<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql 函数</title>
    <link href="/2024/04/21/mysql/mysql%20%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/21/mysql/mysql%20%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ABS(X)  返回X 的绝对值。<br>mysql&gt; SELECT ABS(-32);<br>-&gt; 32<br><br>EXP(X)  返回e的X乘方后的值(自然对数的底)。<br>LN(X)   返回X 的自然对数,即, X 相对于基数e 的对数<br>LOG(X)   若用一个参数调用，这个函数就会返回X 的自然对数。<br>LOG(B,X) 若用两个参数进行调用，这个函数会返回X 对于任意基数B 的对数, LOG(B,X) 就相当于 LOG(X) / LOG(B)。<br>LOG10(X)  返回X的基数为10的对数,LOG10(X)相当于LOG(10,X)。<br>MOD(N,M) , N % M ,  N MOD M  <br>1. 模操作。返回N 被 M除后的余数。<br>2. MOD() 对于带有小数部分的数值也起作用， 它返回除法运算后的精确余数： <br>PI()  返回 ϖ (pi)的值。默认的显示小数位数是7位,然而 MySQL内部会使用完全双精度<br>POW(X,Y) , POWER(X,Y)  返回X 的Y乘方的结果值<br>SIGN(X)   返回参数作为-1、 0或1的符号，该符号取决于X 的值为负、零或正<br><br><br>SQRT(X)   返回非负数X 的二次方根<br><br><br><br><br><br><br><br>mysql&gt; SELECT LOG(2,65536);<br>-&gt; 16<br>mysql&gt; SELECT MOD(34.5,3);<br>-&gt; 1.5<br><br><br><br> <br> <br> <br> <br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ACOS(X)  返回X 反余弦, 即, 余弦是X的值。若X 不在-1到 1的范围之内，则返回 NULL <br>ASIN(X)  返回X 的反正弦，即，正弦为X 的值。若X  若X 不在-1到 1的范围之内，则返回 NULL <br>ATAN(X)  返回X 的反正切，即，正切为X 的值<br>ATAN(Y,X) , ATAN2(Y,X)  返回两个变量X 及Y的反正切。 它类似于 Y 或 X的反正切计算,  除非两个参数的符号均用于确定结果所在象限。<br><br>COS(X)  返回X 的余弦，其中X在弧度上已知<br>SIN(X)  返回X 正弦，其中 X 在弧度中被给定<br>TAN(X)  返回X 的正切，其中X 在弧度中被给定<br><br><br>COT(X)  返回X 的余切<br>DEGREES(X)  返回参数 X, 该参数由弧度被转化为度<br>RADIANS(X)  返回由度转化为弧度的参数 X,  (注意 ϖ 弧度等于180度）。 <br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CEILING(X)  CEIL(X)  返回不小于X 的最小整数值。<br>FLOOR(X)             返回不大于X的最大整数值 <br>ROUND(X)   返回参数X, 其值接近于最近似的整数。<br>ROUND(X,D)  在有两个参数的情况下，返回 X ，其值保留到小数点后D位，而第D位的保留方式为四舍五入。若要接保留X值小数点左边的D 位，可将 D 设为负值<br><br><br>mysql&gt; SELECT CEILING(1.23);<br>-&gt; 2<br><br>mysql&gt; SELECT CEIL(-1.23);<br>-&gt; -1<br><br><br>-------------------<br>返回值的类型同 第一个自变量相同(假设它是一个整数、双精度数或小数)。这意味着对于一个整数参数,结果也是一个整数(无小数部分)。<br><br>当第一个参数是十进制常数时，对于准确值参数，ROUND() 使用精密数学题库：<br><br>对于准确值数字, ROUND() 使用“四舍五入” 或“舍入成最接近的数” 的规则:对于一个分数部分为 .5或大于 .5的值，正数则上舍入到邻近的整数值， 负数则下舍入临近的整数值。(换言之, 其舍入的方向是数轴上远离零的方向）。对于一个分数部分小于.5 的值，正数则下舍入下一个整数值，负数则下舍入邻近的整数值，而正数则上舍入邻近的整数值。 <br>对于近似值数字，其结果根据C 库而定。在很多系统中，这意味着 ROUND()的使用遵循“舍入成最接近的偶数”的规则： 一个带有任何小数部分的值会被舍入成最接近的偶数整数。 <br>以下举例说明舍入法对于精确值和近似值的不同之处： <br><br>mysql&gt; SELECT ROUND(2.5), ROUND(25E-1);<br><br>+------------+--------------+<br><br>| ROUND(2.5) | ROUND(25E-1) |<br><br>+------------+--------------+<br><br>| 3          |            2 |<br><br>+------------+--------------+<br><br><br></code></pre></td></tr></table></figure><h2 id="循环冗余码校验"><a href="#循环冗余码校验" class="headerlink" title="循环冗余码校验"></a>循环冗余码校验</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">CRC32</span>(<span class="hljs-variable">expr</span>) </span><br><span class="hljs-function">计算循环冗余码校验值并返回一个 <span class="hljs-number">32</span>比特无符号值。若参数为<span class="hljs-variable"><span class="hljs-literal">NULL</span></span> ，则结果为 <span class="hljs-variable"><span class="hljs-literal">NULL</span></span>。该参数应为一个字符串，而且在不是字符串的情况下会被作为字符串处理（若有可能）。 </span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">mysql</span>&gt; <span class="hljs-variable">SELECT</span> <span class="hljs-title">CRC32</span>(<span class="hljs-string">&#x27;MySQL&#x27;</span>);</span><br><span class="hljs-function"></span><br><span class="hljs-function">        -&gt; <span class="hljs-number">3259397556</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">mysql</span>&gt; <span class="hljs-variable">SELECT</span> <span class="hljs-title">CRC32</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>);</span><br><span class="hljs-function"></span><br><span class="hljs-function">        -&gt; <span class="hljs-number">2501908538</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FORMAT(X,D)  将数字X 的格式写成&#x27;#,###,###.##&#x27;格式, 即保留小数点后 D位，而第D位的保留方式为四舍五入，然后将结果以字符串的形式返回<br><br>TRUNCATE(X,D) <br>返回被舍去至小数点D位后的数字X。若D 的值为 0, 则结果不带有小数点或不带有小数部分。可以将D设为负数,若要截去(归零) X小数点左起第D位开始后面所有低位的值.  <br><br><br>mysql&gt; SELECT TRUNCATE(-1.999,1);<br>-&gt; -1.9<br><br>mysql&gt; SELECT TRUNCATE(122,-2);<br> -&gt; 100<br><br><br></code></pre></td></tr></table></figure><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RAND() RAND(N) <br>返回一个随机浮点值 v ，范围在 0 到1 之间 (即, 其范围为 0 ≤ v ≤ 1.0)。若已指定一个整数参数 N ，则它被用作种子值，用来产生重复序列。<br><br><br>1. 若要在i ≤ R ≤ j 这个范围得到一个随机整数R ，需要用到表达式 FLOOR(i + RAND() * (j – i + 1))。例如， 若要在7 到 12 的范围（包括7和12）内得到一个随机整数, 可使用以下语句：<br>SELECT FLOOR(7 + (RAND() * 6));<br>2. 在ORDER BY语句中，不能使用一个带有RAND()值的列，原因是 ORDER BY 会计算列的多重时间。然而，可按照如下的随机顺序检索数据行： <br><br>mysql&gt; SELECT * FROM tbl_name ORDER BY RAND();<br><br>3. ORDER BY RAND()同 LIMIT 的结合从一组列中选择随机样本很有用：<br><br>mysql&gt; SELECT * FROM table1, table2 WHERE a=b AND c&lt;d<br><br>    -&gt; ORDER BY RAND() LIMIT 1000;<br><br>注意，在WHERE语句中，WHERE每执行一次， RAND()就会被再计算一次。<br><br>RAND()的作用不是作为一个精确的随机发生器，而是一种用来发生在同样的 MySQL版本的平台之间的可移动ad hoc随机数的快速方式。<br><br><br><br><br></code></pre></td></tr></table></figure><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">返回各自当前日期或时间的函数在每次询问执行开始时计算一次。这意味着在一个单一询问中，对诸如<span class="hljs-built_in">NOW</span>() 的函数多次访问总是会得到同样的结果(未达到我们的目的，单一询问也包括对存储程序或触发器和被该程序/触发器调用的所有子程序的调用 )。这项原则也适用于 <span class="hljs-built_in">CURDATE</span>()、 <span class="hljs-built_in">CURTIME</span>()、 <span class="hljs-built_in">UTC_DATE</span>()、 <span class="hljs-built_in">UTC_TIME</span>()、<span class="hljs-built_in">UTC_TIMESTAMP</span>()，以及所有和它们意义相同的函数。<br><br><br><br></code></pre></td></tr></table></figure><h2 id="current"><a href="#current" class="headerlink" title="current"></a>current</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 返回连接当前时区内的值，这个值可用作time_zone系统变量的值。<br>current_timstamp(), current_timetamp<br>current_time(), current_time<br>  1. 将当前时间以&#x27;HH:MM:SS&#x27;或 HHMMSS 的格式返回， 具体格式根据函数用在字符串或是数字语境中而<br>current_date() , CURRENT_DATE<br>from_unixtime() <br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="datediff"><a href="#datediff" class="headerlink" title="datediff"></a>datediff</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">DATEDIFF</span>(expr,expr2) <br><span class="hljs-built_in">DATEDIFF</span>() 返回起始时间 expr和结束时间expr2之间的天数。Expr和expr2 为日期或 <span class="hljs-built_in">date</span>-and-time 表达式。计算中只用到这些值的日期部分。 <br><br>mysql&gt; SELECT <span class="hljs-built_in">DATEDIFF</span>(<span class="hljs-string">&#x27;1997-12-31 23:59:59&#x27;</span>,<span class="hljs-string">&#x27;1997-12-30&#x27;</span>);<br>-&gt; <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h2 id="day"><a href="#day" class="headerlink" title="day"></a>day</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DAY(date) <br>DAY() 和DAYOFMONTH()的意义相同。<br><br>DAYNAME(date) <br>返回date 对应的工作日名称。<br><br>DAYOFMONTH(date) <br>返回date 对应的该月日期，范围是从 1到31<br><br>DAYOFWEEK(date) <br>返回date (1 = 周日, 2 = 周一, ..., 7 = 周六)对应的工作日索引。这些索引值符合 ODBC标准。<br><br>DAYOFYEAR(date) <br>返回date 对应的一年中的天数，范围是从 1到366。<br><br>LAST_DAY(date) <br>获取一个日期或日期时间值，返回该月最后一天对应的值。若参数无效，则返回NULL。<br><br><br><br><br>mysql&gt; SELECT DAYNAME(&#x27;1998-02-05&#x27;);<br> -&gt; &#x27;周四&#x27;<br> <br>mysql&gt; SELECT DAYOFMONTH(&#x27;1998-02-03&#x27;);<br>-&gt; 3<br><br>mysql&gt; SELECT DAYOFWEEK(&#x27;1998-02-03&#x27;);<br>-&gt; 3<br><br>mysql&gt; SELECT DAYOFYEAR(&#x27;1998-02-03&#x27;);<br>-&gt; 34<br><br><br>mysql&gt; SELECT LAST_DAY(&#x27;2004-02-05&#x27;);<br>-&gt; &#x27;2004-02-29&#x27;<br><br>mysql&gt; SELECT LAST_DAY(&#x27;2004-01-01 01:01:01&#x27;);<br>&gt; &#x27;2004-01-31&#x27;<br><br>mysql&gt; SELECT LAST_DAY(&#x27;2003-03-32&#x27;);<br>-&gt; NULL<br><br></code></pre></td></tr></table></figure><h2 id="获取时间日期中的值"><a href="#获取时间日期中的值" class="headerlink" title="获取时间日期中的值"></a>获取时间日期中的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs mysql">NOW() <br>返回当前日期和时间值，其格式为 &#x27;YYYY-MM-DD HH:MM:SS&#x27; 或YYYYMMDDHHMMSS ， 具体格式取决于该函数是否用在字符串中或数字语境中。 <br>1. 在一个存储程序或触发器内, NOW() 返回一个常数时间，该常数指示了该程序或触发语句开始执行的时间。这同SYSDATE()的运行有所不同。<br><br>MONTHNAME(date) <br>返回date 对应月份的全名。 <br> <br>MONTH(date) <br>返回date 对应的月份，范围时从 1 到 12。<br><br><br>DATE(expr) <br>提取日期或时间日期表达式expr中的日期部分<br><br><br>HOUR(time) <br>返回time 对应的小时数。对于日时值的返回值范围是从 0 到 23 。<br><br>MINUTE(time) <br>返回 time 对应的分钟数,范围是从 0 到 59。<br><br>MICROSECOND(expr) <br>从时间或日期时间表达式expr返回微秒值，其数字范围从 0到 999999<br><br>--------------<br>mysql&gt; SELECT NOW();<br>-&gt; &#x27;1997-12-15 23:50:26&#x27;<br><br>mysql&gt; SELECT MONTHNAME(&#x27;1998-02-05&#x27;);<br>-&gt; &#x27;February &#x27;<br><br>mysql&gt; SELECT MONTH(&#x27;1998-02-03&#x27;);<br>-&gt; 2<br><br><br><br>mysql&gt; SELECT DATE(&#x27;2003-12-31 01:02:03&#x27;);<br>-&gt; &#x27;2003-12-31&#x27;<br><br>-- 然而,  TIME 值的范围实际上非常大, 所以HOUR可以返回大于23的值。<br>mysql&gt; SELECT HOUR(&#x27;10:05:03&#x27;);<br>-&gt; 10<br><br><br>mysql&gt; SELECT MINUTE(&#x27;98-02-03 10:05:03&#x27;);<br>-&gt; 5<br><br><br>mysql&gt; SELECT MICROSECOND(&#x27;12:00:00.123456&#x27;);<br>-&gt; 123456<br></code></pre></td></tr></table></figure><h2 id="日期时间增减"><a href="#日期时间增减" class="headerlink" title="日期时间增减"></a>日期时间增减</h2><h3 id="adddate"><a href="#adddate" class="headerlink" title="adddate"></a>adddate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ADDDATE(expr,days)  <br><br>-- 若 days 参数只是整数值，则 MySQL 5.1将其作为天数值添加至 expr。 <br>mysql&gt; SELECT ADDDATE(&#x27;1998-01-02&#x27;, 31);<br>-&gt; &#x27;1998-02-02&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="addtime"><a href="#addtime" class="headerlink" title="addtime"></a>addtime</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ADDTIME(expr,expr2) <br>ADDTIME()将 expr2添加至expr 然后返回结果。 expr 是一个时间或时间日期表达式，而expr2 是一个时间表达式。 <br><br>mysql&gt; SELECT ADDTIME(&#x27;1997-12-31 23:59:59.999999&#x27;, &#x27;1 1:1:1.000002&#x27;);<br>-&gt; &#x27;1998-01-02 01:01:01.000001&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="date-add"><a href="#date-add" class="headerlink" title="date_add"></a>date_add</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ADDDATE(date,INTERVAL expr type)<br>DATE_ADD(date,INTERVAL expr type)<br>DATE_SUB(date,INTERVAL expr type) <br><br>-- 关键词INTERVA及 type 分类符均不区分大小写。 <br>date 是一个 DATETIME 或DATE值，用来指定起始时间。<br>expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。  <br>Expr是一个字符串;对于负值的时间间隔，它可以以一个 ‘-’开头。<br>type 为关键词，它指示了表达式被解释的方式。<br> <br> <br> -- 若位于另一端的表达式是一个日期或日期时间值 ， 则INTERVAL expr type只允许在 + 操作符的两端。<br> -- 对于 –操作符，  INTERVAL expr type 只允许在其右端，原因是从一个时间间隔中提取一个日期或日期时间值是毫无意义的<br> mysql&gt; SELECT DATE_ADD(&#x27;1998-01-02&#x27;, INTERVAL 31 DAY);<br>-&gt; &#x27;1998-02-02&#x27;x`<br><br>mysql&gt; SELECT &#x27;1997-12-31 23:59:59&#x27; + INTERVAL 1 SECOND;<br>-&gt; &#x27;1998-01-01 00:00:00&#x27;<br><br>mysql&gt; SELECT &#x27;1998-01-01&#x27; - INTERVAL 1 SECOND;<br>-&gt; &#x27;1997-12-31 23:59:59&#x27;<br><br>mysql&gt; SELECT DATE_ADD(&#x27;1997-12-31 23:59:59&#x27;, INTERVAL 1 DAY);<br>-&gt; &#x27;1998-01-01 23:59:59&#x27;<br><br>mysql&gt; SELECT DATE_SUB(&#x27;1998-01-01 00:00:00&#x27;, INTERVAL &#x27;1 1:1:1&#x27; DAY_SECOND);<br>-&gt; &#x27;1997-12-30 22:58:59&#x27;<br><br>-- 注意<br>1. 【尽量使用标准的格式】<br>若你指定了一个过于短的时间间隔值 (不包括type 关键词所预期的所有时间间隔部分), MySQL 假定你已经省去了时间间隔值的最左部分。 例如，你指定了一种类型的DAY_SECOND, expr 的值预期应当具有天、 小时、分钟和秒部分。若你指定了一个类似 &#x27;1:10&#x27;的值, MySQL 假定天和小时部分不存在，那么这个值代表分和秒。换言之, &#x27;1:10&#x27; DAY_SECOND 被解释为相当于 &#x27;1:10&#x27; MINUTE_SECOND。这相当于 MySQL将TIME 值解释为所耗费的时间而不是日时的解释方式。<br><br>2. 假如你对一个日期值添加或减去一些含有时间部分的内容，则结果自动转化为一个日期时间值：<br>mysql&gt; SELECT DATE_ADD(&#x27;1999-01-01&#x27;, INTERVAL 1 HOUR);<br> -&gt; &#x27;1999-01-01 01:00:00&#x27;<br><br>3. 假如你使用了格式严重错误的日期,则结果为 NULL。假如你添加了  MONTH、YEAR_MONTH或YEAR ，而结果日期中有一天的日期大于添加的月份的日期最大限度，则这个日期自动被调整为添加月份的最大日期：<br>mysql&gt; SELECT DATE_ADD(&#x27;1998-01-30&#x27;, INTERVAL 1 MONTH);<br>-&gt; &#x27;1998-02-28&#x27;<br><br><br><br></code></pre></td></tr></table></figure><table><thead><tr><th><em>type</em> <strong>值</strong></th><th><strong>预期的</strong> <em>expr</em>  <strong>格式</strong></th><th></th></tr></thead><tbody><tr><td>MICROSECOND</td><td>MICROSECONDS</td><td></td></tr><tr><td>SECOND</td><td>SECONDS</td><td></td></tr><tr><td>MINUTE</td><td>MINUTES</td><td></td></tr><tr><td>HOUR</td><td>HOURS</td><td></td></tr><tr><td>DAY</td><td>DAYS</td><td></td></tr><tr><td>WEEK</td><td>WEEKS</td><td></td></tr><tr><td>MONTH</td><td>MONTHS</td><td></td></tr><tr><td>QUARTER</td><td>QUARTERS</td><td></td></tr><tr><td>YEAR</td><td>YEARS</td><td></td></tr><tr><td>SECOND_MICROSECOND</td><td>‘SECONDS.MICROSECONDS’</td><td></td></tr><tr><td>MINUTE_MICROSECOND</td><td>‘MINUTES.MICROSECONDS’</td><td></td></tr><tr><td>MINUTE_SECOND</td><td>‘MINUTES:SECONDS’</td><td></td></tr><tr><td>HOUR_MICROSECOND</td><td>‘HOURS.MICROSECONDS’</td><td></td></tr><tr><td>HOUR_SECOND</td><td>‘HOURS:MINUTES:SECONDS’</td><td></td></tr><tr><td>HOUR_MINUTE</td><td>‘HOURS:MINUTES’</td><td></td></tr><tr><td>DAY_MICROSECOND</td><td>‘DAYS.MICROSECONDS’</td><td></td></tr><tr><td>DAY_SECOND</td><td>‘DAYS HOURS:MINUTES:SECONDS’</td><td></td></tr><tr><td>DAY_MINUTE</td><td>‘DAYS HOURS:MINUTES’</td><td></td></tr><tr><td>DAY_HOUR</td><td>‘DAYS HOURS’</td><td></td></tr><tr><td>YEAR_MONTH</td><td>‘YEARS-MONTHS’</td><td></td></tr></tbody></table><h3 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXTRACT(type FROM date) <br>EXTRACT()函数所使用的时间间隔类型说明符同 DATE_ADD()或DATE_SUB()的相同,但它从日期中提取其部分，而不是执行日期运算。  <br><br>mysql&gt; SELECT EXTRACT(YEAR FROM &#x27;1999-07-02&#x27;);<br>-&gt; 1999<br><br>mysql&gt; SELECT EXTRACT(YEAR_MONTH FROM &#x27;1999-07-02 01:02:03&#x27;);<br>-&gt; 199907<br><br></code></pre></td></tr></table></figure><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><h3 id="date-formate"><a href="#date-formate" class="headerlink" title="date_formate"></a>date_formate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DATE_FORMAT(date,format) <br>根据format 字符串安排date 值的格式。<br><br><br><br>注意：<br>1. 月份和日期说明符的范围从零开始，原因是 MySQL允许存储诸如 &#x27;2004-00-00&#x27;的不完全日期. <br>2. <br><br><br>mysql&gt; SELECT DATE_FORMAT(&#x27;1997-10-04 22:23:00&#x27;, &#x27;%W %M %Y&#x27;);<br>-&gt; &#x27;Saturday October 1997&#x27;<br><br>mysql&gt; SELECT DATE_FORMAT(&#x27;1997-10-04 22:23:00&#x27;,  &#x27;%H %k %I %r %T %S %w&#x27;);<br>-&gt; &#x27;22 22 10 10:23:00 PM 22:23:00 00 6&#x27;<br><br><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>明符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>%a</td><td>工作日的缩写名称 (Sun..Sat)</td></tr><tr><td>%b</td><td>月份的缩写名称  (Jan..Dec)</td></tr><tr><td>%c</td><td>月份，数字形式(0..12)</td></tr><tr><td>%D</td><td>带有英语后缀的该月日期 (0th,  1st, 2nd,  3rd, …)</td></tr><tr><td>%d</td><td>该月日期, 数字形式  (00..31)</td></tr><tr><td>%e</td><td>该月日期,  数字形式(0..31)</td></tr><tr><td>%f</td><td>微秒  (000000..999999)</td></tr><tr><td>%H</td><td>小时(00..23)</td></tr><tr><td>%h</td><td>小时(01..12)</td></tr><tr><td>%I</td><td>小时  (01..12)</td></tr><tr><td>%i</td><td>分钟,数字形式  (00..59)</td></tr><tr><td>%j</td><td>一年中的天数  (001..366)</td></tr><tr><td>%k</td><td>小时  (0..23)</td></tr><tr><td>%l</td><td>小时  (1..12)</td></tr><tr><td>%M</td><td>月份名称  (January..December)</td></tr><tr><td>%m</td><td>月份, 数字形式  (00..12)</td></tr><tr><td>%p</td><td>上午（AM）或下午（  PM）</td></tr><tr><td>%r</td><td>时间 , 12小时制  (小时hh:分钟mm:秒数ss  后加  AM或PM)</td></tr><tr><td>%S</td><td>秒  (00..59)</td></tr><tr><td>%s</td><td>秒  (00..59)</td></tr><tr><td>%T</td><td>时间 , 24小时制  (小时hh:分钟mm:秒数ss)</td></tr><tr><td>%U</td><td>周  (00..53),  其中周日为每周的第一天</td></tr><tr><td>%u</td><td>周  (00..53),  其中周一为每周的第一天</td></tr><tr><td>%V</td><td>周  (01..53),  其中周日为每周的第一天 ; 和  %X同时使用</td></tr><tr><td>%v</td><td>周  (01..53),  其中周一为每周的第一天 ; 和  %x同时使用</td></tr><tr><td>%W</td><td>工作日名称  (周日..周六)</td></tr><tr><td>%w</td><td>一周中的每日  (0&#x3D;周日..6&#x3D;周六)</td></tr><tr><td>%X</td><td>该周的年份，其中周日为每周的第一天,  数字形式,4位数;和%V同时使用</td></tr><tr><td>%x</td><td>该周的年份，其中周一为每周的第一天,  数字形式,4位数;和%v同时使用</td></tr><tr><td>%Y</td><td>年份,  数字形式,4位数</td></tr><tr><td>%y</td><td>年份, 数字形式  (2位数)</td></tr><tr><td>%%</td><td>‘%’文字字符</td></tr></tbody></table><h3 id="get-formate"><a href="#get-formate" class="headerlink" title="get_formate"></a>get_formate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GET_FORMAT(DATE|TIME|DATETIME, &#x27;EUR&#x27;|&#x27;USA&#x27;|&#x27;JIS&#x27;|&#x27;ISO&#x27;|&#x27;INTERNAL&#x27;) <br>参数1： date, time, datetime<br>参数2： eur, usa, jis, iso, internal<br><br>注意<br>1. ISO 格式为ISO 9075, 而非ISO 8601<br><br><br>mysql&gt; SELECT DATE_FORMAT(&#x27;2003-10-03&#x27;,GET_FORMAT(DATE,&#x27;EUR&#x27;));<br>-&gt; &#x27;03.10.2003&#x27;<br><br>mysql&gt; SELECT STR_TO_DATE(&#x27;10.31.2003&#x27;,GET_FORMAT(DATE,&#x27;USA&#x27;));<br> -&gt; &#x27;2003-10-31&#x27;<br><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数调用</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>GET_FORMAT(DATE,’USA’)</td><td>‘%m.%d.%Y’</td></tr><tr><td>GET_FORMAT(DATE,’JIS’)</td><td>‘%Y-%m-%d’</td></tr><tr><td>GET_FORMAT(DATE,’ISO’)</td><td>‘%Y-%m-%d’</td></tr><tr><td>GET_FORMAT(DATE,’EUR’)</td><td>‘%d.%m.%Y’</td></tr><tr><td>GET_FORMAT(DATE,’INTERNAL’)</td><td>‘%Y%m%d’</td></tr><tr><td>GET_FORMAT(DATETIME,’USA’)</td><td>‘%Y-%m-%d-%H.%i.%s’</td></tr><tr><td>GET_FORMAT(DATETIME,’JIS’)</td><td>‘%Y-%m-%d %H:%i:%s’</td></tr><tr><td>GET_FORMAT(DATETIME,’ISO’)</td><td>‘%Y-%m-%d %H:%i:%s’</td></tr><tr><td>GET_FORMAT(DATETIME,’EUR’)</td><td>‘%Y-%m-%d-%H.%i.%s’</td></tr><tr><td>GET_FORMAT(DATETIME,’INTERNAL’)</td><td>‘%Y%m%d%H%i%s’</td></tr><tr><td>GET_FORMAT(TIME,’USA’)</td><td>‘%h:%i:%s %p’</td></tr><tr><td>GET_FORMAT(TIME,’JIS’)</td><td>‘%H:%i:%s’</td></tr><tr><td>GET_FORMAT(TIME,’ISO’)</td><td>‘%H:%i:%s’</td></tr><tr><td>GET_FORMAT(TIME,’EUR’)</td><td>‘%H.%i.%S’</td></tr><tr><td>GET_FORMAT(TIME,’INTERNAL’)</td><td>‘%H%i%s’</td></tr></tbody></table><h2 id="convert-tz"><a href="#convert-tz" class="headerlink" title="convert_tz"></a>convert_tz</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CONVERT_TZ(dt,from_tz,to_tz) <br>CONVERT_TZ() 将时间日期值dt 从from_tz 给出的时区转到to_tz给出的时区，然后返回结果值。关于可能指定的时区的详细论述，请参见5.10.8节，“MySQL服务器时区支持”。若自变量无效，则这个函数会返回 NULL。<br><br>1. 在从若from_tz 到UTC的转化过程中，该值超出 TIMESTAMP 类型的被支持范围，那么转化不会发生。关于 TIMESTAMP 范围的论述，请参见11.1.2节，“日期和时间类型概述”。 <br>2. 若要使用诸如 &#x27;MET&#x27;或 &#x27;Europe/Moscow&#x27;之类的指定时间区，首先要设置正确的时区表<br><br>mysql&gt; SELECT CONVERT_TZ(&#x27;2004-01-01 12:00:00&#x27;,&#x27;GMT&#x27;,&#x27;MET&#x27;);<br><br>        -&gt; &#x27;2004-01-01 13:00:00&#x27;<br><br><br></code></pre></td></tr></table></figure><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><h3 id="from-day"><a href="#from-day" class="headerlink" title="from_day"></a>from_day</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FROM_DAYS(N) <br>给定一个天数  N, 返回一个DATE值。<br><br>-- 使用 FROM_DAYS()处理古老日期时，务必谨慎。他不用于处理阳历出现前的日期(1582)。<br>mysql&gt; SELECT FROM_DAYS(729669);<br>-&gt; &#x27;1997-10-07&#x27;<br><br><br></code></pre></td></tr></table></figure><h3 id="from-unixtime"><a href="#from-unixtime" class="headerlink" title="from_unixtime"></a>from_unixtime</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FROM_UNIXTIME(unix_timestamp) ,<br>FROM_UNIXTIME(unix_timestamp,format) <br><br>返回&#x27;YYYY-MM-DD HH:MM:SS&#x27;或YYYYMMDDHHMMSS 格式值的unix_timestamp参数表示，具体格式取决于该函数是否用在字符串中或是数字语境中。 <br>若format 已经给出，则结果的格式是根据format 字符串而定。 format 可以包含同DATE_FORMAT() 函数输入项列表中相同的说明符。<br><br><br>mysql&gt; SELECT FROM_UNIXTIME(875996580);<br>-&gt; &#x27;1997-10-04 22:23:00&#x27;<br>mysql&gt; SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), &#x27;%Y %D %M %h:%i:%s %x&#x27;);<br>-&gt; &#x27;2003 6th August 06:22:58 2003&#x27;<br><br></code></pre></td></tr></table></figure><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCALTIME, LOCALTIME() <br>LOCALTIME 及 LOCALTIME()和NOW()具有相同意义。<br><br>LOCALTIMESTAMP, LOCALTIMESTAMP() <br>LOCALTIMESTAMP和LOCALTIMESTAMP()和NOW()具有相同意义。<br><br><br></code></pre></td></tr></table></figure><h2 id="创建时间"><a href="#创建时间" class="headerlink" title="创建时间"></a>创建时间</h2><h3 id="make-date"><a href="#make-date" class="headerlink" title="make_date"></a>make_date</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">MAKEDATE(year,dayofyear) <br>给出年份值和一年中的天数值，返回一个日期。dayofyear 必须大于 0 ，否则结果为 NULL。<br><br>MAKETIME(hour,minute,second) <br>返回由hour、 minute和second 参数计算得出的时间值<br><br><br><br>mysql&gt; SELECT MAKEDATE(2001,31), MAKEDATE(2001,32);<br>-&gt; &#x27;2001-01-31&#x27;, &#x27;2001-02-01&#x27;<br><br><br>mysql&gt; SELECT MAKETIME(12,15,30);<br>-&gt; &#x27;12:15:30&#x27;<br><br></code></pre></td></tr></table></figure><h1 id="mysql类型转换"><a href="#mysql类型转换" class="headerlink" title="mysql类型转换"></a>mysql类型转换</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MySQL 会自动将数字转化为字符串，反之亦然。 <br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>+<span class="hljs-string">&#x27;1&#x27;</span>;<br><br>        -&gt; <span class="hljs-number">2</span><br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27; test&#x27;</span>);<br><br>        -&gt; <span class="hljs-string">&#x27;2 test&#x27;</span><br><br></code></pre></td></tr></table></figure><h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><h2 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h2><h3 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">将数字明确地转化为字符串，可使用 <span class="hljs-built_in">CAST</span>()或 <span class="hljs-built_in">CONCAT</span>()函数：<br><br><span class="hljs-built_in">CAST</span>() 比较可取。. <br><br>若已经对一个字符串函数给定一个二进制字符串作为参数， 则所得到的结果字符串也是一个二进制字符串。一个转化为字符串的数字被作为二进制字符串对待。这仅会对比较结果产生影响<br><br></code></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="load-file"><a href="#load-file" class="headerlink" title="load_file"></a>load_file</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LOAD_FILE</span><span class="hljs-params">(file_name)</span></span> <br>读取服务器上的某个文件<br>特点<br><span class="hljs-number">1</span>. 件的位置必须在服务器上,你必须为文件制定路径全名，而且你还必须拥有FILE 特许权。文件必须可读取，文件容量必须小于 max_allowed_packet字节。 <br><span class="hljs-number">2</span>. 若文件不存在，或因不满足上述条件而不能被读取， 则函数返回值为 NULL。<br><br><br><br></code></pre></td></tr></table></figure><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FORMAT(X,D) <br> 将number X设置为格式 &#x27;#,###,###.##&#x27;, 以四舍五入的方式保留到小数点后D位, 而返回结果为一个字符串<br></code></pre></td></tr></table></figure><h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> <br>char(N, ...[unsigned charset]) <br>1. 将每个参数N理解为一个整数，其返回值为一个包含这些整数的代码值所给出的字符的字符串。NULL值被省略。 <br>select CHAR(77, 121, 83, 81, 76) -&gt; MySql<br>    2. 大于 255的CHAR()参数被转换为多结果字符<br>CHAR(256) 相当于 CHAR(1,0), <br>CHAR(256*256) 则相当于 CHAR(1,0,0)：  (1,0)*(1,0) = 1,0,0<br></code></pre></td></tr></table></figure><h2 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">COMPRESS(string_to_compress) <br>压缩一个字符串<br>UNCOMPRESS()<br>可将压缩过的字符串进行解压缩<br><br>存储方式<br>1. 空字符串按照空字符串存储。 <br>2. 非空字符串未压缩字符串的四字节长度进行存储(首先为低字节),后面是压缩字符串。如果字符串以空格结尾，就会在后加一个&quot;.&quot;号,以防止当结果值是存储在CHAR或VARCHAR类型的字段列时,出现自动把结尾空格去掉的现象。(不推荐使用 CHAR 或VARCHAR 来存储压缩字符串。最好使用一个 BLOB 列代替）。<br><br><br>mysql&gt; SELECT LENGTH(COMPRESS(&#x27;a&#x27;));<br>-&gt; 13<br><br></code></pre></td></tr></table></figure><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="ord"><a href="#ord" class="headerlink" title="ord"></a>ord</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ORD</span></span>(<span class="hljs-variable">str</span>) </span><br><span class="hljs-function">若字符串<span class="hljs-variable">str</span> 的最左字符是一个多字节字符，则返回该字符的代码， 代码的计算通过使用以下公式计算其组成字节的数值而得出: </span><br><span class="hljs-function"></span><br><span class="hljs-function">   (<span class="hljs-number">1</span><span class="hljs-variable">st</span> <span class="hljs-variable">byte</span> <span class="hljs-variable">code</span>)</span><br>+ (<span class="hljs-number">2</span><span class="hljs-variable">nd</span> <span class="hljs-variable">byte</span> <span class="hljs-variable">code</span> × <span class="hljs-number">256</span>)<br>+ (<span class="hljs-number">3</span><span class="hljs-variable">rd</span> <span class="hljs-variable">byte</span> <span class="hljs-variable">code</span> × <span class="hljs-number">2562</span>) ...<br> <br><br>假如最左字符不是一个多字节字符，那么 <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ORD</span></span>()和函数<span class="hljs-title">ASCII</span>()返回相同的值。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">mysql</span>&gt; <span class="hljs-variable">SELECT</span> <span class="hljs-title"><span class="hljs-built_in">ORD</span></span>(<span class="hljs-string">&#x27;2&#x27;</span>);</span><br><span class="hljs-function"></span><br><span class="hljs-function">        -&gt; <span class="hljs-number">50</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h2 id="查询索引元素"><a href="#查询索引元素" class="headerlink" title="查询索引元素"></a>查询索引元素</h2><h3 id="instr"><a href="#instr" class="headerlink" title="instr"></a>instr</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSTR(str,substr)<br>含义：返回字符串 str 中子字符串的第一个出现位置<br><br>mysql&gt; SELECT INSTR(&#x27;foobarbar&#x27;, &#x27;bar&#x27;);<br>&gt; 4<br><br>mysql&gt; SELECT INSTR(&#x27;xbar&#x27;, &#x27;foobar&#x27;);<br>-&gt; 0<br><br></code></pre></td></tr></table></figure><h3 id="locate-1"><a href="#locate-1" class="headerlink" title="locate"></a>locate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCATE(substr,str) <br>返回字符串 str中子字符串substr的第一个出现位置<br>不存在返回 0<br>LOCATE(substr,str,pos) <br>返回字符串 str中子字符串substr的自 pos 位置往后的第一个出现位置<br>不存在返回 0<br><br>mysql&gt; SELECT LOCATE(&#x27;bar&#x27;, &#x27;foobarbar&#x27;);<br>-&gt; 4<br><br>mysql&gt; SELECT LOCATE(&#x27;xbar&#x27;, &#x27;foobar&#x27;);<br>-&gt; 0<br><br>mysql&gt; SELECT LOCATE(&#x27;bar&#x27;, &#x27;foobarbar&#x27;,5);<br>-&gt; 7<br><br><br><br></code></pre></td></tr></table></figure><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">POSITION</span>(substr IN str)是 <span class="hljs-built_in">LOCATE</span>(substr,str)同义词。<br></code></pre></td></tr></table></figure><h3 id="field"><a href="#field" class="headerlink" title="field"></a>field</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FIELD(str,str1,str2,str3,...) <br>获取 str 在 str1, str2, str3, ... 中的位置，从 1 开始<br>参数<br>str=null 则返回 0， 原因是NULL不能同任何值进行同等比较<br><br># 找到 ej 在后面字符串中的位置， 找不到就返回 0<br>mysql&gt; SELECT FIELD(&#x27;ej&#x27;, &#x27;Hej&#x27;, &#x27;ej&#x27;, &#x27;Heja&#x27;, &#x27;hej&#x27;, &#x27;foo&#x27;);<br>-&gt; 2<br><br><br></code></pre></td></tr></table></figure><h3 id="find-in-set"><a href="#find-in-set" class="headerlink" title="find_in_set"></a>find_in_set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FIND_IN_SET(str,strlist) <br>  获取 str 在 strlist 中的第一个字符的索引位置<br>str : <br>1.包含逗号会让函数无法运行<br>2. 值为 null 就会返回 null<br>3. str不在 strlist 中，或者 strlist 为空，则返回 0<br>strlist : <br>1. 需要是一些被‘,’符号分开的字符串组成的字符串<br>2. 是 type set 列，则 该函数会被优化，使用比特计算<br><br>案例<br>mysql-&gt;select find_in_set(&#x27;b&#x27;, &#x27;a,b,c&#x27;)  <br>-&gt;2<br><br><br></code></pre></td></tr></table></figure><h3 id="elt"><a href="#elt" class="headerlink" title="elt"></a>elt</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">ELT(N,str1,str2,str3,...) <br>从 N 后面的参数中选择一个.<br>若N = <span class="hljs-number">1</span>，则返回值为  str1 ，若N = <span class="hljs-number">2</span>，则返回值为 str2 ，以此类推<br>mysql-&gt;slect elt<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;ej&#x27;</span>， <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;hkj&#x27;</span>)</span></span><br><span class="hljs-function">-&gt;</span><span class="hljs-string">&#x27;ej&#x27;</span><br><br><br></code></pre></td></tr></table></figure><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LENGTH(str) <br>1. 返回值为字符串str 的长度，单位为字节<br>2. 对于一个包含5个2字节字符的字符串， LENGTH() 的返回值为 10, 而 CHAR_LENGTH()的返回值则为5。<br><br>mysql&gt; SELECT LENGTH(&#x27;text&#x27;);<br>&gt; 4<br><br></code></pre></td></tr></table></figure><h3 id="char-length"><a href="#char-length" class="headerlink" title="char_length"></a>char_length</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">CHAR_LENGTH</span>(str)  <br>返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符<br><br>注意： <br>对于一个包含五个二字节字符集, <span class="hljs-built_in">LENGTH</span>()返回值为 <span class="hljs-number">10</span>, 而<span class="hljs-built_in">CHAR_LENGTH</span>()的返回值为<span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><h3 id="character-length"><a href="#character-length" class="headerlink" title="character_length"></a>character_length</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">CHARACTER_LENGTH</span><span class="hljs-params">(str)</span></span> 就是  char_length<br></code></pre></td></tr></table></figure><h3 id="bit-length-str"><a href="#bit-length-str" class="headerlink" title="bit_length(str)"></a>bit_length(str)</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">bit_length</span><span class="hljs-params">(str)</span></span>  返回二进制字符串的长度， 即将 str 的二进制形式的长度<br></code></pre></td></tr></table></figure><h3 id="octet-length"><a href="#octet-length" class="headerlink" title="octet_length"></a>octet_length</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">OCTET_LENGTH() 是 LENGTH()的同义词。<br></code></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="ASCII-str"><a href="#ASCII-str" class="headerlink" title="ASCII(str)"></a>ASCII(str)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CAST()函数将某个值转为另外一种类型。 使用CONVERT()将字符串值转为不同的字符集<br><br><br>ASCII(str) : 获取 str 的 ascii 码值<br>str=null, 返回为 null<br>str=空字符， 返回为 0<br>str 适用： 带有从 0到255的数值的字符。<br><br>案例<br>ascii(&#x27;2&#x27;) ==&gt; 50<br>ascii(2) ==&gt; 50<br><br><br></code></pre></td></tr></table></figure><h3 id="bin-N"><a href="#bin-N" class="headerlink" title="bin(N)"></a>bin(N)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">结果： 返回 N 的二进制的字符串表示<br>参数：<br>1. N 为一个longlong (BIGINT) 数字<br>2. 为 null 则返回 null<br><br>案例<br>mysql&gt;select bin(12)<br>-&gt;&#x27;1100&#x27;<br><br><br></code></pre></td></tr></table></figure><h3 id="conv"><a href="#conv" class="headerlink" title="conv"></a>conv</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">CONV(N,from_base,to_base) <br>将 from_base 进制的 N 转换为 to_base 进制的数<br><span class="hljs-number">1.</span> 参数中不能有 <span class="hljs-literal">null</span> ,否则返回 <span class="hljs-literal">null</span><br><span class="hljs-number">2.</span> 支持的进制为 [<span class="hljs-number">2</span>, <span class="hljs-number">36</span>]<br><br>mysql-&gt;select conv<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&#x27;a&#x27;</span>，<span class="hljs-number">16</span>,<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function">-&gt;</span><span class="hljs-string">&#x27;1010&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="oct"><a href="#oct" class="headerlink" title="oct"></a>oct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">OCT(N) <br>返回一个 N的八进制值的字符串表示，其中 N 是一个longlong (BIGINT)数。这等同于CONV(N,10,8)。若N 为 NULL ，则返回值为NULL。<br><br>mysql-&gt;select oct(12)<br>-&gt;&#x27;14&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="unhex"><a href="#unhex" class="headerlink" title="unhex"></a>unhex</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNHEX(str) <br>将十六进制字符串转化为普通的字符串<br><br>mysql&gt; SELECT UNHEX(&#x27;4D7953514C&#x27;);<br>-&gt; &#x27;MySQL&#x27;<br><br>mysql&gt; SELECT 0x4D7953514C;<br>-&gt; &#x27;MySQL&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">HEX</span><span class="hljs-params">(N_or_S)</span></span> <br><span class="hljs-number">1</span>. N_or_S 是一个数字： 返回该值的十六进制字符串<br><span class="hljs-number">2</span>. N_or_S 是一个字符串： 则其中的每个字符会被转化为两个十六进制数字<br></code></pre></td></tr></table></figure><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><h3 id="lcase"><a href="#lcase" class="headerlink" title="lcase"></a>lcase</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LCASE</span><span class="hljs-params">(str)</span></span> <br><span class="hljs-function"><span class="hljs-title">LCASE</span><span class="hljs-params">()</span></span> 是 <span class="hljs-built_in">LOWER</span>()的同义词。<br><br></code></pre></td></tr></table></figure><h3 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">LOWER(str) <br>返回字符串 str 以及所有根据最新的字符集映射表变为小写字母的字符 (默认为  cp1252 Latin1)。<br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> LOWER(<span class="hljs-string">&#x27;QUADRATICALLY&#x27;</span>);<br>-&gt; <span class="hljs-string">&#x27;quadratically&#x27;</span><br><br></code></pre></td></tr></table></figure><h3 id="ucase"><a href="#ucase" class="headerlink" title="ucase"></a>ucase</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">UCASE</span>()是<span class="hljs-built_in">UPPER</span>()的同义词。<br></code></pre></td></tr></table></figure><h3 id="upper"><a href="#upper" class="headerlink" title="upper"></a>upper</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPPER(str) <br>返回字符串str， 以及根据最新字符集映射转化为大写字母的字符 (默认为cp1252 Latin1). <br><br>mysql-&gt;select upper(&#x27;mysql&#x27;)<br>-&gt;MYSQL<br></code></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="cast-1"><a href="#cast-1" class="headerlink" title="cast"></a>cast</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><h3 id="contact"><a href="#contact" class="headerlink" title="contact"></a>contact</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">CONCAT(str1,str2,...)   <br>连接字符串<br><br>参数转型： <br><span class="hljs-number">1.</span> 参数有 <span class="hljs-literal">null</span>, 返回值就是 <span class="hljs-literal">null</span><br><span class="hljs-number">2.</span> 参数有 二进制字符串， 其他参数跟同转为二进制字符串<br><br>案例<br>mysql-&gt;select concat<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&#x27;My&#x27;</span>, <span class="hljs-string">&#x27;Sql&#x27;</span>)</span></span><br><span class="hljs-function">-&gt;</span><span class="hljs-string">&#x27;MySql&#x27;</span><br>mysql-&gt;select concat<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&#x27;My&#x27;</span>, <span class="hljs-string">&#x27;Sql&#x27;</span>, NULL)</span></span><br><span class="hljs-function">-&gt;</span>NULL<br></code></pre></td></tr></table></figure><h3 id="concat-ws"><a href="#concat-ws" class="headerlink" title="concat_ws"></a>concat_ws</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CONCAT_WS(separator,str1,str2,...) <br>concat 的特殊形式，即 concat_with_separator, <br>特殊<br>如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。<br>不会忽略任何空字符串。然而会忽略所有的 null<br>案例<br>mysql-&gt; select concat_ws(&#x27;,&#x27;, &#x27;lisi&#x27;， &#x27;zhangsan&#x27;, &#x27;wangwu&#x27;)<br>-&gt;&#x27;lisi,zhangsan,wangwu&#x27;<br></code></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REPEAT(str,count) <br>将 str 重复 count 次，组成一个新的字符串<br>返回一个由重复的字符串str 组成的字符串，字符串str的数目等于count 。 若 count &lt;= 0,则返回一个空字符串。若str 或 count 为 NULL，则返回 NULL 。<br><br><br>mysql-&gt;selct repeat(&#x27;mysql&#x27;, 3)<br>-&gt;&#x27;mysqlmysqlmysql&#x27;<br></code></pre></td></tr></table></figure><h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><h3 id="mid"><a href="#mid" class="headerlink" title="mid"></a>mid</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">MID(str,pos,len) 是 SUBSTRING(str,pos,len)的同义词。<br><br></code></pre></td></tr></table></figure><h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 从 str 的 pos 的位置开始截取长度 len 的子字符串<br>-- pos 正值[从左往右数] 负值 [从右往左数]<br>-- len 省略[截取到字符串结尾], 小于1 会得到空字符串<br>SUBSTRING(str,pos) , <br>SUBSTRING(str,pos,len) ,<br><br><br>SUBSTRING(str FROM pos) <br>SUBSTRING(str FROM pos FOR len) <br><br># mysql 是从 1 开始数数的<br>mysql-&gt; select substring(&#x27;mysql132456&#x27;, 5)<br>-&gt;&#x27;l132456&#x27;<br>mysql-&gt; select substring(&#x27;mysql123456&#x27; FROM 5)<br>-&gt;&#x27;l132456&#x27;<br>mysql-&gt; select substring(&#x27;mysql123456&#x27; FROM 5)<br>-&gt;&#x27;l132456&#x27;<br></code></pre></td></tr></table></figure><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SUBSTR</span>()是 <span class="hljs-built_in">SUBSTRING</span>()的同义词。<br></code></pre></td></tr></table></figure><h3 id="substring-index"><a href="#substring-index" class="headerlink" title="substring_index"></a>substring_index</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SUBSTRING_INDEX(str,delim,count) <br>从 str 中截取 delim 第 count 处出现的位置，到开始或者结尾的字符串<br>在定界符 delim 以及count 出现前，从字符串str返回自字符串。若count为正值,则返回最终定界符(从左边开始)左边的一切内容。若count为负值，则返回定界符（从右边开始）右边的一切内容。<br><br><br># count 大于 0 。 从开始到count索引处<br>mysql&gt; SELECT SUBSTRING_INDEX(&#x27;www.mysql.com&#x27;, &#x27;.&#x27;, 2);<br>-&gt; &#x27;www.mysql&#x27;<br><br># count 小于 0 。 从count索引处到结尾，注意从结尾数<br>mysql&gt; SELECT SUBSTRING_INDEX(&#x27;www.mysql.com&#x27;, &#x27;.&#x27;, -2);<br>-&gt; &#x27;mysql.com&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="right"><a href="#right" class="headerlink" title="right"></a>right</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">RIGHT</span>(str,<span class="hljs-built_in">len</span>) <br>从字符串str 开始，返回最右<span class="hljs-built_in">len</span> 字符。 <br><br>select <span class="hljs-literal">right</span>(<span class="hljs-string">&#x27;football&#x27;</span>, <span class="hljs-number">4</span>) -&gt; <span class="hljs-string">&#x27;ball&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="left"><a href="#left" class="headerlink" title="left"></a>left</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">LEFT(<span class="hljs-built_in">str</span>,<span class="hljs-built_in">len</span>) <br>含义： 截取字符串 <span class="hljs-built_in">str</span> 自左向右长度为 <span class="hljs-built_in">len</span> 的子串<br></code></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TRIM([&#123;BOTH | LEADING | TRAILING&#125; [remstr] FROM] str)<br>TRIM(remstr FROM] str) <br><br>trim(str)  -- 删除 str 两端的空格<br>trim(BOTH remstr FROM str) -- 删除 str 两端的字符串 remstr<br>trim(LEADING remstr FROM str) -- 删除 str 前端的字符串 remstr<br>trim(TRAILING remstr FROM str) -- 删除 str 后端[右边]的字符串 remstr<br>trim(remstr FROM str) -- 删除 str 中所有的字符串 remstr<br><br><br>mysql&gt; SELECT TRIM(&#x27;  bar   &#x27;);<br> -&gt; &#x27;bar&#x27;<br><br>mysql&gt; SELECT TRIM(LEADING &#x27;x&#x27; FROM &#x27;xxxbarxxx&#x27;);<br>&gt; &#x27;barxxx&#x27;<br><br>mysql&gt; SELECT TRIM(BOTH &#x27;x&#x27; FROM &#x27;xxxbarxxx&#x27;);<br> -&gt; &#x27;bar&#x27;<br><br>mysql&gt; SELECT TRIM(TRAILING &#x27;xyz&#x27; FROM &#x27;barxxyz&#x27;);<br> -&gt; &#x27;barx&#x27;<br><br><br></code></pre></td></tr></table></figure><h3 id="ltrim"><a href="#ltrim" class="headerlink" title="ltrim"></a>ltrim</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LTRIM(str) <br> 删除字符串左侧的空格<br> <br></code></pre></td></tr></table></figure><h3 id="rtrim"><a href="#rtrim" class="headerlink" title="rtrim"></a>rtrim</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">删除字符串右侧的空格<br><br></code></pre></td></tr></table></figure><h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT(str,pos,len,newstr) <br>含义： 将 str 从 pos 位置开始长度为 len 的子串替换为 newstr 并返回<br>参数：<br>pos ： 1. pos 大于 str 的长度或者小于 1 ，则返回原始字符串，2. <br>其他：1. 任意一个参数为 null ，则返回 null<br>案例<br>mysql&gt; SELECT INSERT(&#x27;Quadratic&#x27;, 3, 4, &#x27;What&#x27;);<br>-&gt; &#x27;QuWhattic&#x27;<br><br>mysql&gt; SELECT INSERT(&#x27;Quadratic&#x27;, 3, 100, &#x27;What&#x27;);<br> -&gt; &#x27;QuWhat&#x27;<br> <br> <br> <br></code></pre></td></tr></table></figure><h3 id="lpad"><a href="#lpad" class="headerlink" title="lpad"></a>lpad</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LPAD(str,len,padstr) <br>  返回字符串 str, 其左边由字符串padstr 填补到len 字符长度。假如str 的长度大于len, 则返回值被缩短至 len 字符<br>  <br>理解记忆：  <br><br>#hi --&gt; 00hi --&gt; ??hi<br>mysql&gt; SELECT LPAD(&#x27;hi&#x27;,4,&#x27;??&#x27;);<br>-&gt; &#x27;??hi&#x27;<br><br><br>#hi --&gt; h<br>mysql&gt; SELECT LPAD(&#x27;hi&#x27;,1,&#x27;??&#x27;);<br>-&gt; &#x27;h&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="rpad"><a href="#rpad" class="headerlink" title="rpad"></a>rpad</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">回字符串str, 其右边被字符串 padstr填补至len 字符长度。假如字符串str 的长度大于 len,则返回值被缩短到与 len 字符相同长度<br><br>select rpad(&#x27;hi&#x27;, 5, ?) -&gt; hi???<br></code></pre></td></tr></table></figure><h2 id="更新替换"><a href="#更新替换" class="headerlink" title="更新替换"></a>更新替换</h2><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">REPLACE(str,from_str,to_str) <br>返回字符串str 以及所有被字符串to_str替代的字符串from_str <br><br>mysql-&gt; replace<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&#x27;www.mysql.com&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>)</span></span><br><span class="hljs-function">-&gt;</span><span class="hljs-string">&#x27;121212.mysql.com&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">REVERSE</span>(<span class="hljs-built_in">str</span>) <br>返回字符串 <span class="hljs-built_in">str</span> ，顺序和字符顺序相反。 <br><br><span class="hljs-built_in">select</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) -&gt; <span class="hljs-string">&#x27;cba&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><h3 id="space"><a href="#space" class="headerlink" title="space"></a>space</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SPACE(N) <br>返回一个由 N 个间隔符号组成的字符串<br><br>mysql-&gt;select space(6)<br>-&gt;&#x27;      &#x27;<br><br></code></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="uncompress"><a href="#uncompress" class="headerlink" title="uncompress"></a>uncompress</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sas">对经<span class="hljs-meta">COMPRESS</span>()函数压缩后的字符串进行解压缩。若参数为压缩值，则结果为 <span class="hljs-keyword">NULL</span>。这个函数要求  MySQL 已被诸如zlib 之类的压缩库编译过。否则, 返回值将始终是 <span class="hljs-keyword">NULL</span>。<br><br><br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> UN<span class="hljs-meta">COMPRESS</span>(<span class="hljs-meta">COMPRESS</span>(<span class="hljs-string">&#x27;any string&#x27;</span>));<br><br>        -&gt; <span class="hljs-string">&#x27;any string&#x27;</span><br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> UN<span class="hljs-meta">COMPRESS</span>(<span class="hljs-string">&#x27;any string&#x27;</span>);<br><br>        -&gt; <span class="hljs-keyword">NULL</span><br><br>UNCOMPRESSED_<span class="hljs-meta">LENGTH</span>(compressed_string) <br>返回压缩字符串压缩前的长度。 <br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> UNCOMPRESSED_<span class="hljs-meta">LENGTH</span>(<span class="hljs-meta">COMPRESS</span>(<span class="hljs-meta">REPEAT</span>(<span class="hljs-string">&#x27;a&#x27;</span>,30)));<br><br>        -&gt; 30<br><br></code></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-number">1.</span> 运算符 <span class="hljs-keyword">like</span><br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">STRCMP(expr1,expr2)<br>比较两个字符串<br>expr1 = expr2 ： 返回 0<br>expr1 &gt; expr2 :  返回 1<br>expr1 &lt; expr2 :  返回 -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SELECT STRCMP(<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-string">&#x27;text2&#x27;</span>);</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">-1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SELECT STRCMP(<span class="hljs-string">&#x27;text2&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>);</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SELECT STRCMP(<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>);</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">0</span><br><br></code></pre></td></tr></table></figure><h1 id="字符串-set"><a href="#字符串-set" class="headerlink" title="字符串 set"></a>字符串 set</h1><h2 id="export-set"><a href="#export-set" class="headerlink" title="export_set"></a>export_set</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPORT_SET(bits,on,off[,separator[,number_of_bits]]) <br><br>mysql-&gt;EXPORT_SET(5, &#x27;Y&#x27;, &#x27;N&#x27;, &#x27;,&#x27;, 4)<br>1. 第一个参数 6 ： 的二进制是 101 <br>2. 第二个参数 Y ： 将二进制中 1 改为 Y<br>3. 第二个参数 N ： 将二进制中 0 改为 N<br>4，第四个参数 4 ： 将从 5 的二进制串中获取 4 个bit 位的转换值，但是 5 只有三位，所以补 0<br>   即 101 变为 0101 ==》 然后替换 NYNY<br>5. 将结果逆序放入到结果中，即结果为 YNYN, <br>6. 其中指定分隔符是 , 即最后的接故事 &#x27;Y,N,Y,N&#x27;<br> <br></code></pre></td></tr></table></figure><h2 id="make-set"><a href="#make-set" class="headerlink" title="?make_set"></a>?make_set</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">MAKE_SET</span>(<span class="hljs-params">bits,str1,str2,...</span>)</span> <br>参数索引： <br>    bits: <span class="hljs-number">0</span><br>    str1: <span class="hljs-number">1</span><br>    str2: <span class="hljs-number">2</span><br>    ...<br>含义： 根据指定的索引，生成 <span class="hljs-keyword">set</span> 字符串<br><br></code></pre></td></tr></table></figure><h1 id="不懂"><a href="#不懂" class="headerlink" title="不懂"></a>不懂</h1><p><img src="F:\1=学习笔记\3=数据库\mysql\image-20231214202917605.png" alt="image-20231214202917605"></p><h1 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql 安装配置</title>
    <link href="/2024/04/21/mysql/mysql%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/04/21/mysql/mysql%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="配置文加载顺序"><a href="#配置文加载顺序" class="headerlink" title="配置文加载顺序"></a>配置文加载顺序</h2><h1 id="mysql-中的程序"><a href="#mysql-中的程序" class="headerlink" title="mysql 中的程序"></a>mysql 中的程序</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>mysqld 是 mysql的后台程序，即mysql服务器， 客户端通过连接服务器来访问数据库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">2.</span> mysql-safe： mysql启动脚本<br><span class="hljs-bullet">3.</span> mysql.server： mysql 启动脚本<br><span class="hljs-bullet">4.</span> mysql<span class="hljs-emphasis">_multi： mysql启动脚本，在服务器上停启多个服务器</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">1. mysqld : mysql 的服务器</span><br><span class="hljs-emphasis">2. mysqld-max： 是 mysqld 的升级版，有更多的功能，是非稳定发布版</span><br><span class="hljs-emphasis">3. mysql_</span>install<span class="hljs-emphasis">_db:</span><br><span class="hljs-emphasis">脚本用默认权限创建 mysql 授权版，通常只在首次安装 mysql 的时候执行一次</span><br><span class="hljs-emphasis">4. mysql_</span>fix<span class="hljs-emphasis">_privilege_</span>tables:<br><span class="hljs-code">升级安装 mysql 后，如果新版本 mysql 的授权表有更改，则使用该脚本更改授权表</span><br></code></pre></td></tr></table></figure></li><li><p>mysql 一个命令行客户程序，用于交互式或者批处理模式执行 sql 语句</p><ul><li>mysql-admin 用于管理功能的客户程序</li><li>mysql-check 执行表维护操作</li><li>mysql-dimp, mysql-hot-copy 是数据库备份</li><li>mysql-import 导入数据文件</li><li>mysql- show 显示信息数据库和表的相关信息</li><li>mysql-binlog 处理二进制日志文件的使用工具</li><li>mysql-bug mysql缺陷报告脚本，可以用来向 mysql 邮件系统发送缺陷报告</li></ul></li><li><p>myisam</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> myisam-chhk 执行表维护操作<br> 用来描述，检查，优化和维护 myisam 报的工具<br><br><span class="hljs-bullet">2.</span> myisam-pack 产生压缩只读的表<br>  <br></code></pre></td></tr></table></figure></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>perror 显示错误代码的含义</p></li><li><p>make_binary_distribution</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">生成编译过的 mysql 的二进制版本，可以通过 ftp 上传到 ftp.mysql.com的<span class="hljs-regexp">/pub/my</span>sql<span class="hljs-regexp">/upload/</span>，供其它MySQL用户使用。<br></code></pre></td></tr></table></figure></li></ul><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="连接-mysql"><a href="#连接-mysql" class="headerlink" title="连接 mysql"></a>连接 mysql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>h host <span class="hljs-operator">-</span>u <span class="hljs-keyword">user</span> <span class="hljs-operator">-</span>p<br><br><br>mysql <span class="hljs-operator">-</span>h host <span class="hljs-operator">-</span>u <span class="hljs-operator">-</span>pprimeton self_database_name<br></code></pre></td></tr></table></figure><h2 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span>e[<span class="hljs-comment">--execute]：  </span><br><span class="hljs-number">1.</span> 用来将<span class="hljs-keyword">SQL</span>语句传递给服务器。<br><span class="hljs-number">2.</span> 该语句必须用引号引起来(单引号或双引号)。(然而，如果想要在查询中将值引起来，则对于查询应使用双引号，查询中引用的值应使用单引号）。<br>    <span class="hljs-number">3.</span> 当使用该选项时，语句被执行，然后mysql立即退出命令外壳。<br>mysql <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>pprimton <span class="hljs-operator">-</span>h host <span class="hljs-operator">-</span>e &quot;SELECT User, Host FROM User&quot; mysql<br>                             <br># 长形式(<span class="hljs-comment">--execute)后面必须紧跟一个等号(=)。                             </span><br>mysql <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-comment">--execute=&quot;SELECT Name FROM Country WHERE Name LIKE &#x27;AU%&#x27;;SELECT COUNT(*) FROM City&quot; world                             </span><br></code></pre></td></tr></table></figure><h1 id="mysqld-max"><a href="#mysqld-max" class="headerlink" title="mysqld-max"></a>mysqld-max</h1><ul><li>mysqld 的另一个版本，又有更多的特性</li><li>【暂时用不到】</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h1 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h1><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><table><thead><tr><th>脚本</th><th>读取配置组</th><th>备注</th></tr></thead><tbody><tr><td>mysqld</td><td>[mysqld]、[server]</td><td></td></tr><tr><td>mysqld_safe</td><td>[mysqld]、[server]、[mysqld_safe]、[safe_mysqld]</td><td></td></tr><tr><td>mysql.server</td><td>[mysqld]、[mysql.server]</td><td></td></tr><tr><td>嵌入式MySQL服务器</td><td>[server]、[embedded]、[xxxxx_SERVER]</td><td>其中xxxxx是服务器嵌入的应用程序名。</td></tr></tbody></table><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><h2 id="lower-case-tables-name"><a href="#lower-case-tables-name" class="headerlink" title="lower_case_tables_name"></a>lower_case_tables_name</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sql">lower_case_tables_name <br>含义： MySQL中如何在硬盘上保存和使用表名和数据库名<br><br><span class="hljs-number">0</span><br>硬盘上保存表名和数据库名： 使用<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>或<span class="hljs-keyword">CREATE</span> DATABASE语句指定的大小写<br>名称比较： 对大小写敏感<br>系统默认： unix<br>特点： 如果在大小写不敏感的文件系统上用<span class="hljs-comment">--lower-case-table-names=0强制设为0，并且使用不同的大小写访问MyISAM表名，会导致索引破坏。</span><br><span class="hljs-number">1</span><br>硬盘上保存表名和数据库名： 统一使用小写<br>名称比较： 对大小写敏感<br>系统默认： windows, max os x<br>特点： 如果在大小写不敏感的文件系统上用<span class="hljs-comment">--lower-case-table-names=0强制设为0，并且使用不同的大小写访问MyISAM表名，会导致索引破坏。</span><br><span class="hljs-number">2</span><br>硬盘上保存表名和数据库名： 使用<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>或<span class="hljs-keyword">CREATE</span> DATABASE语句指定的大小写<br>名称比较： 对大小写敏感<br>系统默认： <br>特点：<br>      a。 虽然按照指定大小写保存，但是MySQL将它们转换为小写以便查找<br>      b. 只在对大小写不敏感的文件系统上适用<br><br>使用建议<br><span class="hljs-number">1.</span> 默认不动<br>缺点： 想要在对大小写敏感不同的文件系统的平台之间转移表，会遇到困难。例如，在Unix中，my_tables和MY_tables是两个不同的表，但在Windows中，这两个表名相同。<br><br><span class="hljs-number">2.</span> 任何系统中都配置为 <span class="hljs-number">1</span> ， <br>缺点： 当使用<span class="hljs-keyword">SHOW</span> TABLES或<span class="hljs-keyword">SHOW</span> DATABASES时，看不出名字原来是用大写还是小写。<br><br><span class="hljs-number">3.</span> unix 中配置为 <span class="hljs-number">1</span>， windows 中配置为 <span class="hljs-number">0</span><br>    优势：可以保留数据库名和表名的大小写<br>    缺点：必须确保在Windows中查询总是用正确大小写引用数据库名和表名<br>    <br>例外：<br><span class="hljs-number">1.</span> 使用InnoDB表，在任何平台上均应将lower_case_tables_name设置为<span class="hljs-number">1</span>，以强制将名转换为小写。<br><span class="hljs-number">2.</span> 在Unix中将lower_case_tables_name设置为<span class="hljs-number">1</span>之前，重启mysqld之前，必须先将旧的数据库名和表名转换为小写。<br><br><br><br></code></pre></td></tr></table></figure><h1 id="mysqld-safe"><a href="#mysqld-safe" class="headerlink" title="mysqld_safe"></a>mysqld_safe</h1><ul><li><p>unix 和  netware 中推荐使用这个来启动 mysql </p></li><li><p>mysqld_safe 会优先启动 mysqld_max, </p></li><li><p>所有在命令行中为<strong>mysqld_safe</strong>指定的选项被传递给<strong>mysqld</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">  <br></code></pre></td></tr></table></figure></li><li><p>支持的选项</p></li></ul><h1 id="mysqlManager"><a href="#mysqlManager" class="headerlink" title="mysqlManager"></a>mysqlManager</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql 权限分离</title>
    <link href="/2024/04/21/mysql/mysql%20%E6%9D%83%E9%99%90%E5%88%86%E7%A6%BB/"/>
    <url>/2024/04/21/mysql/mysql%20%E6%9D%83%E9%99%90%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Alter<br>Alter Routine<br>Create<br>Create Routine<br>Create Temporary Tables<br>Create User<br>Create View<br>Delete<br>Drop<br>Event<br>Execute<br>File<br>Grant Option<br>Index<br>Insert<br>Lock Tables<br>Process<br>References<br>Reload<br>Replication Client<br>Replication Slave<br>Select<br>Show Databases<br>Show View<br>Shutdown<br>Super<br>Trigger<br>Update<br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>Event<br><span class="hljs-keyword">Execute</span><br>File<br><span class="hljs-keyword">Grant</span> <span class="hljs-keyword">Option</span><br><span class="hljs-keyword">Index</span><br><br><span class="hljs-keyword">Lock</span> <span class="hljs-keyword">Tables</span><br>Process<br><span class="hljs-keyword">References</span><br>Reload<br><span class="hljs-keyword">Replication</span> Client<br><span class="hljs-keyword">Replication</span> Slave<br><br><br>Shutdown<br>Super<br><span class="hljs-keyword">Trigger</span><br><br><br></code></pre></td></tr></table></figure><h2 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Create</span><br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Routine</span><br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Temporary</span> <span class="hljs-keyword">Tables</span><br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">User</span><br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">View</span><br><br><br><span class="hljs-keyword">Select</span><br><span class="hljs-keyword">Alter</span><br><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">Routine</span><br><span class="hljs-keyword">Show</span> Databases<br><span class="hljs-keyword">Show</span> <span class="hljs-keyword">View</span><br><br><br><span class="hljs-keyword">Delete</span><br><span class="hljs-keyword">Drop</span><br><br><span class="hljs-keyword">Insert</span><br><br><span class="hljs-keyword">Update</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql 基础</title>
    <link href="/2024/04/21/mysql/mysql%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/21/mysql/mysql%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><ol><li><p>sql 语句一般后面跟一个分号，有些不跟。 一般都跟</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">mysql通过寻找终止分号而不是输入行的结束来决定语句在哪儿结束。（换句话说，mysql接受自由格式的输入：它收集输入行但直到看见分号才执行。）<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="提示符"><a href="#提示符" class="headerlink" title="提示符 &gt;"></a>提示符 &gt;</h2><table><thead><tr><th><strong>提示符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>mysql&gt;</td><td>准备好接受新命令。</td></tr><tr><td>-&gt;</td><td>等待多行命令的下一行。</td></tr><tr><td>‘&gt;</td><td>等待下一行，等待以单引号(“’”)开始的字符串的结束。</td></tr><tr><td>“&gt;</td><td>等待下一行，等待以双引号(“””)开始的字符串的结束。</td></tr><tr><td>&#96;&gt;</td><td>等待下一行，等待以反斜点(‘&#96;’)开始的识别符的结束。</td></tr><tr><td>&#x2F;*&gt;</td><td>等待下一行，等待以&#x2F;*开始的注释的结束。</td></tr></tbody></table><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">mysql 不区分大小写<br><br><span class="hljs-bullet">1.</span> 在Unix下，数据库名称是区分大小写的(不像SQL关键字)，因此你必须总是以menagerie访问数据库，而不能用Menagerie、MENAGERIE或其它一些变量。对表名也是这样的。<br></code></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">风格三种<br><span class="hljs-number">1.</span> 从‘#’字符从行尾。<br><span class="hljs-number">2.</span> 从‘-- ’序列到行尾。请注意‘-- ’(双破折号)注释风格要求第<span class="hljs-number">2</span>个破折号后面至少跟一个空格符(例如空格、tab、换行符等等)。该语法与标准SQL注释语法稍有不同，<br><span class="hljs-number">3.</span> 从<span class="hljs-comment">/*序列到后面的*/</span>序列。结束序列不一定在同一行中，因此该语法允许注释跨越多行<br><br></code></pre></td></tr></table></figure><h1 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h1><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">在MySQL中，<br>数据库:对应数据目录中的目录。<br>表:  至少对应数据库目录中的一个文件<span class="hljs-comment">(也可能是多个，取决于存储引擎)</span>。<br></code></pre></td></tr></table></figure><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">格式<br>指用单引号(‘<span class="hljs-comment">&#x27;’)或双引号(‘&quot;’)引起来的字符序列</span><br>案例<br><span class="hljs-comment">&#x27;a string&#x27;</span><br><span class="hljs-string">&quot;another string&quot;</span><br>特殊<br><span class="hljs-number">1</span>. 指定字符串使用的字符集<br><span class="hljs-keyword">SELECT</span> _latin1<span class="hljs-comment">&#x27;string&#x27;;</span><br><span class="hljs-keyword">SELECT</span> _latin1<span class="hljs-comment">&#x27;string&#x27; COLLATE latin1_danish_ci;</span><br><br>注意<br><span class="hljs-number">1</span>. 如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符<br><br><br></code></pre></td></tr></table></figure><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="&#x3D;&#x3D; 特殊字符"></a>&#x3D;&#x3D; 特殊字符</h3><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table><thead><tr><th>\0</th><th>ASCII 0(NUL)字符。</th></tr></thead><tbody><tr><td>&#39;</td><td>单引号(‘’’)。</td></tr><tr><td>&quot;</td><td>双引号(‘“’)。</td></tr><tr><td>\b</td><td>退格符。</td></tr><tr><td>\n</td><td>换行符。</td></tr><tr><td>\r</td><td>回车符。</td></tr><tr><td>\t</td><td>tab字符。</td></tr><tr><td>\Z</td><td>ASCII  26(控制（Ctrl）-Z)。该字符可以编码为‘\Z’，以允许你解决在Windows中ASCII  26代表文件结尾这一问题。(如果你试图使用mysql <em>db_name</em> &lt;  <em>file_name</em>，ASCII 26会带来问题）。</td></tr><tr><td>\</td><td>反斜线(‘\’)字符。</td></tr><tr><td>%</td><td>‘%’字符。参见表后面的注解。</td></tr><tr><td>_</td><td>‘_’字符。参见表后面的注解。</td></tr></tbody></table><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span> \<span class="hljs-meta">%</span>’和‘\_’序列用于搜索可能会解释为通配符的模式匹配环境中的‘<span class="hljs-meta">%</span>’和‘_’文字实例。参见<span class="hljs-number">12.3</span><span class="hljs-number">.1</span>节，“字符串比较函数”。请注意如果你在其它环境中使用‘\<span class="hljs-meta">%</span>’或‘\_’，它们返回字符串‘\<span class="hljs-meta">%</span>’和‘\_’，而不是‘<span class="hljs-meta">%</span>’和‘_’。<br><br></code></pre></td></tr></table></figure><h3 id="字符串中的引号"><a href="#字符串中的引号" class="headerlink" title="字符串中的引号"></a>字符串中的引号</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1.</span> 在字符串内用 <span class="hljs-string">&#x27; 引用的 &#x27;</span> 可以写成 <span class="hljs-string">&#x27;&#x27;</span>。<br><span class="hljs-number">2.</span> 在字符串内用 <span class="hljs-string">&quot; 引用的 &quot;</span> 可以写成 <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-number">3.</span> 通用在字符前面加转义字符 <span class="hljs-string">\</span><br><span class="hljs-number">4.</span> 在 <span class="hljs-string">&quot; 中引用 &#x27; , 在 &#x27; 中引用 &quot;</span>  ，都不需要加引号<br><br></code></pre></td></tr></table></figure><h3 id="字符串中插入二进制数据"><a href="#字符串中插入二进制数据" class="headerlink" title="字符串中插入二进制数据"></a>字符串中插入二进制数据</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cos">如果你想要在字符串列内插入二进制数据(例如BLOB)，必须通过转义序列表示下面的字符：<br><br>NUL  NUL字节(<span class="hljs-keyword">ASCII</span> <span class="hljs-number">0</span>)。用‘\<span class="hljs-number">0</span>’表示该字符(反斜线后面跟一个<span class="hljs-keyword">ASCII</span>‘<span class="hljs-number">0</span>’字符)。<br>\  反斜线(<span class="hljs-keyword">ASCII</span> <span class="hljs-number">92</span>)。用‘\\’表示该字符。 <br>&#x27;  单引号(<span class="hljs-keyword">ASCII</span> <span class="hljs-number">39</span>)。用‘\&#x27;’表示该字符。<br><span class="hljs-string">&quot;  双引号(ASCII 34)。用‘\&quot;</span>’表示该字符。<br> <br><br></code></pre></td></tr></table></figure><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">整数： <br>用一系列阿拉伯数字表示。<br>浮点数： <br>使用‘.’作为十进制间隔符。<br>负数：<br><span class="hljs-number">0</span>. 分为整数和浮点数 <br><span class="hljs-number">1</span>. 均可以在前面加一个‘-’来表示负值。<br><span class="hljs-number">2</span>. 整数可以用在浮点环境中；它被解释为与浮点数等效。<br><br>十六进制<br><span class="hljs-number">1</span>. 默认类型是字符串。如果想要确保该值作为数字处理，可以使用CAST(...AS UNSIGNED)：<br><span class="hljs-number">2</span>. 在数字上下文中，十六进制数如同整数(<span class="hljs-number">64</span>位精度)。<br>   在字符串上下文，如同二进制字符串，每对十六进制数字被转换为一个字符<br>   SELECT <span class="hljs-function"><span class="hljs-title">x</span>&#x27;4D7953514C&#x27;；   -&gt;</span> <span class="hljs-string">&#x27;MySQL&#x27;</span><br>   SELECT <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xa</span>+0； -&gt;</span> <span class="hljs-number">10</span><br>   SELECT <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x5061756c</span>； -&gt;</span> <span class="hljs-string">&#x27;Paul&#x27;</span><br>   <span class="hljs-number">3</span>. 需要前缀 <span class="hljs-number">0</span>x, x<br><br><br></code></pre></td></tr></table></figure><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 大小写的 true, false 都可以<br>常量 TRUE=1<br>常量 FALAE=0<br></code></pre></td></tr></table></figure><h2 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">可以使用b<span class="hljs-string">&#x27;value&#x27;</span>符号写位字段值。<span class="hljs-keyword">value</span>是一个用<span class="hljs-number">0</span>和<span class="hljs-number">1</span>写成的二进制值。<br><br>位字段符号可以方便指定分配给BIT列的值：<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t (b BIT(<span class="hljs-number">8</span>));<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t <span class="hljs-keyword">SET</span> b <span class="hljs-operator">=</span> b<span class="hljs-string">&#x27;11111111&#x27;</span>;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t <span class="hljs-keyword">SET</span> b <span class="hljs-operator">=</span> b<span class="hljs-string">&#x27;1010&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">NULL</span> <br>含义： 没有数据<br>特点： 不同于数字类型的<span class="hljs-number">0</span>或字符串类型的空字符串<br><br><br>含义<br><span class="hljs-number">1.</span> 意味着“没有值”或“未知值”，且它被看作与众不同的值<br>原酸<br><span class="hljs-number">1.</span> 不能使用算术比较 操作符例如<span class="hljs-operator">=</span>、<span class="hljs-operator">&lt;</span>或<span class="hljs-operator">!=</span>。<br></code></pre></td></tr></table></figure><h1 id="识别符"><a href="#识别符" class="headerlink" title="识别符"></a>识别符</h1><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 数据库、表、索引、列和别名是识别符<br><br>特例<br><span class="hljs-bullet">1.</span> 不可以包含ASCII 0或值为255的字节<br><span class="hljs-bullet">2.</span> 不应以空格结尾<br><span class="hljs-bullet">3.</span> 可能避免引号识别符<br><br>保存<br><span class="hljs-bullet">1.</span> 别符用Unicode(UTF8)保存。在.frm文件中保存的表定义的识别符和在mysql数据库中的授权表保存的识别符也用Unicode(UTF8)保存<br><br><br>使用<br><span class="hljs-bullet">1.</span> 可以引起来，也可以不引起来<br><span class="hljs-bullet">2.</span> 如果识别符是一个保留字或包含特殊字符，无论何时使用，必须将它引起来<br><span class="hljs-code">保留字：  参看 mysql 保留字</span><br><span class="hljs-code">特殊字符：指那些当前字符集、‘_’和‘$’之外的文字数字字符集</span><br><span class="hljs-code"></span><br><span class="hljs-code">例子</span><br><span class="hljs-code">SELECT * FROM `select` WHERE `select`.id &gt; 100;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>识别符</strong></th><th><strong>最大长度(字节)</strong></th><th><strong>允许的字符</strong></th></tr></thead><tbody><tr><td>数据库</td><td>64</td><td>目录名允许的任何字符，不包括‘&#x2F;’、‘\’或者‘。’</td></tr><tr><td>表</td><td>64</td><td>文件名允许的任何字符，不包括‘&#x2F;’、‘\’或者‘。’</td></tr><tr><td>列</td><td>64</td><td>所有字符</td></tr><tr><td>索引</td><td>64</td><td>所有字符</td></tr><tr><td>别名</td><td>255</td><td>所有字符</td></tr></tbody></table><h2 id="大小写-1"><a href="#大小写-1" class="headerlink" title="大小写"></a>大小写</h2><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">数据库和数据库表<br><span class="hljs-number">1</span>. mysql 大小写是否敏感取决于操作系统<br>大多数Unix中数据库名和表名对大小写敏感，<br>Windows中对大小写不敏感。<br>mac os x 基于Unix但使用默认文件系统类型(HFS+)，对大小写不敏感。然而，Mac OS X也支持UFS卷，该卷对大小写敏感，就像Unix一样】<br><br><br><span class="hljs-number">2</span>. 列、索引、存储子程序和触发器名、列的别名： <br>不区分平台， 对大小写不敏感。<br><br>注意<br><span class="hljs-number">1</span>. 数据库名，表明应该统一规范，使用大写还是小写。最好是小写<br><span class="hljs-number">2</span>. MySQL中如何在硬盘上保存和使用表名和数据库名由lower<span class="hljs-number">_</span><span class="hljs-keyword">case</span><span class="hljs-number">_</span>tables<span class="hljs-number">_n</span>ame系统变量确定，可以在启动mysqld时设置<br>   参看【参数配置中的 lower<span class="hljs-number">_</span><span class="hljs-keyword">case</span><span class="hljs-number">_n</span>ame】<br><br><br></code></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 滥用用户变量会导致程序难以理解及管理<br>局部变量【       】： 函数/存储过程中使用 begin ... end 中使用  declare<br>用户变量【当前用户有效】： set/select @<br>系统变量【所有用户有效】:  set/select @@<br>会话变量<br>全局变量<br><br>区别<br>在调用存储过程时，<br>  1. 以declare声明的变量都会被初始化为null。<br>  2. 会话变量（即@开头的变量）则不会被再初始化，在一个会话内，只须初始化一次，之后在会话内都是对上一次计算的结果，就相当于在是这个会话内的全局变量。<br></code></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">使用位置<br>局部变量一般用在sql语句块中，比如存储过程的begin/end。其作用域仅限于该语句块，在该语句块执行完毕后，局部变量就消失了<br>语法<br>declare var_name [, var_name]... data_type [ DEFAULT value ];<br>datatype 为 MySQL 的数据类型【列类型】，如: int, float, date,varchar(length)<br>default  默认值<br><br>限制<br>1. 局部变量声明一定要放在存储过程体的开始：<br>2. <br>赋值<br># set语句既可以用于局部变量的赋值，也可以用于用户变量的申明并赋值。<br>SET 变量名 = 表达式值 [,variable_name = expression ...]<br>----------------------------<br>declare c int default 0;<br>    set c=a+b;<br>    select c as C;<br><br># <br>select col_name[,...] into var_name[,...] table_expr [where...];<br>--------------------------<br>declare v_employee_name varchar(100);<br>    declare v_employee_salary decimal(8,4);<br><br>    select employee_name, employee_salary<br>    into v_employee_name, v_employee_salary<br>    from employees<br>    where employee_id=1;<br><br><br></code></pre></td></tr></table></figure><h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs mysql">用处<br>以先在用户变量中保存值然后在以后引用它；这样可以将值从一个语句传递到另一个语句<br>生命周期：<br>     #在客户端链接到数据库实例整个过程中用户变量都是有效的<br>个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放<br>语法结构<br>@标识符<br>标识符：<br>1. 大小写不敏感<br>2. 由当前字符集的文字数字字符、‘.’、‘_’和‘$’组成。 默认字符集是cp1252 (Latin1)。<br>3. 用mysqld的--default-character-set选项更改字符集<br>特点<br>1. 如果使用没有初始化的变量，其值是NULL。即： 未分配的变量有一个值NULL，类型为字符串。<br>2. <br><br>curd<br>    # 设置用户变量 -- set 语句。 set可以使用=或:=作为分配符<br>    set @name=lisi, @age=13;  <br>    set @name:=lisi, @age:=13;<br><br>    # 设置用户变量 -- 非 set 语句， 必须使用 := , 因为 = 作为比较符号了<br>    SELECT @t2:=1,@t2;<br>    <br>    # 变量可以参与计算<br>    SELECT @t1:=(@t2:=1)+@t3:=4,@t1;<br>    <br>危险：<br>1. SELECT语句中，表达式发送到客户端后才进行计算。这说明在HAVING、GROUP BY或者ORDER BY子句中，不能使用包含SELECT列表中所设的变量的表达式<br>SELECT (@aa:=id) AS a，(@aa+3) AS b  from tbl_name HAVING b=5；<br>hvaing 使用了select 中的别名 b, ，使用@aa。不能按期望工作：@aa不包含当前行的值，而是前面所选的行的id值<br><br><br>------------<br>【后续总结】<br>用户变量可以用于表达式中。目前不包括明显需要文字值的上下文中，例如SELECT语句的LIMIT子句，或者LOAD DATA语句的IGNORE number LINES子句。<br><br>如果使用没有初始化的变量，其值是NULL。<br><br>如果用户变量分配了一个字符串值，其字符集和校对规则与该字符串的相同。用户变量的可压缩性（coercibility）是隐含的。(即为表列值的相同的可压缩性（coercibility）。<br><br>注释：在SELECT语句中，表达式发送到客户端后才进行计算。这说明在HAVING、GROUP BY或者ORDER BY子句中，不能使用包含SELECT列表中所设的变量的表达式。例如，下面的语句不能按期望工作：<br><br>mysql&gt; SELECT (@aa:=id) AS a，(@aa+3) AS b 从tbl_name HAVING b=5；<br>HAVING子句中引用了SELECT列表中的表达式的别名，使用@aa。不能按期望工作：@aa不包含当前行的值，而是前面所选的行的id值。<br><br>一般原则是不要在语句的一个部分为用户变量分配一个值而在同一语句的其它部分使用该变量。可能会得到期望的结果，但不能保证。<br><br>设置变量并在同一语句中使用它的另一个问题是变量的默认结果的类型取决于语句前面的变量类型。下面的例子说明了该点：<br><br>mysql&gt; SET @a=&#x27;test&#x27;;<br>mysql&gt; SELECT @a,(@a:=20) FROM tbl_name;<br>对于该 SELECT语句，MySQL向客户端报告第1列是一个字符串，并且将@a的所有访问转换为字符串，即使@a在第2行中设置为一个数字。执行完SELECT语句后，@a被视为下一语句的一个数字。<br><br>要想避免这种问题，要么不在同一个语句中设置并使用相同的变量，要么在使用前将变量设置为0、0.0或者&#x27;&#x27;以定义其类型。<br><br>未分配的变量有一个值NULL，类型为字符串。<br><br></code></pre></td></tr></table></figure><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs mysql">含义<br>1. 系统运行所需要的变量，比如从配置文件中加载的变量<br>2. 服务器运行时许多变量可以修改，而不用去重启服务器<br>分类<br>全局系统变量：<br>    1. 全局变量的更改可以被访问该全局变量的任何客户端看见。然而，它只影响更改后连接的客户的从该全局变量初始化的相应会话变量。不影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。<br>2. 更改全局变量，必须具有SUPER权限。<br><br>会话系统变量<br>    1. 服务器还为每个连接的客户端维护一系列会话变量，设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其它客户端的会话变量。<br>    2. <br><br>生命周期<br>1. 当服务器启动时，它将所有全局变量初始化为默认值。[默认值可以在选项文件中或在命令行中指定的选项进行更改]<br>语法<br>#============== 新增，修改<br>set global 变量名=变量值；<br>set @@global.变量名=变量值<br><br><br># 默认 session <br>set session buffer_size=10;<br>set @@session.buffer_size=10;<br>set buffer_size=10;<br><br># local 是 session 的同义词<br><br><br>#============== 查询<br><br>-- 全局系统变量<br>select @@global.buffer_size<br><br>-- 会话系统变量<br>select @@session.buffer_size<br><br>-- 省略。 先从 session 中找， 如果找不到再从 global 中找<br>select @@buffer_size<br><br><br>#============= 等价<br>show  global variables like &#x27;buffer_size&#x27;<br><br><br><br><br><br><br></code></pre></td></tr></table></figure><h3 id="结构式系统变量"><a href="#结构式系统变量" class="headerlink" title="结构式系统变量"></a>结构式系统变量</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">没看懂<br></code></pre></td></tr></table></figure><h1 id="列类型"><a href="#列类型" class="headerlink" title="列类型"></a>列类型</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">众多列类型： 带符号<span class="hljs-operator">/</span>无符号整数，<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">8</span>字节长，<span class="hljs-type">FLOAT</span>，<span class="hljs-keyword">DOUBLE</span>，<span class="hljs-type">CHAR</span>，<span class="hljs-type">VARCHAR</span>，TEXT，<span class="hljs-type">BLOB</span>，<span class="hljs-type">DATE</span>，<span class="hljs-type">TIME</span>，DATETIME，<span class="hljs-type">TIMESTAMP</span>，<span class="hljs-keyword">YEAR</span>，<span class="hljs-keyword">SET</span>，ENUM，以及OpenGIS空间类型。请参见第<span class="hljs-number">11</span>章：列类型。 <br><br>定长和可变长度记录<br><br></code></pre></td></tr></table></figure><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs fortran">MySQL支持所有标准SQL数值数据类型<br>严格数据类型[整型]： <span class="hljs-keyword">integer</span>, samllint, <span class="hljs-keyword">decimal</span>, numeric<br>近似数据类型[小数]： <span class="hljs-built_in">float</span>, <span class="hljs-keyword">real</span>, <span class="hljs-keyword">double</span> percision<br><br>大小<br>计算公式： 最大值 <span class="hljs-built_in">max</span>= <span class="hljs-number">2</span> ^ （字节数*<span class="hljs-number">4</span>）<br>    <span class="hljs-number">1.</span> 无符号：最大值[<span class="hljs-built_in">max</span>-<span class="hljs-number">1</span>, 因为有个 <span class="hljs-number">0</span>] ， 最小值[<span class="hljs-number">0</span>]<br>    <span class="hljs-number">2.</span> 有符号：<span class="hljs-built_in">max</span>/<span class="hljs-number">2</span>,  最大值[<span class="hljs-built_in">max</span>/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, 因为有个 <span class="hljs-number">0</span>] ， 最小值[<span class="hljs-built_in">max</span>/<span class="hljs-number">2</span>]<br>    <br>显示宽度：<br>    介绍： <br>        类型关键字后面的括号内指定整数值的显示宽度(例如，<span class="hljs-built_in">INT</span>(<span class="hljs-number">4</span>)) <br>    作用：<br>        <span class="hljs-number">1.</span> 值的实际位数小于指定的值的位数的时候， 会在左侧使用 <span class="hljs-number">0</span> 填充宽度 <br>          声明为<span class="hljs-built_in">INT</span>(<span class="hljs-number">5</span>) ZEROFILL的列，值<span class="hljs-number">4</span>检索为<span class="hljs-number">00004</span><br>        <span class="hljs-number">2.</span> 显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。 <br>符号<br>    语法： 所有整数类型可以有一个可选(非标准)属性UNSIGNED<br>    使用： 列内只允许非负数和该列需要较大的上限数值范围时可以使用无符号值， 防止负值保存到列中<br><br>注意<br><span class="hljs-number">1.</span> 一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>类型</strong></th><th><strong>字节</strong></th><th></th><th>有符号&#x2F;无符号</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>tiny_int</td><td></td></tr><tr><td>SMALLINT</td><td>2</td><td>small_int</td><td></td></tr><tr><td>MEDIUMINT</td><td>3</td><td>medium_int</td><td></td></tr><tr><td>INT&#x2F;INTEGER</td><td>4</td><td>int</td><td></td></tr><tr><td>BIGINT</td><td>8</td><td>big_int</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql">非标语法<br>FLOAT(M,D)<br>REAL(M,D)<br>DOUBLE PRECISION(M,D)<br>-- “(M,D)”表示该值一共显示M位整数，其中D位位于小数点后面<br>-- D 默认是 0， 可省略<br>DECIMAL(M, D)<br>NUMERIC<br>-- M 默认是 10， D 默认是 0,  可省略<br><br>案例使用<br>FLOAT(7,4)的一个列可以显示为-999.9999<br>FLOAT(7,4)列内插入999.00009，近似结果是999.0001。 【MySQL保存值时进行四舍五入】<br><br>注意<br>1. 同义词： double == double precision , real == double precision <br>除非SQL服务器模式包括REAL_AS_FLOAT选项。<br><br>精确精度<br>含义： <br>保存必须为确切精度的值，例如货币数据。当声明该类型的列时，可以(并且通常要)指定精度和标度；例如：<br>salary DECIMAL(5,2) ： 5是精度，2是标度。精度表示保存值的主要位数，标度表示小数点后面可以保存的位数。<br><br>待总结<br>DECIMAL或NUMERIC的最大位数是65，但具体的DECIMAL或NUMERIC列的实际范围受具体列的精度或标度约束。如果此类列分配的值小数点后面的位数超过指定的标度允许的范围，值被转换为该标度。(具体操作与操作系统有关，但一般结果均被截取到允许的位数）。<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>字节</th><th></th></tr></thead><tbody><tr><td>float</td><td>4字节单精度， 0到23</td><td>近似精度</td></tr><tr><td>double</td><td>8字节双精度， 24到53</td><td>近似精度</td></tr><tr><td>decimal</td><td>最大位数是65</td><td>精确精度</td></tr><tr><td>numeric</td><td>最大位数是65</td><td>精确精度</td></tr></tbody></table><h3 id="bit位"><a href="#bit位" class="headerlink" title="bit位"></a>bit位</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">应用<br><span class="hljs-number">1.</span> 可用来保存位字段值，【参看字面量<span class="hljs-comment">--位字段】 </span><br>语法结构<br>BIT(M)类型允许存储M位值。<br>M： 范围为<span class="hljs-number">1</span>到<span class="hljs-number">64</span><br>特点：<br><span class="hljs-number">1.</span> 如果为BIT(M)列分配的值的长度小于M位，在值的左边用<span class="hljs-number">0</span>填充。<br>  例如，为BIT(<span class="hljs-number">6</span>)列分配一个值b<span class="hljs-string">&#x27;101&#x27;</span>，其效果与分配b<span class="hljs-string">&#x27;000101&#x27;</span>相同。<br><br><br></code></pre></td></tr></table></figure><h3 id="sql裁剪"><a href="#sql裁剪" class="headerlink" title="sql裁剪"></a>sql裁剪</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">介绍<br>当要在一个数值列内保存一个超出该列允许范围的值时<br>mysql 动作<br>MySQL的操作取决于此时有效的SQL模式。<br><span class="hljs-number">1</span>. 如果模式未设置，MySQL将值裁剪到范围的相应端点，并保存裁减好的值。<br><span class="hljs-number">2</span>. 如果模式设置为traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据SQL标准插入会失败<br><br>案例<br>如果INT列是UNSIGNED，列范围的大小相同，但其端点会变为到<span class="hljs-number">0</span>和<span class="hljs-number">4294967295</span>。如果你试图保存-<span class="hljs-number">9999999999</span>和<span class="hljs-number">9999999999</span>，以非严格模式保存到列中的值是<span class="hljs-number">0</span>和<span class="hljs-number">4294967296</span>。<br>如果在浮点或定点列中分配的值超过指定(或默认)精度和标度规定的范围，MySQL以非严格模式保存表示范围相应端点的值。<br><br></code></pre></td></tr></table></figure><h2 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h2><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">使用<br><span class="hljs-number">1.</span> 不要使用两位格式的年份<br><br>格式字符串<br> <span class="hljs-number">1.</span> 年份的格式可以用 YY， 但是不建议用<br> <br>    <br>时间字符串解析    <br>  datatime ：YYYY-MM-DD HH:MM:SS <br>  date: YYYY-MM-DD<br>  <span class="hljs-number">1.</span> 允许不严格的语法：任何标点符都可以用做日期部分或时间部分之间的间割符。<br>  例如，<span class="hljs-string">&#x27;98-12-31 11:30:45&#x27;</span>、<span class="hljs-string">&#x27;98.12.31 11+30+45&#x27;</span>、<span class="hljs-string">&#x27;98/12/31 11*30*45&#x27;</span>和<span class="hljs-string">&#x27;98@12@31 11^30^45&#x27;</span>是等价的。<br>  <span class="hljs-number">2.</span> 对于取消分割符的字符串，只能解析年份是 YYYY 格式的<br>   <span class="hljs-number">19970523091528</span>  被解释为<span class="hljs-string">&#x27;1997-05-23 09:15:28&#x27;</span><br>   <span class="hljs-number">19970523</span> 被解释为 <span class="hljs-string">&#x27;1997-05-23&#x27;</span>，<br>   <span class="hljs-number">971332</span> 是不合法的(它有一个没有意义的月和日部分)，将变为<span class="hljs-string">&#x27;0000-00-00 。</span><br><span class="hljs-string">  3. 无效的时间类型日期，会被转换为对应的&quot;零值&quot;</span><br><span class="hljs-string">  4. 月，日， 时分秒，不足两位的，可以不用指定两位</span><br><span class="hljs-string">    &#x27;</span><span class="hljs-number">1979</span>-<span class="hljs-number">6</span>-<span class="hljs-number">9</span><span class="hljs-string">&#x27;与&#x27;</span><span class="hljs-number">1979</span>-<span class="hljs-number">06</span>-09<span class="hljs-string">&#x27;是相同的</span><br><span class="hljs-string">    &#x27;</span><span class="hljs-number">1979</span>-<span class="hljs-number">10</span>-<span class="hljs-number">30</span> <span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">3</span><span class="hljs-string">&#x27;与&#x27;</span><span class="hljs-number">1979</span>-<span class="hljs-number">10</span>-<span class="hljs-number">30</span> <span class="hljs-number">01</span>:<span class="hljs-number">02</span>:<span class="hljs-number">03</span><span class="hljs-string">&#x27;相同。</span><br><span class="hljs-string">  5. 根据字符串长度进行切割，数字值应为6、8、12或者14位长,从左向右解释字符串内出现的各部分，以发现年、月、日、小时、分和秒值。</span><br><span class="hljs-string">    如果一个数值是 8 或 14 位长，则假定为YYYYMMDD或YYYYMMDDHHMMSS格式，前4位数表示年。</span><br><span class="hljs-string">    如果数字是 6 或 12 位长，则假定为YYMMDD或YYMMDDHHMMSS格式，前2位数表示年。</span><br><span class="hljs-string">    其它数字被解释为仿佛用零填充到了最近的长度。</span><br><span class="hljs-string">    &#x27;</span><span class="hljs-number">9903</span><span class="hljs-string">&#x27; 认为它表示1999年3月，MySQL将在你的表内插入一个“零”日期值。这是因为年和月值是99和03，但日部分完全丢失，因此该值不是一个合法的日期, 合法的应该是 &#x27;</span><span class="hljs-number">990300</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">   6. 值&#x27;</span><span class="hljs-number">10</span>:<span class="hljs-number">11</span>:<span class="hljs-number">12</span><span class="hljs-string">&#x27;由于‘:’间割符看上去可能象时间值，但如果用于日期上下文值则被解释为年&#x27;</span><span class="hljs-number">2010</span>-<span class="hljs-number">11</span>-<span class="hljs-number">12</span><span class="hljs-string">&#x27;。值&#x27;</span><span class="hljs-number">10</span>:<span class="hljs-number">45</span>:<span class="hljs-number">15</span><span class="hljs-string">&#x27;被转换为&#x27;</span><span class="hljs-number">0000</span>-<span class="hljs-number">00</span>-<span class="hljs-number">00</span><span class="hljs-string">&#x27;因为&#x27;</span><span class="hljs-number">45</span><span class="hljs-string">&#x27;不是合法月。</span><br><span class="hljs-string">   7. 非严格模式，MySQL服务器只对日期的合法性进行基本检查：年、月和日的范围分别是1000到9999、00到12和00到31。任何包含超出这些范围的部分的日期被转换成&#x27;</span><span class="hljs-number">0000</span>-<span class="hljs-number">00</span>-<span class="hljs-number">00</span><span class="hljs-string">&#x27;。</span><br><span class="hljs-string"></span><br><span class="hljs-string">两位年份转换规则：</span><br><span class="hljs-string">1. 00-69范围的年值转换为2000-2069。</span><br><span class="hljs-string">2. 70-99范围的年值转换为1970-1999。</span><br><span class="hljs-string">       </span><br><span class="hljs-string">       </span><br><span class="hljs-string">      </span><br><span class="hljs-string">时间类型转换</span><br><span class="hljs-string">1. 如果你为一个DATETIME或TIMESTAMP对象分配一个DATE值，结果值的时间部分被设置为&#x27;</span><span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-string">&#x27;，因为DATE值未包含时间信息。</span><br><span class="hljs-string">2. 如果你为一个DATE对象分配一个DATETIME或TIMESTAMP值，结果值的时间部分被删除，因为DATE值未包含时间信息。</span><br><span class="hljs-string">3. 所以使用相同的格式指定时间值，不要乱转换时间戳， </span><br><span class="hljs-string">      </span><br><span class="hljs-string"></span><br><span class="hljs-string">总结       </span><br><span class="hljs-string">  1. 使用严格模式： 非法日期不被接受，并且不转换。</span><br><span class="hljs-string"></span><br><span class="hljs-string">      </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">时间字符串格式<br><br>格式<br><span class="hljs-number">1.</span>  <span class="hljs-string">&#x27;D HH:MM:SS.fraction&#x27;</span>格式的字符串。还可以使用下面任何一种“非严格”语法：<span class="hljs-string">&#x27;HH:MM:SS.fraction&#x27;</span>、<span class="hljs-string">&#x27;HH:MM:SS&#x27;</span>、<span class="hljs-string">&#x27;HH:MM&#x27;</span>、<span class="hljs-string">&#x27;D HH:MM:SS&#x27;</span>、<span class="hljs-string">&#x27;D HH:MM&#x27;</span>、<span class="hljs-string">&#x27;D HH&#x27;</span>或<span class="hljs-string">&#x27;SS&#x27;</span>。这里D表示日，可以取<span class="hljs-number">0</span>到<span class="hljs-number">34</span>之间的值。请注意MySQL还不保存分数。<br><span class="hljs-number">2.</span> 无分隔符的 <span class="hljs-string">&#x27;HHMMSS&#x27;</span>格式<br>例如，<span class="hljs-string">&#x27;101112&#x27;</span>被理解为<span class="hljs-string">&#x27;10:11:12&#x27;</span>，但<span class="hljs-string">&#x27;109712&#x27;</span>是不合法的(它有一个没有意义的分钟部分)，将变为<span class="hljs-string">&#x27;00:00:00&#x27;</span>。<br><span class="hljs-number">3.</span> 含有时间分隔符的 HH:MM:SS <br>如果时、分或者秒值小于<span class="hljs-number">10</span>，则不需要指定两位数。<span class="hljs-string">&#x27;8:3:2&#x27;</span>与<span class="hljs-string">&#x27;08:03:02&#x27;</span>相同。<br><span class="hljs-number">4.</span> 无分隔符的其他模式<br>a. 没有冒号，MySQL解释值时假定最右边的两位表示秒(MySQL解释TIME值为过去的时间而不是当天的时间）: 可能认为<span class="hljs-string">&#x27;1112&#x27;</span>和<span class="hljs-number">1112</span>表示<span class="hljs-string">&#x27;11:12:00&#x27;</span>(<span class="hljs-number">11</span>点过<span class="hljs-number">12</span>分)，但MySQL将它们解释为<span class="hljs-string">&#x27;00:11:12&#x27;</span>(<span class="hljs-number">11</span>分，<span class="hljs-number">12</span> 秒)。<br>b. 含有冒汗，TIME值中使用冒号则肯定被看作当天的时间。也就是说，<span class="hljs-string">&#x27;11:12&#x27;</span>表示<span class="hljs-string">&#x27;11:12:00&#x27;</span>，而不是<span class="hljs-string">&#x27;00:11:12&#x27;</span><br><span class="hljs-number">5</span>、无效TIME值被转换为<span class="hljs-string">&#x27;00:00:00&#x27;</span>。<br>      请注意由于<span class="hljs-string">&#x27;00:00:00&#x27;</span>本身是一个合法TIME值，只从表内保存的一个<span class="hljs-string">&#x27;00:00:00&#x27;</span>值还不能说出原来的值是 <span class="hljs-string">&#x27;00:00:00&#x27;</span>还是不合法的值。<br>                                 <br>                                 <br>time 字符串截断<br>  <span class="hljs-number">1.</span> 超出TIME范围但合法的值被裁为范围最接近的端点。例如，<span class="hljs-string">&#x27;-850:00:00&#x27;</span>和<span class="hljs-string">&#x27;850:00:00&#x27;</span>被转换为<span class="hljs-string">&#x27;-838:59:59&#x27;</span>和<span class="hljs-string">&#x27;838:59:59&#x27;</span> <br>                                 <br></code></pre></td></tr></table></figure><h3 id="年"><a href="#年" class="headerlink" title="年"></a>年</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">介绍<br>YEAR类型是一个单字节类型用于表示年<br>格式<br>·         四位字符串，范围为&#x27;1901&#x27;到&#x27;2155&#x27;。<br>·         四位数字，范围为1901到2155。<br>·         函数返回的结果，其值适合YEAR上下文，例如NOW()。<br>-- 下面的都不建议用： MySQL内部使用四位来保存年。<br>·         两位字符串，范围为&#x27;00&#x27;到&#x27;99&#x27;。&#x27;00&#x27;到&#x27;69&#x27;和&#x27;70&#x27;到&#x27;99&#x27;范围的值被转换为2000到2069和1970到1999范围的YEAR值。<br>·         两位整数，范围为1到99。1到69和70到99范围的值被转换为2001到2069和1970到1999范围的YEAR值。请注意两位整数范围与两位字符串范围稍有不同，因为你不能直接将零指定为数字并将它解释为2000。你必须将它指定为一个字符串&#x27;0&#x27;或&#x27;00&#x27;或它被解释为0000。<br><br><br>年-字符串转换<br>1. 非法YEAR值被转换为0000。<br><br><br>2000年(Y2K) 问题<br>1. MySQL本身对于2000年(Y2K)是安全的， MySQL本身对于2000年(Y2K)是安全的<br>2. 对于年份只有 2 个的年份，mysql 会做出自己猜测，但是不一定符合业务或者正确使用，所以【请使用四位年份】<br><br></code></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table><thead><tr><th><strong>列类型</strong></th><th>零值</th><th>检索格式</th><th>支持范围</th></tr></thead><tbody><tr><td>DATETIME</td><td>‘0000-00-00 00:00:00’</td><td>YYYY-MM-DD HH:MM:SS</td><td>‘1000-01-01 00:00:00’到’9999-12-31 23:59:59’</td></tr><tr><td>DATE</td><td>‘0000-00-00’</td><td>YYYY-MM-DD</td><td>‘1000-01-01’到 ‘9999-12-31’</td></tr><tr><td>TIMESTAMP</td><td>00000000000000</td><td></td><td></td></tr><tr><td>TIME</td><td>‘00:00:00’</td><td>‘HH:MM:SS’</td><td>从’-838:59:59’到’838:59:59’</td></tr><tr><td>YEAR</td><td>0000</td><td>YYYY</td><td>1901到2155</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>. 要想计算用于保存具体<span class="hljs-built_in">CHAR</span>、VARCHAR或者<span class="hljs-built_in">TEXT</span>列值的字节数，需要考虑该列使用的字符集。在具体情况中，当使用<span class="hljs-built_in">Unicode</span>时，必须记住所有<span class="hljs-built_in">Unicode</span>字符使用相同的字节数。为了细分用于不同类<span class="hljs-built_in">Unicode</span>字符使用的存储，<br></code></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>观察</th><th>存储或检索过程</th></tr></thead><tbody><tr><td>CHAR</td><td>char</td><td>不进行大小写转换</td></tr><tr><td>VARCHAR</td><td>varchar</td><td>不进行大小写转换</td></tr><tr><td>BINARY</td><td>binary</td><td></td></tr><tr><td>VARBINARY</td><td>var-binary</td><td></td></tr><tr><td>BLOB</td><td>blob</td><td></td></tr><tr><td>TEXT</td><td>text</td><td></td></tr><tr><td>ENUM</td><td>enum</td><td></td></tr><tr><td>SET</td><td>set</td><td></td></tr></tbody></table><h3 id="char-和-varchar"><a href="#char-和-varchar" class="headerlink" title="char 和 varchar"></a>char 和 varchar</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">语法<br><span class="hljs-number">1.</span> 声明的长度就是你想要保存的最大字符长度<br><br>裁剪<br><span class="hljs-number">1</span>、分配给<span class="hljs-type">CHAR</span>或<span class="hljs-type">VARCHAR</span>列的值超过列的最大长度，则对值进行裁剪以使其适合。<br>a. 如果被裁掉的字符不是空格，则会产生一条警告。<br>b. 如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格<span class="hljs-keyword">SQL</span>模式禁用值的插入<br>注意： 严格模式下，不会进行裁剪，会直接进行报错<br><br>待补充<br>对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。<br><span class="hljs-type">CHAR</span> BYTE是<span class="hljs-type">CHAR</span> <span class="hljs-type">BINARY</span>的别名。这是为了保证兼容性。<br>ASCII属性为<span class="hljs-type">CHAR</span>列分配latin1字符集。UNICODE属性分配ucs2字符集<br></code></pre></td></tr></table></figure><ul><li><p>区别</p><table><thead><tr><th></th><th>char</th><th>varchar</th></tr></thead><tbody><tr><td>长度</td><td>声明时的长度</td><td>保存需要的字符，根据字符实际的长度开辟长度</td></tr><tr><td>检索保存</td><td>当保存CHAR值时，在它们的右边填充空格以达到指定的长度。<br />当检索到CHAR值时，尾部的空格被删除掉</td><td>保存和检索时尾部的空格仍保留，符合标准SQL <br />不进行填充</td></tr><tr><td>比较</td><td>不需要考虑任何尾部空格</td><td>不需要考虑任何尾部空格</td></tr></tbody></table></li><li><p>使用</p></li></ul><table><thead><tr><th><strong>值</strong></th><th>CHAR(4)</th><th><strong>存储需求</strong></th><th>VARCHAR(4)</th><th><strong>存储需求</strong></th></tr></thead><tbody><tr><td>‘’</td><td>‘  ‘</td><td>4个字节</td><td>‘’</td><td>1个字节</td></tr><tr><td>‘ab’</td><td>‘ab ‘</td><td>4个字节</td><td>‘ab ‘</td><td>3个字节</td></tr><tr><td>‘abcd’</td><td>‘abcd’</td><td>4个字节</td><td>‘abcd’</td><td>5个字节</td></tr><tr><td>‘abcdefgh’</td><td>‘abcd’</td><td>4个字节</td><td>‘abcd’</td><td>5个字节</td></tr></tbody></table><h3 id="binary-和-var-binary"><a href="#binary-和-var-binary" class="headerlink" title="binary 和 var-binary"></a>binary 和 var-binary</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">介绍<br><span class="hljs-bullet">1.</span> bianry 是二进制字符串，内容只能有0和1组成。说明没有字符集，并且排序和比较基于列值字节的数值值。<br><span class="hljs-bullet">2.</span> 注意：<br><span class="hljs-bullet">3.</span> 长度为字节长度而不是字符长度<br><span class="hljs-code"></span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h3 id="blob-和-text"><a href="#blob-和-text" class="headerlink" title="blob 和 text"></a>blob 和 text</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">blob</span> <br>介绍<br>二进制大文件对象<br>种类<br>tiny<span class="hljs-operator">-</span><span class="hljs-type">blob</span>, <span class="hljs-type">blob</span><br></code></pre></td></tr></table></figure><ul><li><p>类型</p><table><thead><tr><th></th><th>blob</th><th>text</th></tr></thead><tbody><tr><td>特点</td><td>二进制字符串（字节字符串）</td><td>非二进制字符串(字符字符串)</td></tr><tr><td>比较</td><td>BLOB列没有字符集，并且排序和比较基于列值字节的数值值</td><td>1. TEXT列有一个字符集，并且根据字符集的 校对规则对值进行排序和比较。<br />2. 比较时将用空格对TEXT进行扩充以适合比较的对象，正如CHAR和VARCHAR</td></tr><tr><td>存储和检索</td><td>1. 不存在大小写<br />2. 不删除尾部空格<br />3. 必须指定索引前缀的长度<br />4. 不能有默认值<br />5.</td><td>不存在大小写</td></tr><tr><td>理解</td><td>足够大的 var-binary</td><td>足够大的 varchar</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>​</p></li><li><p>区别</p></li></ul><table><thead><tr><th>类型</th><th></th></tr></thead><tbody><tr><td>tiny-blob</td><td></td></tr><tr><td>blob</td><td></td></tr><tr><td>medium-blob</td><td></td></tr><tr><td>long-blob</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>tiny-text</td><td></td></tr><tr><td>text</td><td></td></tr><tr><td>medium-text</td><td></td></tr><tr><td>long-text</td><td></td></tr></tbody></table><h2 id="枚举集合"><a href="#枚举集合" class="headerlink" title="枚举集合"></a>枚举集合</h2><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">介绍<br><span class="hljs-bullet">1.</span> 一个字符串对象， 用来枚举对象<br><span class="hljs-bullet">2.</span> 用于一个字段配以一个枚举值<br></code></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql">介绍<br>set: 计算机中用于存储无序且唯一的元素集合。<br>mysql_set:   用于一个字段配置多个枚举值<br>使用<br>该类型的字段可以包含0个或多个成员，但成员个数的上限为64。设置字段值时，可以取 取值范围内的 0 个或多个值。<br>该类型的字段，能包含多个成员。上为64个<br>特点<br>1. 插入的数据有重复值。会自动去重<br>下面的 插入(&#x27;A,B,B&#x27;) 得到的是 A,B<br>2. 向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误<br>下面的 插入(&#x27;A,B,D&#x27;) 会报错<br>3. 当创建表时，SET成员值的尾部空格将自动被删除<br>4. 大小写：<br>使用定义的时候指定的大小写<br>5. SET值按数字顺序排序。NULL值排在非NULL SET值的前面。<br><br><br>占用空间<br>根据初始化的成员个数来计算的， 8个成员一个字节，最多有 8 个字节<br><br>案例1<br><br><br><br>案例2<br>1. 用数字保存SET值<br><br><br></code></pre></td></tr></table></figure><ul><li>案例1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建表<br>CREATE TABLE test_set(<br>s SET (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)<br>);<br><br>#向表中插入数据： 插入的数据必须是前面指定的<br>INSERT INTO test_set (s) VALUES (&#x27;A&#x27;), (&#x27;A,B&#x27;);<br><br># 查询<br>SELECT * FROM test_set;<br><br># 结果<br>A<br>A<br>A，B<br></code></pre></td></tr></table></figure><ul><li><p>案例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 如果给 set 列分配了 9 ，其二进制形式为1001，因此第1个和第4个SET值成员&#x27;a&#x27;和&#x27;d&#x27;被选择，结果值为 &#x27;a,d&#x27;。<br>？？？？<br></code></pre></td></tr></table></figure><table><thead><tr><th>SET<strong>成员</strong></th><th><strong>十进制值</strong></th><th><strong>二进制值</strong></th></tr></thead><tbody><tr><td>‘a’</td><td>1</td><td>0001</td></tr><tr><td>‘b’</td><td>2</td><td>0010</td></tr><tr><td>‘c’</td><td>4</td><td>0100</td></tr><tr><td>‘d’</td><td>8</td><td>1000</td></tr></tbody></table></li></ul><h2 id="空间数据类型"><a href="#空间数据类型" class="headerlink" title="空间数据类型"></a>空间数据类型</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">GEOMETRY</span>, <span class="hljs-built_in">POINT</span>, LINESTRING, <span class="hljs-built_in">POLYGON</span>, <span class="hljs-built_in">MULTIPOINT</span>, MULTILINESTRING, MULTIPOLYGON, <span class="hljs-attr">GEOMETRYCOLLECTION</span>: 用于存储空间数据（地理信息、几何图形等）。<br></code></pre></td></tr></table></figure><h2 id="列存储汇总"><a href="#列存储汇总" class="headerlink" title="列存储汇总"></a>列存储汇总</h2><h3 id="数值-1"><a href="#数值-1" class="headerlink" title="数值"></a>数值</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">重点： <br><span class="hljs-string">[int]</span> <span class="hljs-number">4</span> 字节<br><span class="hljs-built_in">float</span> <span class="hljs-number">4</span>/<span class="hljs-number">8</span><br><span class="hljs-built_in">double</span> <span class="hljs-number">8</span><br> <br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>列类型</strong></th><th><strong>存储需求</strong></th></tr></thead><tbody><tr><td>TINYINT</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>2个字节</td></tr><tr><td>MEDIUMINT</td><td>3个字节</td></tr><tr><td>INT, INTEGER</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>8个字节</td></tr><tr><td>FLOAT(<em>p</em>)</td><td>如果0 &lt;&#x3D; <em>p</em> &lt;&#x3D;  24为4个字节, 如果25 &lt;&#x3D;  <em>p</em> &lt;&#x3D;  53为8个字节</td></tr><tr><td>FLOAT</td><td>4个字节</td></tr><tr><td>DOUBLE [PRECISION], item REAL</td><td>8个字节</td></tr><tr><td>DECIMAL(<em>M</em>,<em>D</em>)<br />NUMERIC(<em>M</em>,<em>D</em>)</td><td>变长；参见下面的讨论<br />如果M&gt;D，为M+2否则为D+2, 依赖于 M 和 D 的值</td></tr><tr><td>BIT(<em>M</em>)</td><td>大约(<em>M</em>+7)&#x2F;8个字节</td></tr></tbody></table><p><img src="F:\1=学习笔记\3=数据库\mysql\mysql基础\image-20231213094607758.png" alt="image-20231213094607758"></p><h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><table><thead><tr><th><strong>列类型</strong></th><th><strong>存储需求</strong></th><th></th><th>范围</th></tr></thead><tbody><tr><td>DATE</td><td>3个字节</td><td>YYYY-MM-DD</td><td>1000-01-01&#x2F;9999-12-31</td></tr><tr><td>DATETIME</td><td>8个字节</td><td>YYYY-MM-DD hh:mm:ss</td><td>‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td></tr><tr><td>TIMESTAMP</td><td>4个字节</td><td>YYYY-MM-DD hh:mm:s</td><td>‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC</td></tr><tr><td>TIME</td><td>3个字节</td><td>HH:MM:SS</td><td>结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07 ‘-838:59:59’&#x2F;‘838:59:59’</td></tr><tr><td>YEAR</td><td>1个字节</td><td>YYYY</td><td>1901&#x2F;2155</td></tr></tbody></table><h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><ul><li>L： 每个类型的存储需求取决于列值的实际长度</li></ul><table><thead><tr><th><strong>列类型</strong></th><th><strong>存储需求</strong></th><th></th></tr></thead><tbody><tr><td>CHAR(<em>M</em>)</td><td>M个字符，0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 255</td><td>定长字符串</td></tr><tr><td>VARCHAR(<em>M</em>)</td><td>M个字符，其中<em>L</em>  &lt;&#x3D; <em>M</em> 且0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 65535(参见下面的注释) 变长字符串</td><td></td></tr><tr><td>BINARY(<em>M</em>)</td><td><em>M</em>个字节，0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 255</td><td></td></tr><tr><td>VARBINARY(<em>M</em>)</td><td><em>L</em>+1个字节，其中<em>L</em>  &lt;&#x3D; <em>M</em> 且0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 255</td><td></td></tr><tr><td>TINYBLOB, TINYTEXT</td><td><em>L</em>+1个字节，其中<em>L</em>  &lt; 28</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>BLOB, TEXT</td><td><em>L</em>+2个字节，其中<em>L</em>  &lt; 216</td><td>二进制形式的长文本数据， 长文本数据</td></tr><tr><td>MEDIUMBLOB, MEDIUMTEXT</td><td><em>L</em>+3个字节，其中<em>L</em>  &lt; 224</td><td>可变类型</td></tr><tr><td>LONGBLOB, LONGTEXT</td><td><em>L</em>+4个字节，其中<em>L</em>  &lt; 232</td><td></td></tr><tr><td>ENUM(‘<em>value1</em>‘,’<em>value2</em>‘,…)</td><td>1或2个字节，取决于枚举值的个数(最多65,535个值)</td><td></td></tr></tbody></table><h2 id="列类型选择"><a href="#列类型选择" class="headerlink" title="列类型选择"></a>列类型选择</h2><ul><li><p>为了优化存储，在任何情况下均应使用最精确的类型</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">用精度为<span class="hljs-number">65</span>位十进制数(基于<span class="hljs-number">10</span>)对DECIMAL 列进行所有基本计算(+、-、*、/)。参见<span class="hljs-number">11.1</span><span class="hljs-selector-class">.1</span>节，“数值类型概述”。<br><br>使用双精度操作对DECIMAL值进行计算。如果准确度不是太重要或如果速度为最高优先级，DOUBLE类型即足够了。为了达到高精度，可以转换到保存在BIGINT中的定点类型。这样可以用<span class="hljs-number">64</span>位整数进行所有计算，根据需要将结果转换回浮点值。<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="&#x3D;&#x3D; 数据库操作"></a>&#x3D;&#x3D; 数据库操作</h1><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">元数据操作<br>create<br>drop<br><br><br># 可以省略的<br>在语法介绍中，方括号（“[”和“]”）用于指明可选字或子句。例如，在下面的语句中，IF EXISTS是可选的： <br>DROP TABLE [IF EXISTS] tbl_name<br><br><br># 多选一<br>当某一语法成分由多个可选项组成时，可选项应用竖线“|”分开。当可能选择一组选择中的某一成员时，可选项将列在方括号（“[”和“]”）<br>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)<br><br># 必选则一个<br>当必须选择一组选择中的某一成员时，可选项将列在大括号（“&#123;”和“&#125;”）中。<br>&#123;DESCRIBE | DESC&#125; tbl_name [col_name | wild]<br><br><br>省略号（…）表明省略了语句的某一选择，通常是为了提供复杂语法的简短表述。<br>INSERT ... SELECT是后跟SLECT语句的INSERT语句的简短形式。<br>省略号还能指明语句的前部分语法元素可重复。<br>RESET reset_option [,reset_option] ...<br></code></pre></td></tr></table></figure><ul><li>数据定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">在MySQL中，数据定义（Data Definition）指的是定义数据库、表格、列和相关数据库对象的过程。这包括创建、修改和删除数据库中的数据结构。常见的数据定义操作包括以下几种：<br><br>1. **创建数据库（CREATE DATABASE）**：用于创建新的数据库。<br><br>2. **创建表格（CREATE TABLE）**：用于在数据库中创建新的表格，指定表格的列、数据类型、约束条件等。<br><br>3. **修改表格结构（ALTER TABLE）**：用于修改现有表格的结构，如添加、删除、修改列，添加索引等。<br><br>4. **删除表格（DROP TABLE）**：用于从数据库中删除不再需要的表格及其相关数据。<br><br>5. **创建索引（CREATE INDEX）**：用于在表格的列上创建索引，以提高数据检索效率。<br><br>6. **定义视图（CREATE VIEW）**：用于创建虚拟的表格视图，使用户可以以特定的方式查看数据，而不实际修改原始表格。<br><br>7. **定义存储过程和函数（CREATE PROCEDURE / CREATE FUNCTION）**：用于创建可在数据库中执行的存储过程和函数，以便在需要时重复使用特定的操作或计算。<br><br>8. **定义触发器（CREATE TRIGGER）**：用于在特定的数据库事件（如插入、更新、删除等）发生时自动触发执行特定的操作。<br><br>数据定义操作是数据库管理的重要部分，它定义了数据库中存储数据的结构和规则，确保数据的一致性、完整性和安全性。<br></code></pre></td></tr></table></figure><h2 id="表元数据"><a href="#表元数据" class="headerlink" title="表元数据"></a>表元数据</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name<br>    [USING index_type]<br>    ON tbl_name (index_col_name,...)<br> <br>index_col_name:<br>    col_name [(length)] [ASC | DESC]<br><br></code></pre></td></tr></table></figure><h1 id="引擎擎操作"><a href="#引擎擎操作" class="headerlink" title="引擎擎操作"></a>引擎擎操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询引擎: 找出你的服务器支持哪个存储引擎，执行下面的语句<br><span class="hljs-keyword">show</span> engines;<br><span class="hljs-comment">-- 结果含义</span><br>yes: 支持并激活<br><span class="hljs-keyword">no</span>: 不支持<br>disabled: 支持该特性但是禁用<br><br>等价于<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;have%&#x27;</span><br><br><br><br></code></pre></td></tr></table></figure><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="创建-create"><a href="#创建-create" class="headerlink" title="创建 - create"></a>创建 - create</h2><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database if not exists test default character set， default COLLATE<br>create database if not exists test character set utf8,  COLLATE utf8mb4_general_ci;<br><br><br>CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name<br>    [create_specification [, create_specification] ...]<br> <br>create_specification:<br>    [DEFAULT] CHARACTER SET charset_name   -- 数据库使用的默认字符集<br>  | [DEFAULT] COLLATE collation_name --  数据库的排序规则<br><br><br><br><br><br>1. mysql 中 database 和 schema 是同义词， 可以互换使用， 同指数据库的集合和结构<br>2. 数据库模式： 通常用来描述数据库中的结构，包括表、视图、存储过程、函数、触发器等对象的定义。这些对象定义了数据库中数据的组织形式和操作方式。<br>3. 有些目录包含文件，这些文件与数据库中的表对应。MySQL中的数据库的执行方法与这些目录的执行方法相同。因为当数据库刚刚被创建时，在数据库中没有表，所以CREATE DATABASE只创建一个目录。这个目录位于MySQL数据目录和db.opt文件之下<br><br></code></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database self_name<br></code></pre></td></tr></table></figure><h2 id="修改-alter"><a href="#修改-alter" class="headerlink" title="修改 - alter"></a>修改 - alter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER &#123;DATABASE | SCHEMA&#125; [db_name]<br>    alter_specification [, alter_specification] ...<br><br>alter_specification:<br>    [DEFAULT] CHARACTER SET charset_name  # 修改字符集<br>  | [DEFAULT] COLLATE collation_name  # 修改排序方式<br><br><br>注意：<br>1. alter database 是修改数据库的全局属性，这些特性储存在数据库目录中的db.opt文件中<br>2. 数据库名省略，对应默认数据库<br><br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name<br><br>drop database if exists test;<br><br><br>特点：<br>1. 如果您对一个带有符号链接的数据库使用DROP DATABASE，则链接和原数据库都被取消<br>2. DROP DATABASE会返回已被取消的表的数目。此数目相当于被取消的.frm文件的数目。<br>3. 是删除创建数据库的时候创建的文件：<br>.BAK  .DAT  .HSH <br>    .MRG  .MYD  .ISD<br>    .MYI  .db   .frm<br>4. 如果在MySQL删除了上述这些文件之后，在数据库目录中仍保留有其它文件和目录，则数据库目录不能被取消。在这种情况下，您必须人工取消所有保留下的文件或目录，并再次发送DROP DATABASE语句。 <br></code></pre></td></tr></table></figure><h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use database<br>可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。<br>该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句：<br>即： 后面使用数据表的时候，不用使用 数据库.数据表 来定位表<br>注意<br>1. 使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表<br>mysql-&gt;use test1<br>mysql-&gt;select * from test2.student    # 这个语句是正常的<br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">方式一<br>mysql [-h 127.0.0.1] -u root opprimeton -D 数据库名称<br></code></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 获取当前用户能使用的数据库。请注意如果没有SHOW DATABASES权限，则不能看见所有数据库<br>show databases;<br><br><br>#选择使用的数据库, <br>#表示接下来执行的语句是在这个数据库中执行的<br>use self_database_name;<br><br># 当前使用的是哪个数据库<br># 如果你还没选择任何数据库，结果是NULL。<br>SELECT DATABASE();<br></code></pre></td></tr></table></figure><h1 id="数据表-表元数据"><a href="#数据表-表元数据" class="headerlink" title="数据表_表元数据"></a>数据表_表元数据</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="表创建"><a href="#表创建" class="headerlink" title="表创建"></a>表创建</h3><ul><li>使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式一<br>CREATE TABLE users (<br>    id INT AUTO_INCREMENT PRIMARY KEY,<br>    username VARCHAR(50) NOT NULL,<br>    email VARCHAR(100) NOT NULL,<br>    birthdate DATE,<br>    is_active BOOLEAN DEFAULT TRUE<br>);<br><br># 方式二<br>CREATE TABLE orders (<br>    order_id INT AUTO_INCREMENT,<br>    product_id INT,<br>    quantity INT,<br>    PRIMARY KEY (order_id),<br>    FOREIGN KEY (product_id) REFERENCES products(id)<br>);<br><br><br><br>CREATE TABLE pet (<br>name VARCHAR(20), <br>owner VARCHAR(20), <br>species VARCHAR(20), <br>sex CHAR(1), <br>birth DATE, <br>death DATE<br>);<br><br></code></pre></td></tr></table></figure><ul><li>语法结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name<br>    [(create_definition,...)]  ## 列定义，列创建<br>    [table_options]  # 表属性<br>    [partition_options]  # 表<br>    [select_statement] # 创建表的时候，填充的数据<br>或：<br><br>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name<br>    [(] LIKE old_tbl_name [)];<br><br>     <br>create_definition:<br>    column_definition column_constraint   # 列定义语句  列约束语句    列外键  列索引 <br>      <br>参数     <br>tempoaray:<br>      1. 只有在当前连接情况下，TEMPORARY表才是可见的。当连接关闭时，TEMPORARY表被自动取消。这意味着两个不同的连接可以使用相同的临时表名称，同时两个临时表不会互相冲突，也不与原有的同名的非临时表冲突。（原有的表被隐藏，直到临时表被取消时为止。）您必须拥有CREATE TEMPORARY TABLES权限，才能创建临时表。<br><br>if [not] exists<br>      1. 用于防止表存在发生错误<br>      2. 原有表的结构与 create table 语句中表示的表的结构是否相同，这一样没有验证<br>      3. 如果在 create table ... select 语句中使用 if not exists, 不论表是否已经存在，由 select 部分选择的记录都会被插入<br>      <br>注意      <br>1. 表名<br>    表名可以指定为 db_name.tbl_name 以便特定的数据库中创建表，即不论是否在当前库，都可以创建表。注意：`mydb`.`mytbl`是合法的，但是`mydb.mytbl`不合法。<br>2. 如果没有指定是 null 或者 not null， 列在创建的时候默认是 null<br><br>      <br></code></pre></td></tr></table></figure><h3 id="列定义"><a href="#列定义" class="headerlink" title="列定义"></a>列定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> <br>create_definition:<br>    column_definition   # 列定义语句 <br>    <br>column_definition:<br>    col_name      # 列名称<br>    type           # 列类型<br>    [NOT NULL | NULL]  # 创建表的时候，自动填充为 null ，默认(null)<br>    [DEFAULT default_value] # 列指定的默认值， 不指定默认是 null<br>        [AUTO_INCREMENT] # 用于在插入新行时自动为该列生成唯一递增的值，通常用于主键字段。<br>        [UNIQUE [KEY] | [PRIMARY] KEY]  # 唯一键，主键，主键就是唯一键<br>        [COMMENT &#x27;string&#x27;] # 列的注解信息，一般会设置为中文名<br>        [reference_definition外键] # 外键约束，用来连接当前表的列到另一个表的列，建立表之间的关系。<br>        <br>        | [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...)  # 约束，主键<br>        | KEY    # 约束，索引 key<br>        | INDEX [index_name] [index_type] (index_col_name,...) # 普通的索引<br>        | [CONSTRAINT [symbol]] UNIQUE [INDEX]   # 约束， 唯一索引<br>                [index_name] [index_type] (index_col_name,...)<br>        | [FULLTEXT|SPATIAL] [INDEX] [index_name] (index_col_name,...)   # 全文索引，表空间索引<br>        | [CONSTRAINT [symbol]] FOREIGN KEY # 约束，外键<br>                [index_name] (index_col_name,...) [reference_definition]<br>        | CHECK (expr)  #  定义了列中值的约束条件，确保符合指定的表达式。<br>    <br>    <br>    <br>注意<br>1. USE KEY、IGNORE KEY和FORCE KEY是USE INDEX、IGNORE INDEX和FORCE INDEX的同义词。<br>2. AUTO_INCREMENT 自增, 参看常用参数<br><br></code></pre></td></tr></table></figure><h3 id="列类型-1"><a href="#列类型-1" class="headerlink" title="列类型"></a>列类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mysql">type:<br>    TINYINT[(length)] <br>    [UNSIGNED] # 默认是有符号整数，除非指定为 unsinged 无符号整数<br>    [ZEROFILL] # 填充的数据长度不够指定的长度，是否需要左侧填充 0<br>  | SMALLINT[(length)] [UNSIGNED] [ZEROFILL]<br>  | MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]<br>  | INT[(length)] [UNSIGNED] [ZEROFILL]<br>  | INTEGER[(length)] [UNSIGNED] [ZEROFILL]<br>  | BIGINT[(length)] [UNSIGNED] [ZEROFILL]<br>  | REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]<br>  | DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]<br>  | FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]<br>  | DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]<br>  | NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]<br>  | DATE<br>  | TIME<br>  | TIMESTAMP<br>  | DATETIME<br>  | CHAR(length) [BINARY | ASCII | UNICODE]<br>  | VARCHAR(length) [BINARY]<br>  | TINYBLOB<br>  | BLOB<br>  | MEDIUMBLOB<br>  | LONGBLOB<br>  | TINYTEXT [BINARY]<br>  | TEXT [BINARY]<br>  | MEDIUMTEXT [BINARY]<br>  | LONGTEXT [BINARY]<br>  | ENUM(value1,value2,value3,...)<br>  | SET(value1,value2,value3,...)<br>  | spatial_type  # 空间坐标类型<br>  <br>  <br><br></code></pre></td></tr></table></figure><h3 id="列索引"><a href="#列索引" class="headerlink" title="列索引"></a>列索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">index_col_name:<br># 以 ASC或DESC为结尾用于指定递增或递减索引值存储。目前，这些关键词被分析，但是被忽略；索引值均以递增顺序存储。<br>    col_name [(length)] [ASC | DESC]<br></code></pre></td></tr></table></figure><h3 id="列外键"><a href="#列外键" class="headerlink" title="列外键"></a>列外键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">reference_definition:<br>    REFERENCES tbl_name [(index_col_name,...)]<br>               [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]<br>               [ON DELETE reference_option] #  参考表中的数据被删除时，对外键的影响<br>               [ON UPDATE reference_option] #  这部分是指定当参考表中的数据被更新时，对外键的影响<br> <br>reference_option:<br>    RESTRICT | CASCADE | SET NULL | NO ACTION<br>    # RESTRICT 表示阻止删除，<br>    # CASCADE 表示级联删除，<br>    # SET NULL 表示将外键设为 NULL，<br>    # NO ACTION 表示不执行任何操作（默认行为）。<br><br>-- ---------------------------------------------------------------<br>MATCH FULL 表示所有外键列都必须有对应的值，<br>MATCH PARTIAL 表示一些列可以为 NULL，<br>MATCH SIMPLE 表示只要有一个外键列有值即可<br><br><br></code></pre></td></tr></table></figure><h3 id="表属性"><a href="#表属性" class="headerlink" title="表属性"></a>表属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">table_option:<br>    &#123;ENGINE|TYPE&#125; = engine_name   # 指定表的存储引擎，比如 InnoDB、MyISAM 等。存储引擎决定了表的特性和支持的功能。<br>  | AUTO_INCREMENT = value  # 设置表中自增长列的起始值和步长<br>  | AVG_ROW_LENGTH = value  # 指定表中每行数据的平均长度，这有助于优化存储空间分配。<br>  | [DEFAULT] CHARACTER SET charset_name [COLLATE collation_name] # 定义表的默认字符集和校对规则。<br>  | CHECKSUM = &#123;0 | 1&#125; # 控制表在存储时是否使用校验和来保护数据完整性<br>  | COMMENT = &#x27;string&#x27; # 允许添加对表的注释描述。<br>  | CONNECTION = &#x27;connect_string&#x27; # 用于连接到远程服务器的连接参数。<br>  | MAX_ROWS = value  #  分别指定表的最大和最小行数，这些值可以用来优化存储空间分配。<br>  | MIN_ROWS = value<br>  | PACK_KEYS = &#123;0 | 1 | DEFAULT&#125; # 控制索引的压缩方式。<br>  | PASSWORD = &#x27;string&#x27; # 设置 MySQL 用户密码<br>  | DELAY_KEY_WRITE = &#123;0 | 1&#125; # 延迟索引写入，提高写入性能。<br>  | ROW_FORMAT = &#123;DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT&#125;  # 设置行的存储格式。x<br>  | UNION = (tbl_name[,tbl_name]...) # 创建联合表。<br>  | INSERT_METHOD = &#123; NO | FIRST | LAST &#125; # 指定在插入数据时处理重复键的方式。<br>  | DATA DIRECTORY = &#x27;absolute path to directory&#x27; # 定表数据和索引的存储目录。<br>  | INDEX DIRECTORY = &#x27;absolute path to directory&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mysql">partition_options:<br>    PARTITION BY<br>           [LINEAR] HASH(expr)<br>        |  [LINEAR] KEY(column_list)<br>        |  RANGE(expr)<br>        |  LIST(column_list)<br>    [PARTITIONS num]<br>    [  SUBPARTITION BY<br>           [LINEAR] HASH(expr)<br>         | [LINEAR] KEY(column_list)<br>      [SUBPARTITIONS(num)]  <br>    ]<br>    [(partition_definition), [(partition_definition)], ...]<br> <br>partition_definition:<br>    PARTITION partition_name<br>        [VALUES &#123; <br>                  LESS THAN (expr) | MAXVALUE <br>                | IN (value_list) &#125;]<br>        [[STORAGE] ENGINE [=] engine-name]<br>        [COMMENT [=] &#x27;comment_text&#x27; ]<br>        [DATA DIRECTORY [=] &#x27;data_dir&#x27;]<br>        [INDEX DIRECTORY [=] &#x27;index_dir&#x27;]<br>        [MAX_ROWS [=] max_number_of_rows]<br>        [MIN_ROWS [=] min_number_of_rows]<br>        [TABLESPACE [=] (tablespace_name)]<br>        [NODEGROUP [=] node_group_id]<br>        [(subpartition_definition), [(subpartition_definition)], ...]<br> <br>subpartition_definition:<br>    SUBPARTITION logical_name<br>        [[STORAGE] ENGINE [=] engine-name]<br>        [COMMENT [=] &#x27;comment_text&#x27; ]<br>        [DATA DIRECTORY [=] &#x27;data_dir&#x27;]<br>        [INDEX DIRECTORY [=] &#x27;index_dir&#x27;]<br>        [MAX_ROWS [=] max_number_of_rows]<br>        [MIN_ROWS [=] min_number_of_rows]<br>        [TABLESPACE [=] (tablespace_name)]<br>        [NODEGROUP [=] node_group_id]<br><br></code></pre></td></tr></table></figure><h3 id="表填充"><a href="#表填充" class="headerlink" title="表填充"></a>表填充</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[IGNORE | REPLACE] [AS] SELECT ...   (Some legal select statement)<br><br><br>这个 select_statement 是在创建表的时候，可以选择将新表的数据来自另一个已存在的表。它允许你执行一个 SELECT 查询来定义新表的初始数据。这个 SELECT 查询可以是任何合法的查询语句，你可以使用 IGNORE 或者 REPLACE 关键字来指定当遇到重复数据时的处理方式。<br><br>IGNORE: 如果在插入新数据时遇到重复的唯一键值，会忽略这些重复的行而不报错。<br>REPLACE: 如果遇到重复的唯一键值，会替换掉旧的数据行。<br>例如，假设你有一个现有的表 old_table，你可以通过以下方式创建一个新表 new_table 并从 old_table 中选择数据：<br><br>CREATE TABLE new_table LIKE old_table;<br>或者，你可以在创建新表的同时从旧表中选择数据：<br>CREATE TABLE new_table SELECT * FROM old_table;<br>这样就会将 old_table 中的所有数据复制到 new_table 中。<br><br></code></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h3><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 修改表名<br>alter table t rename test<br><br># 添加一个新的列<br>alter table t add d TIMESTAMP<br><br># 给列添加索引<br>alter table t add index(d) , add index(a)<br><br># 删除列<br>alter table t drop column d<br><br># 添加一个自增列<br># c编制了索引（作为PRIMARY KEY），因为AUTO_INCREMENT列必须编制索引。同时我们定义c为NOT NULL，因为主键列不能为NULL。<br>alter table t add d int unsinged not null AUTO_INCREMENT add primary key(c)<br><br><br><br># alter 进行重命名： ALTER TABLE my_table CHANGE old_column new_column 数据类型;<br> ALTER TABLE t1 CHANGE a b INTEGER<br> <br> # alter 更改列的类型: 新旧列的名称一致<br>  ALTER TABLE t1 CHANGE a a INTEGER<br>  ALTER TABLE t1 MODIFY b INTEGER NOT NULL;<br>  <br>  #取消外键<br>   ALTER TABLE yourtablename DROP FOREIGN KEY fk_symbol;<br>   <br>   #把表默认的字符集和所有字符列（CHAR, VARCHAR, TEXT）改为新的字符集<br>   ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;<br>   #-- 上面语句会出现问题：有一列使用一种字符集（如latin1），但是存储的值实际上使用了其它的字符集（如utf8）<br>   #-- 原因： 当您转换到BLOB列或从BLOB列转换过来时，并没有发生转换<br>   #-- 如果您指定CONVERT TO CHARACTER SET为二进制，则TEXT列被转换到相应的二进制字符串类型（BINARY, VARBINARY, BLOB）。这意味着这些列将不再有字符集，接下来的CONVERT TO操作也将不适用于这些列。<br>   ALTER TABLE t1 CHANGE c1 c1 BLOB;<br>   ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;<br><br>   <br>   # 要仅仅改变一个表的默认字符集<br>   ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name;<br>   <br># 在表中增加一个新的分区p3，该分区用于储存小于2002的值   <br>alter table t1 add partition  p1 values less than (2000)<br></code></pre></td></tr></table></figure><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER [IGNORE] TABLE tbl_name<br>    alter_specification [, alter_specification] ...<br>    <br>alter_specification:<br>  # ---------------------------------------------------------------------<br>  # 添加一个新的列，可以指定其位置为表的首列或某列之后,默认是添加到最后<br>    ADD [COLUMN] column_definition [FIRST | AFTER col_name ]  <br>  # 修改列的默认值或删除默认值(指定列的新默认值，或删除旧的默认值)==》如果旧的默认值被删除同时列值为NULL，则新的默认值为NULL。如果列值不能为NULL，MySQL会指定一个默认值<br>  | ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;<br>  # 修改列名称和定义，可指定新列的位置<br>  | CHANGE [COLUMN] old_col_name column_definition<br>        [FIRST|AFTER col_name]<br>  # 改列的定义，可以更改数据类型等。<br>  # MODIFY是Oracle对ALTER TABLE的扩展<br>  | MODIFY [COLUMN] column_definition [FIRST | AFTER col_name]<br>  # 删除指定的列。<br>  | DROP [COLUMN] col_name<br>  # 一次性添加多个列<br>  | ADD [COLUMN] (column_definition,...)<br><br>  # ---------------------------------------------------------------------<br>  # 添加主键约束，指定主键的列和类型<br>  # 如果您向表中添加UNIQUE KEY或PRIMARY KEY，则UNIQUE KEY或PRIMARY KEY会被储存在非唯一索引之前，这样MySQL就可以尽早地检查出重复关键字<br>  | ADD [CONSTRAINT [symbol]]<br>        PRIMARY KEY [index_type] (index_col_name,...)<br>  # 添加唯一约束，确保列或列组合的唯一性。<br>  | ADD [CONSTRAINT [symbol]]<br>        UNIQUE [index_name] [index_type] (index_col_name,...)<br>  # 添加外键约束，指定外键的列和参考表的相关定义。<br>  | ADD [CONSTRAINT [symbol]]<br>        FOREIGN KEY [index_name] (index_col_name,...)<br>        [reference_definition]<br>  # 删除主键。<br>  # 在MySQL较早的版本中，如果没有主索引，则DROP PRIMARY KEY会取消表中的第一个UNIQUE索引<br>  # MySQL 5.1中对没有主键的表使用DROP PRIMARY KEY，则会出现错误信息。<br>  | DROP PRIMARY KEY  <br>  # 删除指定的外键约束。<br>  | DROP FOREIGN KEY fk_symbol    <br><br> # ---------------------------------------------------------------------<br>  # 添加一个索引，可以指定索引的名称、类型以及涉及的列。<br>  | ADD INDEX [index_name] [index_type] (index_col_name,...)<br>  # 加全文或空间索引。      <br>  | ADD [FULLTEXT|SPATIAL] [index_name] (index_col_name,...) <br>  # 删除指定的索引: 为 mysql 的扩展<br>  | DROP INDEX index_name <br>  # 禁止索引的使用: 在进行成批插入操作前先使关键字禁用可以大大地加快速度<br>  | DISABLE KEYS<br>  # 启用索引的使用<br>  | ENABLE KEYS<br>   # ---------------------------------------------------------------------<br>   <br>   <br>  #  重命名表<br>  | RENAME [TO] new_tbl_name<br>  # 对表中的数据按照指定列排序<br>  | ORDER BY col_name<br>  # 修改表的字符集和校对规则。<br>  | CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]<br>  # 带不带 default 都是等价的，只用于更改默认的表字符集。<br>  | [DEFAULT] CHARACTER SET charset_name [COLLATE collation_name]<br>  # 丢弃表空间<br>  | DISCARD TABLESPACE<br>  #  导入表空间<br>  | IMPORT TABLESPACE<br>  # 表级别的选项<br>  | table_options<br>   # ---------------------------------------------------------------------<br>   <br>  # 1. 不能使用ALTER TABLE向一个没有进行分区的表添加分区。<br>  # 2. 对于没有明确命名的分区，MySQL会自动提供默认名称p0, p1, p2等<br>  #  分区选项<br>  | partition_options<br>  # 添加分区: <br>  # 1. 不支持 if [not] exists <br>  | ADD PARTITION partition_definition<br>  # 删除分区:<br>  # 1. 如果被取消的分区其名称列于partition_names清单中，则储存在此分区中的数据也被取消。<br>  # 2. 只能用于一个或者多个 range,list 分区，不能用于 hash 和 key 分区（hash和key分区使用colesce partition）<br>  # 3. 不支持 if [not] exists<br>  | DROP PARTITION partition_names<br>  # 合并分区， 用来取消 hash 和 key 分区，取消的分区数据会被合并到没有取消的分区中<br>  | COALESCE PARTITION number<br>  # 重新组织分区: 更改部分分区，但不更改所有的分区<br>  | REORGANIZE PARTITION partition_names INTO (partition_definitions)<br>  # 分析分区<br>  | ANALYZE PARTITION partition_names<br>  # 检查分区<br>  | CHECK PARTITION partition_names<br>  # 优化分区<br>  | OPTIMIZE PARTITION partition_names<br>  # 重建分区<br>  | REBUILD PARTITION partition_names<br>  # 修复分区<br>  | REPAIR PARTITION partition_names<br>  # 重命名分区<br>  # 1. 如果您希望对一个分区进行重命名，您必须取消分区，再重新建立；<br>  # 2. 如果您希望对一个已分区的表进行重新命名，您必须取消所有分区，然后对表进行重命名，再添加被取消的分区。<br><br>  <br>参数<br>ignore:<br>如果在新表中有重复关键字，或者当STRICT模式启动后出现警告，则使用IGNORE控制ALTER TABLE的运行<br>1. 没有指定IGNORE，当重复关键字错误发生时，复制操作被放弃，返回前一步骤<br>2. 指定了IGNORE，则对于有重复关键字的行，只使用第一行，其它有冲突的行被删除。并且，对错误值进行修正，使之尽量接近正确值。<br>  <br>使用限制<br>1. alter 的子句语法基本上跟 create 相同，  table_options 可以参考 create table 的<br>2， 某些引擎不支持某些参数，会出现警告，可以使用 show warnings 查看<br>3. alter table 运行时会对原表进行临时复制【除了rename选项】，在副本上进行更改，然后删除原表，再对新表进行重命名。在执行ALTER TABLE时，其它用户可以阅读原表，但是对表的更新和修改的操作将被延迟，直到新表生成为止。新表生成后，这些更新和修改信息会自动转移到新表上。<br>a. 对于MyISAM表，您可以通过把myisam_sort_buffer_size系统变量设置到一个较高的值，来加快重新创建索引（该操作是变更过程中速度最慢的一部分）的速度。<br>b. 使用 alter table 需要获得表的ALTER, INSERT和CREATE权限。<br>c. 使用ALTER TABLE tbl_name RENAME TO new_tbl_name并且没有其它选项，则MySQL只对与table tbl_name相对应的文件进行重命名。不需要创建一个临时表<br><br><br>4. mysql扩展了 alter,  <br>a. alter table 可以写入多个ADD, ALTER, DROP和CHANGE子句，中间用逗号分开<br>ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;<br>b. CHANGE col_name, DROP col_name和DROP INDEX是MySQL相对于标准SQL的扩展。<br>c. MODIFY是Oracle对ALTER TABLE的扩展。<br><br>5. change, modify<br>a. 缩短列长时，列中存在有索引，并且缩短后的列长小于索引长度，则MySQL会自动缩短索引的长度。<br>6. 如果列从表中被取消了，则这些列也从相应的索引中被取消。如果组成一个索引的所有列均被取消，则该索引也被取消。<br>   如果一个表只包含一列，则此列不能被取消。如果您想要取消表，应使用DROP TABLE。<br>   <br>7.  子句兼容性<br> Innodb存储引擎支持FOREIGN KEY和REFERENCES子句, 对于其它存储引擎，这些子句会被分析，但是会被忽略。对于所有的存储引擎，CHECK子句会被分析，但是会被忽略。接受这些子句但又忽略子句的原因是为了提高兼容性，以便更容易地从其它SQL服务器中导入代码，并运行应用程序，创建带参考数据的表<br><br>8. ALTER TABLE忽略DATA DIRECTORY和INDEX DIRECTORY表选项。<br><br>9. coalesce partition 用来删除 hash 和 key 分区的表<br>    alter table t coalesce partition 2  【原本有 6 个分区】<br>    a. 包含在最后一个number分区中的数据将被合并到其余的分区中。在此情况下，分区4和分区5将被合并到前4个分区中（编号为0、1、2和3的分区）。<br><br>9. REORGANIZE PARTITION<br>使用方法<br>a. 把多个分区合并为一个分区。通过把多个分区的名称列入partition_names清单，并为partition_definition提供一个单一的定义，可以实现这个功能。<br>b。 把一个原有的分区拆分为多个分区。通过为partition_names命名一个分区，并提供多个partition_definitions，可以实现这个功能。<br>c. 更改使用VALUES LESS THAN定义的分区子集的范围或更改使用VALUES IN定义的分区子集的值清单。<br><br><br><br><br><br><br><br><br><br><br><br>    <br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP [TEMPORARY] TABLE [IF EXISTS]<br>    tbl_name [, tbl_name] ...<br>    [RESTRICT | CASCADE]  # 这是在删除表时进行约束检查的选项<br><br>参数<br>1. temporary<br>a. 用于指定删除临时表（只在当前会话中存在的表）。<br>       语句只取消TEMPORARY表。<br>      语句不会终止正在进行中的事务。<br>      不会查验存取权。（TEMPORARY表仅对于创建该表的客户端是可见的，所以查验是不必要的。）<br><br>2. if exists<br>对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。[show 语法]<br><br>1. 这是在删除表时进行约束检查的选项<br>restrict: 如果其他对象依赖于要删除的表，将会阻止删除操作<br>cascade: 如果其他对象依赖于要删除的表，将会一并删除这些依赖对象。<br><br><br>特点<br>1. 对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件<br>    2. 除非您使用TEMPORARY关键词，DROP TABLE会自动提交当前的有效的事务<br><br>    <br><br></code></pre></td></tr></table></figure><h2 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询数据库中有哪些数据表<br>SHOW TABLES;<br><br># 查询某个表的元数据<br># Field显示列名字，Type是列的数据类型，Null表示列是否能包含NULL值，Key显示列是否被索引而Default指定列的默认值。<br>describe self_表名<br><br></code></pre></td></tr></table></figure><h1 id="数据表-列元数据"><a href="#数据表-列元数据" class="headerlink" title="数据表_列元数据"></a>数据表_列元数据</h1><h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name<br>    [USING index_type]<br>    ON tbl_name (index_col_name,...)<br> <br><br>   <br>参数<br>USING index_type<br>1. 部分储存引擎允许在创建索引时指定索引类型，如果列有多个索引类型，当没有指定index_type时，第一个类型是默认值<br>存储引擎 MyISAM  允许的索引类型  BTREE<br>存储引擎 InnoDB  允许的索引类型  BTREE<br>存储引擎 MEMORY/HEAP  允许的索引类型 HASH, BTREE<br>CREATE TABLE lookup (id INT) ENGINE = MEMORY;<br>CREATE INDEX id_index USING BTREE ON lookup (id);<br>2. TYPE type_name可以作为USING type_name的同义词，用于指定索引类型.<br>a.在索引规约语法中，位于索引类型前面的索引名称不能使用TYPE。这是因为，与USING不同，TYPE不是保留词，因此会被认为是一个索引名称<br>b.USING是首选的格式<br><br>    <br>注意：    <br>    <br>1, CREATE INDEX被映射到一个ALTER TABLE语句上，用于创建索引<br>2, CREATE INDEX允许您向已有的表中添加索引。<br>   CREATE TABLE创建表时，也同时在表中创建了所有的索引<br> <br>3, 多列索引<br>  格式为（col1, col2,...）的一个列清单创建出一个多列索引。通过串接给定列中的值，确定索引值的格式<br>  <br>4. 对于CHAR和VARCHAR列，只用一列的一部分就可创建索引。创建索引时，使用col_name(length)语法，对前缀编制索引。前缀包括每列值的前length个字符。BLOB和TEXT列也可以编制索引，但是必须给出前缀长度。<br># 创建一个索引，索引使用列名称的前10个字符。<br>CREATE INDEX part_of_name ON customer (name(10));<br>     a. 多数名称的前10个字符通常不同，所以此索引不会比使用列的全名创建的索引速度慢很多。另外，使用列的一部分创建索引可以使索引文件大大减小，从而节省了大量的磁盘空间，有可能提高INSERT操作的速度<br>     b. 前缀最长为255字节。对于MyISAM和InnoDB表，前缀最长为1000字节。【注意前缀的限长以字节计，而CREATE INDEX语句中的前缀长度指的是字符的数目。对于使用多字节字符集的列，在指定列的前缀长度时，要考虑这一点。】<br><br> <br><br><br>MYSQL5.1中：<br>a. 只有当您正在使用MyISAM, InnoDB或BDB表类型时，您可以向有NULL值的列中添加索引。<br>b. 只有当您正在使用MyISAM, BDB或InnoDB表类型时，您可以向BLOB或TEXT列中添加索引。<br>5. 如果您指定的索引类型在给定的储存引擎中不合法，但是有其它的索引类型适合引擎使用，并且不会影响查询功能，则引擎应使用此类型。<br>6. FULLTEXT索引只能对CHAR, VARCHAR和TEXT列编制索引，并且只能在MyISAM表中编制<br>7. SPATIAL索引只能对空间列编制索引，并且只能在MyISAM表中编制<br>   <br><br></code></pre></td></tr></table></figure><h1 id="数据表-数据"><a href="#数据表-数据" class="headerlink" title="数据表_数据"></a>数据表_数据</h1><h2 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 按升序对动物的种类进行排序，然后按降序根据生日对各动物种类进行排序（最年轻的动物在最前面），<br># 注意DESC关键字仅适用于在它前面的列名(birth)；不影响species列的排序顺序。<br>SELECT name, species, birth FROM pet ORDER BY species, birth DESC;<br><br><br><br><br><br></code></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>      [ALL | DISTINCT | DISTINCTROW ] # 用于控制返回结果集中的唯一值。ALL 返回所有匹配的行，DISTINCT 返回唯一不同的行，DISTINCTROW 在某些数据库中类似于 DISTINCT。<br>      [HIGH_PRIORITY] # 这是一个查询优先级提示，用于指示数据库系统优先处理该查询。<br>      [STRAIGHT_JOIN] # 强制使用指定的连接顺序，可能会影响查询优化<br>      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] # 这些是用于控制查询结果集大小和缓冲的选项，用于优化查询性能。<br>      [SQL_CACHE | SQL_NO_CACHE]  # 控制查询结果是否被缓存。<br>      [SQL_CALC_FOUND_ROWS] # 当查询包含 LIMIT 子句时，使用这个选项可以获取在不考虑 LIMIT 的情况下，满足条件的行数。<br>    select_expr, ...  # 这里是列名或表达式，表示要检索行元数据<br>      [INTO OUTFILE &#x27;file_name&#x27; export_options | INTO DUMPFILE &#x27;file_name&#x27;] # 将查询结果输出到文件，可以是文本文件或二进制文件。<br>    [FROM table_references  # 指定数据来自哪些表或子查询<br>    [WHERE where_definition] #  该表达式指示被选择的行必须满足的条件。<br>       [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] # 对结果集进行分组，可以使用 WITH ROLLUP 生成额外的行汇总。<br>   [HAVING where_definition] # 类似于 WHERE，但是在分组之后对分组结果进行过滤。<br>    [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC] , ...]  # 指定结果集的排序方式。<br>    [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] # 限制返回的行数<br>    [PROCEDURE procedure_name(argument_list)] # 可以调用存储过程来处理数据。<br>    [FOR UPDATE | LOCK IN SHARE MODE] # 控制对查询结果行的锁定方式，以确保一致性和避免并发问题。<br>    ] <br># ----------------------------------------------------------------------------------------------<br>1. 所有被使用的子句[必须]按语法说明中显示的顺序严格地排序<br>2. <br># ----------------------------------------------------------------------------------------------<br> <br></code></pre></td></tr></table></figure><ul><li><p>基础参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALL, DISTINCT和DISTINCTROW<br>1. 指定是否重复行应被返回。<br>3. 如果这些选项没有被给定，则默认值为ALL（所有的匹配行被返回）。<br>2. DISTINCT和DISTINCTROW是同义词，用于指定结果集合中的重复行应被删除。<br><br>HIGH_PRIORITY, STRAIGHT_JOIN和以SQL_为开头:  是MySQL相对于标准SQL的扩展。<br>·         HIGH_PRIORITY给予SELECT更高的优先权，高于用于更新表的语句。您应该只对查询使用HIGH_PRIORITY。查询速度非常快，而且立刻被执行。SELECT HIGH_PRIORITY查询在表被锁定用于读取时被发出。即使有一个新的语句正在等待表变为空闲，查询也会运行。<br> 注意：HIGH_PRIORITY不能和SELECT语句同时使用。SELECT语句是UNION的一部分。<br><br>·         STRAIGHT_JOIN用于促使优化符把表联合在一起，顺序按照这些表在FROM子句中排列的顺序。如果优化符联合表时顺序不佳，您可以使用STRAIGHT_JOIN来加快查询的速度。 ‘join语法’<br><br>·         SQL_BIG_RESULT可以与GROUP BY或DISTINCT同时使用，来告知优化符结果集合有很多行。在这种情况下，MySQL直接使用以磁盘为基础的临时表（如果需要的话）。在这种情况下，MySQL还会优先进行分类，不优先使用临时表。临时表对于GROUP BY组分带有关键字。<br><br>·         SQL_BUFFER_RESULT促使结果被放入一个临时表中。这可以帮助MySQL提前解开表锁定，在需要花费较长时间的情况下，也可以帮助把结果集合发送到客户端中。<br><br>·         SQL_SMALL_RESULT可以与GROUP BY或DISTINCT同时使用，来告知优化符结果集合是较小的。在此情况下，MySAL使用快速临时表来储存生成的表，而不是使用分类。在MySQL 5.1中，通常不需要这样。<br><br>·         SQL_CALC_FOUND_ROWS告知MySQL计算有多少行应位于结果集合中，不考虑任何LIMIT子句。行的数目可以使用SELECT FOUND_ROWS()恢复。请参见12.9.3节，“信息函数”。<br><br>·         如果您正在使用一个query_cache_type值，值为2或DEMAND，则SQL_CACHE告知MySQL把查询结果存储在查询缓存中。对于使用UNION的查询或子查询，本选项会影响查询中的所有SELECT。请参见5.13节，“MySQL查询高速缓冲”。<br><br>·         SQL_NO_CACHE告知MySQL不要把查询结果存储在查询缓存中。请参见5.13节，“MySQL查询高速缓冲”。对于一个使用UNION或子查询的查询，本选项会影响查询中的SELECT。 <br><br></code></pre></td></tr></table></figure></li><li><p>选择到文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INTO OUTFILE &#x27;file_name&#x27; export_options | INTO DUMPFILE &#x27;file_name&#x27;<br>1. 把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。file_name不能是一个原有的文件。原有文件会阻止例如“/etc/passwd”的文件和数据库表被销毁。<br>2. 主要作用是让您可以非常快速地把一个表转储到服务器机器上<br><br>export_options<br>FIELDS和LINES子句, 这些子句与LOAD DATA INFILE语句同时使用<br><br><br>同类型的<br>mysql –e &quot;SELECT ...&quot; &gt; file_name”的命令，来生成文件<br><br><br># ===== 待整理<br>SELECT...INTO OUTFILE是LOAD DATA INFILE的补语；用于语句的exort_options部分的语法包括部分FIELDS和LINES子句，这些子句与LOAD DATA INFILE语句同时使用。请参见13.2.5节，“LOAD DATA INFILE语法”。<br><br>FIELDS ESCAPED BY用于控制如何写入特殊字符。如果FIELDS ESCAPED BY字符不是空字符，则被用于在输出中对以下字符设前缀：<br><br>o        FIELDS ESCAPED BY字符<br><br>o        FIELDS [OPTIONALLY] ENCLOSED BY字符<br><br>o        FIELDS TERMINATED BY和LINES TERMINATED BY值的第一个字符<br><br>o        ASCII 0（在编写时接在转义符后面的是ASCII ‘0’，而不是一个零值字节）<br><br>如果FIELDS ESCAPED BY字符是空字符，则没有字符被转义，并且NULL被作为NULL输出，而不是作为\N输出。指定一个空的转义符不是一个好的主意。特别是当您的数据中的字段值包含刚被给予的清单中的字符时，更是如此。<br><br>其原因是您必须对所有FIELDS TERMINATED BY, ENCLOSED BY, ESCAPED BY或LINES TERMINATED BY字符进行转义，才能可靠地读取文件并返回。ASCII NUL被转义，以便更容易地使用调页程序观看。<br><br>生成的文件不必符合SQL语法，所以没有其它的字符需要被转义。<br><br>在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。<br><br>SELECT a,b,a+b INTO OUTFILE &#x27;/tmp/result.text&#x27;<br>FIELDS TERMINATED BY &#x27;,&#x27; OPTIONALLY ENCLOSED BY &#x27;&quot;&#x27;<br>LINES TERMINATED BY &#x27;\n&#x27;<br>FROM test_table;<br>·         如果您使用INTO DUMPFILE代替INTO OUTFILE，则MySQL只把一行写入到文件中，不对任何列或行进行终止，也不执行任何转义处理。如果您想要把一个BLOB值存储到文件中，则这个语句是有用的。<br><br>·         注释：任何由INTO OUTFILE或INTO DUMPFILE创建的文件都可以被服务器主机上的所有用户编写。原因是，MySQL服务器不能创建这样的文件，即文件的所有者不是该文件运行时所属的用户（任何时候，您都不能出于此原因或出于其它原因把mysqld作为根段运行）。该文件必须是全局可写的，这样您就可以操作其中的内容。<br><br>·         有的过程应在结果集合内处理数据。PROCEDURE子句用于对这些过程进行命名。要了解示例，请参见27.3.1节，“步骤分析”。<br><br>·         存储引擎使用页面或行锁。如果您对存储引擎使用FOR UPDATE，则受到查询检验的行会被进行写锁定，直到当前事务结束为止。使用LOCK IN SHARE MODE可以设置一个共享锁。共享锁可以防止其它事务更新或删除被检验的行。请参见15.2.10.5节，“锁定读取SELECT ... FOR UPDATE和SELECT ... LOCK IN SHARE MODE”。<br><br>在SELECT关键词的<br><br></code></pre></td></tr></table></figure><h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FROM table_references<br>1. 如果您命名的表多于一个，则您在进行一个联合操作,对于每一个被指定的表，您可以自选地指定一个别名<br>2. 可以向优化符提示如何选择索引<br> tbl_name [[AS] alias]  [&#123;USE|IGNORE|FORCE&#125; INDEX (key_list)]<br><br><br>参数<br>  USE INDEX: 强制查询使用指定的索引，如果这个索引不存在，查询将报错。<br>  IGNORE INDEX: 强制查询忽略指定的索引，即使这个索引存在也不使用它。<br>  FORCE INDEX: 强制查询使用指定的索引，如果这个索引不存在，查询会继续执行并忽略这个索引的存在<br>  key_list： 是一个逗号分隔的索引列表，指定了要使用的索引。这可以是单个索引或者多个索引的组合。<br><br><br><br>虚表<br>1. 在没有表被引用的情况下，允许您指定DUAL作为一个假的表名<br>SELECT 1 + 1 FROM DUAL;<br><br>/<br><br></code></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">where<br>1.<br>2. 在WHERE子句中，您可以使用MySQL支持的所有函数，不过总计（总结）函数除外<br></code></pre></td></tr></table></figure><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">group<br>1. 可以使用列名 &#123;col_name&#125;，表达式 &#123;expr&#125; 或者列的位置 &#123;position&#125; 来作为分组依据。<br>2. ASC 和 DESC 用于指定排序顺序，默认是升序（ASC）<br>3. [WITH ROLLUP]: 这是一个可选部分，用于生成包含汇总行的结果。WITH ROLLUP 可以生成一个额外的行，包含每个分组的汇总值，这个行会在结果中以 NULL 或者其他特殊标识出现，表示对应列的总计或者小计。<br><br></code></pre></td></tr></table></figure><h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. SQL标准要求HAVING必须引用GROUP BY子句中的列或用于总计函数中的列。不过，MySQL支持对此工作性质的扩展，并允许HAVING因为SELECT清单中的列和外部子查询中的列。<br><br>2. HAVING子句引用了一个意义不明确的列，则会出现警告<br># col2意义不明确，因为它既作为别名使用，又作为列名使用<br>SELECT COUNT(col1) AS col2 <br>FROM t GROUP <br>BY col2 <br>HAVING col2 = 2;<br><br>3.  HAVING不能用于应被用于WHERE子句的条目<br>   异常语句： SELECT col_name FROM tbl_name HAVING col_name &gt; 0;<br>   修改语句： SELECT col_name FROM tbl_name WHERE col_name &gt; 0;<br>   <br>4.  HAVING子句可以引用总计函数，而WHERE子句不能引用：<br>    SELECT user, MAX(salary) FROM users GROUP BY user HAVING MAX(salary)&gt;10;<br>    <br>5.     <br></code></pre></td></tr></table></figure><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">limit<br>1. LIMIT row_count: 这种形式指定了要返回的行数。例如，LIMIT 10 表示只返回查询结果的前 10 行。<br>2. LIMIT row_count OFFSET offset: 这种形式中，row_count 表示要返回的行数，offset 表示从查询结果的起始位置开始跳过的行数。例如， 表示<br>   a. 从查询结果的第 11 行开始，返回接下来的 5 行数据。<br>     LIMIT 5 OFFSET 10<br>     LIMIT 5, 10  #  LIMIT n与LIMIT 0,n等价<br>     。<br>3. 为了与PostgreSQL兼容，MySQL也支持<br>LIMIT row_count OFFSET offset<br></code></pre></td></tr></table></figure><h3 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">对于已预备的语句，您可以使用位置保持符。以下语句将从tb1表中返回一行：<br><br>mysql&gt; SET @a=1;<br>mysql&gt; PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?&quot;;<br>mysql&gt; EXECUTE STMT USING @a;<br>以下语句将从tb1表中返回第二到第六行：<br><br>mysql&gt; SET @skip=1; SET @numrows=5;<br>mysql&gt; PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?, ?&quot;;<br>mysql&gt; EXECUTE STMT USING @skip, @numrows; <br><br></code></pre></td></tr></table></figure><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">使用AS alias_name可以为select_expr给定一个别名。此别名用作表达式的列名，可以用于GROUP BY、ORDER BY或HAVING子句<br><br>mysql&gt; SELECT CONCAT(last_name,&#x27;, &#x27;,first_name) AS full_name<br>-&gt; FROM mytable ORDER BY full_name;<br><br># as 可以省略<br># 没有在两个select_expr表达式之间加逗号，则会出现一个小问题：MySQL会把第二个表达式理解为一个别名<br>SELECT columna columnb FROM mytable;<br><br>2. 表别名可以在 where 子句中使用， 别名使用不讲顺序<br>SELECT t1.name, t2.salary <br>  FROM employee t1, info t2<br>  WHERE t1.name = t2.name;<br><br>2. 被选择的用于输出的列可以使用列名称、列别名或列位置被引用到ORDER BY和GROUP BY子句中。列位置为整数，从1开始<br>SELECT college, region AS r, seed AS s <br> FROM tournament<br> ORDER BY r, s;<br> <br># 不建议使用列位置，因为该语法已经从SQL标准中删除。 <br>SELECT college, region, seed <br>FROM tournament <br>    ORDER BY 2, 3;<br><br>注意<br>1. 使用AS明确地指定列的别名，把它作为习惯，是一个良好的操作规范<br>2.  在一个WHERE子句中使用列别名是不允许的，因为当执行WHERE子句时，列值可能还没有被确定<br></code></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># From table_references: 的语句<br>table_references:<br>    table_reference [, table_reference] …<br><br>table_reference:<br>    table_factor  | join_table <br><br># 使用下面的任何一行都可以<br>table_factor:<br>    tbl_name [[AS] alias] [&#123;USE|IGNORE|FORCE&#125; INDEX (key_list)]<br>  | ( table_references )<br>  | &#123; OJ table_reference LEFT OUTER JOIN table_reference ON conditional_expr &#125; # 目的只是为了保持与ODBC的兼容性<br><br>join_table:<br>    table_reference [INNER | CROSS] JOIN table_factor [join_condition]<br>  | table_reference STRAIGHT_JOIN table_factor    #straight_join 强制 MySQL 使用特定的连接顺序。<br>  | table_reference STRAIGHT_JOIN table_factor ON condition <br>  | table_reference LEFT [OUTER] JOIN table_reference join_condition # 左连<br>  | table_reference NATURAL [LEFT [OUTER]] JOIN table_factor # <br>  | table_reference RIGHT [OUTER] JOIN table_reference join_condition # 右连<br>  | table_reference NATURAL [RIGHT [OUTER]] JOIN table_factor<br> <br># -----------------------<br>straignt_join<br>1. 它用于指定在查询中按照表的顺序进行连接。当你在 SQL 查询中使用 JOIN 来连接多个表时，数据库通常会尝试找到最有效的连接顺序和方法来执行这些连接，以获得最佳性能。但有时候数据库的优化并不总是最适合你的情况，这时你可能希望强制数据库按照你给定的表连接顺序来执行连接操作<br># 查询中的 STRAIGHT_JOIN 关键字告诉数据库明确按照你给定的顺序，首先连接 users 表，然后连接 orders 表，而不是让数据库自己决定连接顺序。<br>SELECT * FROM users STRAIGHT_JOIN orders ON users.id = orders.user_id;<br><br><br><br><br>natural join<br>1. 表示进行自然连接，它会自动查找两个表中具有相同列名的列，并将它们作为连接条件进行连接<br>2. 会带来一些便利，因为它自动识别相同名称的列并进行连接，但也可能存在一些潜在的问题。如果表中有多个列具有相同的名称，这可能会导致意外的连接行为，因为所有同名列都会被用作连接条件<br>inner join<br>1.  两个表的NATURAL [LEFT] JOIN被定义为与INNER JOIN语义相同<br>2.  INNER JOIN和，（逗号）在无联合条件下是语义相同的<br>即： 两者都可以对指定的表计算出笛卡儿乘积（也就是说，第一个表中的每一行被联合到第二个表中的每一行）。<br><br>left|right join<br>1. 要使代码可以在数据库内移植，建议您使用LEFT JOIN代替RIGHT JOIN。<br><br><br><br>#---------------------------<br># 如果我们把一系列table_reference条目中的每个逗号都看作相当于一个内部联合，则这是一个稳妥的扩展<br>SELECT * FROM t1 LEFT JOIN (t2, t3, t4) ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)<br>等价于：<br>SELECT * <br>FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4) ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)<br># 方式二<br>  a LEFT JOIN b USING (c1,c2,c3)<br>  ON 是用来指定连接条件的一般方式，<br>  USING 是在两个表具有相同列名的情况下更为简洁的一种写法<br><br>特点<br>1. SQL标准只接受table_reference，而不是圆括号内的一系列条目<br>2. MySQL中，CROSS JOIN从语法上说与INNER JOIN等同（两者可以互相替换。标准SQL中，两者是不等同的。<br>   INNER JOIN与ON子句同时使用，CROSS JOIN以其它方式使用。<br>3. 通常，在只含有内部联合运行的联合表达式中，圆括号可以被忽略。MySQL也支持嵌套的联合<br>4. 通常，您不应对ON部分有任何条件。ON部分用于限定在结果集合中您想要哪些行。但是，您应在WHERE子句中指定这些条件<br><br>注意<br>1. 自然联合和使用USING的联合，包括外部联合变量，依据SQL:2003标准被处理。这些变更时MySQL与标准SQL更加相符。不过，对于有些联合，这些变更会导致不同的输出列<br>2.  NATURAL联合或USING联合的列会与旧版本不同。特别是，不再出现冗余的输出列，用于SELECT *扩展的列的顺序会与以前不同。<br><br><br>旧版本特性<br>1. 在旧版本中，逗号操作符（，）和JOIN均有相同的优先权，所以联合表达式t1, t2 JOIN t3被理解为((t1, t2) JOIN t3)。现在，JOIN有更高的优先权，所以表达式被理解为(t1, (t2 JOIN t3))。这个变更会影响使用ON子句的语句，因为该子句只参阅联合操作数中的列。优先权的变更改变了对什么是操作数的理解。[本变更也适用于INNER JOIN，CROSS JOIN，LEFT JOIN和RIGHT JOIN。]<br>  SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);<br><br>2. SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;<br>在旧版本中，SELECT语句是合法的。现在该语句会运行失败，出现在&#x27;on clause&#x27;中未知列&#x27;i3&#x27;的错误。这是因为i3是t3中的一个表，而t3不是ON子句中的操作数。本语句应进行如下改写：<br>SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);<br><br> <br><br># 待整理<br>旧版本特性<br>3. 一个USING子句可以被改写为一个ON子句。ON子句对比了相应的列。例如，以下两个子句具有相同的语义：<br>     a LEFT JOIN b USING (c1,c2,c3)<br>     a LEFT JOIN b ON a.c1=b.c1 AND a.c2=b.c2 AND a.c3=b.c3<br>现在，这两个子句不再是一样的：<br>a. 在决定哪些行满足联合条件时，两个联合保持语义相同。<br>b. 在决定哪些列显示SELECT *扩展时，两个联合的语义不相同<br># USING联合选择对应列中的合并值，而ON联合选择所有表中的所有列<br>对于前面的USING联合，SELECT *选择这些值：<br><br>o                     COALESCE(a.c1,b.c1), COALESCE(a.c2,b.c2), COALESCE(a.c3,b.c3)<br>对于ON联合，SELECT *选择这些值：<br><br>a.c1, a.c2, a.c3, b.c1, b.c2, b.c3<br>使用内部联合时，COALESCE(a.c1,b.c1)与a.c1或b.c1相同，因为两列将具有相同的值。使用外部联合时（比如LEFT JOIN），两列中有一列可以为NULL。该列将会从结果中被忽略。<br><br><br><br><br></code></pre></td></tr></table></figure><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ...<br>UNION [ALL | DISTINCT]<br>SELECT ...<br>[UNION [ALL | DISTINCT]<br>SELECT ...]<br><br>作用<br>1. 用于把来自许多SELECT语句的结果组合到一个结果集合中。<br><br>所受限制<br>1. SELECT语句的对应位置的被选择的列应具有相同的类型。（例如，被第一个语句选择的第一列应和被其它语句选择的第一列具有相同的类型。）在第一个SELECT语句中被使用的列名称也被用于结果的列名称。<br><br>2. 只有最后一个SELECT语句可以使用INTO OUTFILE<br>3.  HIGH_PRIORITY不能与作为UNION一部分的SELECT语句同时使用。如果您对第一个SELECT指定了HIGH_PRIORITY，则不会起作用。如果您对其它后续的SELECT语句指定了HIGH_PRIORITY，则会产生语法错误。<br>4. 去重问题。<br>a.对UNION不使用关键词ALL，则所有返回的行都是唯一的，如同您已经对整个结果集合使用了DISTINCT。如果您指定了ALL，您会从所有用过的SELECT语句中得到所有匹配的行。<br>b. DISTINCT关键词是一个自选词，不起任何作用，但是根据SQL标准的要求，在语法中允许采用<br>c. 在MySQL中，DISTINCT代表一个共用体的默认工作性质.<br>d. 混用 union all 和 union distinct , 会导致 distinct 会覆盖其左侧的所有 all 配置<br>e. distinct 共用体可以使用 union distinct 明确生成，或者只使用 union 进行隐式生成<br><br>5. 排序和分页<br>a. 想使用ORDER BY或LIMIT子句来对全部UNION结果进行分类或限制，则应对单个地SELECT语句加圆括号，并把ORDER BY或LIMIT放到最后一个的后面。<br>#这种 ORDER BY不能使用包括表名称（也就是，采用tbl_name.col_name格式的名称）列引用。可以在第一个SELECT语句中提供一个列别名，并在ORDER BY中参阅别名，或使用列位置在ORDER BY中参阅列。（首选采用别名，因为不建议使用列位置。）<br>(SELECT a FROM tbl_name WHERE a=10 AND B=1)<br>    UNION<br>    (SELECT a FROM tbl_name WHERE a=11 AND B=2)<br>    ORDER BY a LIMIT 10;<br><br>b. 带 order by 的一列有别名，则ORDER BY子句必须引用别名，而不能引用列名称。以下语句中的第一个语句必须运行，但是第二个会运行失败，出现在&#x27;order clause&#x27;中有未知列&#x27;a&#x27;的错误：<br>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;<br>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;<br><br>c. 为了对单个SELECT使用ORDER BY或LIMIT，应把子句放入圆括号中。圆括号包含了SELECT：<br># 圆括号中用于单个SELECT语句的ORDER BY只有当与LIMIT结合后，才起作用。否则，ORDER BY被优化去除。<br>(SELECT a FROM tbl_name WHERE a=10 AND B=1 ORDER BY a LIMIT 10)<br>    UNION<br>    (SELECT a FROM tbl_name WHERE a=11 AND B=2 ORDER BY a LIMIT 10);<br><br>e  UNION结果集合中的列的类型和长度考虑了被所有SELECT语句恢复的数值<br></code></pre></td></tr></table></figure><h3 id="查询顺序"><a href="#查询顺序" class="headerlink" title="查询顺序"></a>查询顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1, 选出所有的表<br>2, 条件选出所有的数据<br>3， 分组<br>4， 函数计算<br>5. 组内筛选<br>6. 去重排序<br>7. 限制<br><br>FROM<br>&lt;表名&gt; # 笛卡尔积<br>ON<br>&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选<br>JOIN &lt;join, left join, right join...&gt; <br>&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中<br>WHERE<br>&lt;where条件&gt; # 对上述虚表进行筛选<br>GROUP BY<br>&lt;分组条件&gt; # 分组<br>&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的<br>HAVING<br>&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选<br>SELECT<br>&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外<br>DISTINCT<br># 数据除重<br>ORDER BY<br>&lt;排序条件&gt; # 排序<br>LIMIT<br>&lt;行数限制&gt;<br><br></code></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">概念<br>一个语句中嵌套 select ,  <br>案例<br>select * from student where name=(select student_name from subject)<br>特点<br>1. 一个子查询会返回一个标量（单一值）、一个行、一个列或一个表（一行或多行及一列或多列）。这些子查询被称为标量、列、行和表子查询<br><br>使用限制<br>1. 子查询必须要位于圆括号中<br>2. 个子查询的外部语句必须是以下语句之一：SELECT, INSERT, UPDATE, DELETE, SET或DO<br>3. 不能在一个子查询中修改一个表，又在同一个表中选择<br><br><br>优势<br><br></code></pre></td></tr></table></figure><h3 id="标量-单一值-子查询"><a href="#标量-单一值-子查询" class="headerlink" title="标量(单一值)_子查询"></a>标量(单一值)_子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">概述<br>就是子查询只是返回单一值，是一个单一的操作数<br>只要单一列值或文字是合法的，并且您希望子查询具有所有操作数都具有的特性，则您就可以使用子查询。操作数具有的特性包括：一个数据类型、一个长度、一个指示是否可以为NULL的标志等<br><br><br>限制<br>1. 如果一个语句只允许一个文字值，您不能使用子查询。例如，LIMIT要求文字整数自变量，LOAD DATA要求一个文字字符串文件名。您不能使用子查询来提供这些值。<br><br>重要<br>1. 不要忘记子查询的圆括号<br># 一个标量子查询可以为一个表达式的一部分。不要忘记圆括号。即使是子查询是一个为函数提供自变量的操作数时，也不要忘记圆括号<br>SELECT UPPER((SELECT s1 FROM t1)) FROM t2;<br></code></pre></td></tr></table></figure><h3 id="列-子查询"><a href="#列-子查询" class="headerlink" title="列_子查询"></a>列_子查询</h3><h3 id="行-子查询"><a href="#行-子查询" class="headerlink" title="行_子查询"></a>行_子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">概述<br>子查询返回的是一行的数值<br><br>案例<br># 表达式（1，2）和ROW（1，2）有时被称为行构造符。两者是等同的，在其它的语境中，也是合法的<br>SELECT * FROM t1 WHERE (1,2) = (SELECT column1, column2 FROM t2);<br>SELECT * FROM t1 WHERE ROW(1,2) = (SELECT column1, column2 FROM t2);<br><br><br>行构造符号<br>用途<br>通常用于与对能返回两个或两个以上列的子查询进行比较<br>SELECT column1,column2,column3<br>    FROM t1<br>    WHERE (column1,column2,column3) IN<br>    (SELECT column1,column2,column3 FROM t2);<br><br></code></pre></td></tr></table></figure><h3 id="表-子查询"><a href="#表-子查询" class="headerlink" title="表_子查询"></a>表_子查询</h3><h3 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h3><h4 id="比较语句中使用子查询"><a href="#比较语句中使用子查询" class="headerlink" title="比较语句中使用子查询"></a>比较语句中使用子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1 FROM t1 WHERE column1 = (SELECT MAX(column2) FROM t2);<br><br>可以使用的操作符<br>=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;<br><br>注意<br>1. 有时， 子查询的合法位置只能在比较式的右侧，您可以发现，在有些旧的DBMSs中仍保持这一点。<br>2. 对于采用这些操作符之一进行的比较，子查询必须返回一个标量。有一个例外，那就是＝可以和行子查询同时使用【必须在标量中使用】<br></code></pre></td></tr></table></figure><h4 id="any-in-some-中使用"><a href="#any-in-some-中使用" class="headerlink" title="any, in some 中使用"></a>any, in some 中使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">operand comparison_operator ANY (subquery)<br>operand IN (subquery)<br>operand comparison_operator SOME (subquery)<br><br><br><br><br># ANY关键词必须后面接一个比较操作符<br># 对于在子查询返回的列中的任一数值，如果比较结果为TRUE的话，则返回TRUE<br>SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);<br><br># in 是 any 的别名<br># not in 不是 &lt;&gt;any 的别名， 而是 &lt;&gt;all 的别名<br>SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);<br>SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);<br><br># some 是 any 的别名<br>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY  (SELECT s1 FROM t2);<br>SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);<br><br><br></code></pre></td></tr></table></figure><h4 id="all-子查询"><a href="#all-子查询" class="headerlink" title="all 子查询"></a>all 子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 词语ALL必须接在一个比较操作符的后面。ALL的意思是“对于子查询返回的列中的所有值，如果比较结果为TRUE，则返回TRUE。”<br># 通常，包含NULL值的表和空表为“边缘情况”。当编写子查询代码时，都要考虑您是否把这两种可能性计算在内。<br>SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);<br><br><br># NOT IN是&lt;&gt; ALL的别名。因此，以下两个语句是相同的：<br>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);<br>SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);<br><br></code></pre></td></tr></table></figure><h4 id="not-exists"><a href="#not-exists" class="headerlink" title="[not] exists"></a>[not] exists</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">执行逻辑<br># EXISTS 的作用是检查子查询是否有结果，而不是返回子查询的数据<br>EXISTS 子查询在执行时不会返回任何具体的数据，它只会返回一个布尔值（True 或者 False）。<br>a. 如果子查询中的条件成立（即子查询返回至少一行结果），EXISTS 就会返回 True，然后外部查询会选择符合这个条件的 t1 表中的数据。<br>b. 如果子查询没有结果（即返回空），EXISTS 就会返回 False，外部查询就不会选择任何 t1 表中的数据。<br>SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);<br><br><br># 1. 从 stores 中查询出所有的的 store_type<br># 2. 将查询的 store_type 传入到子查询中，然后执行子查询<br># 3. exists 判断子查询是否为空<br>SELECT DISTINCT store_type FROM stores<br>WHERE EXISTS (SELECT * FROM cities_stores WHERE cities_stores.store_type = stores.store_type);<br><br><br></code></pre></td></tr></table></figure><h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">相关联的子查询是一个包含对表的引用的子查询。该表也显示在外部查询中。例如：<br># 即使子查询的FROM子句不提及表t1，该子查询也会包含一个对t1中一列的引用。所以，MySQL看上去位于子查询的外部，并在外部查询中查找t1<br>SELECT * FROM t1 WHERE column1 = ANY<br>(SELECT column1 FROM t2 WHERE t2.column2 = t1.column2);<br><br></code></pre></td></tr></table></figure><h4 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FROM (subquery) [AS] name ...<br>1. [AS] name子句是强制性的，因为FROM子句中的每个表必须有一个名称。在子查询选择列表中的任何列都必须有唯一的名称<br>2. FROM子句中的子查询可以返回标量、列、行或表。FROM子句中的子查询不能为有关联的子查询。即使对EXPLAIN语句（即建立临时导出表），FROM子句中的子查询也会被执行。这是因为在优化过程中，上一级的查询需要有关所有表的信息<br><br>实例<br>SELECT sb1,sb2,sb3<br>FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb<br>WHERE sb1 &gt; 1;<br><br></code></pre></td></tr></table></figure><h2 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入 - insert"></a>插入 - insert</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># values 插入<br>INSERT <br>    [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] # 它们影响插入数据的优先级和行为。<br>    [INTO] tbl_name [(col_name,...)]<br>    VALUES (&#123;expr | DEFAULT&#125;,...),(...),...  # 插入的各个值<br>    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]<br>    <br># set 插入    <br>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]<br>    [INTO] tbl_name<br>    SET col_name=&#123;expr | DEFAULT&#125;, ...<br>    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]<br>或：<br><br># select 插入: 一个或多个表中向一个表中插入多个行<br>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]<br>    [INTO] tbl_name [(col_name,...)]<br>    SELECT ...<br>    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]<br><br>-- ------------------------------------------------------------------------------------s<br><br>sql 语句执行<br>    low_priority： 如果表被锁定，则指示MySQL在低负载时执行INSERT。<br>    high_priority: 告诉MySQL在后台执行INSERT，这在需要处理大量插入请求时很有用。<br>    delayed: 在表锁定时强制优先处理INSERT语句。<br>duplicate<br>1. 当插入行违反唯一性约束（例如，插入重复键）时执行更新操作。如果出现重复键的情况，这些列将会被更新为新的值。<br>在尝试插入一行数据时，如果有重复键（例如，唯一索引或主键），则更新该行数据而不是插入新行，以避免重复。<br>2. 只要您不使用SELECT部分中的GROUP BY，您就可以引用在其它表中的列。有一个副作用是，您必须使值部分中的非唯一列的名称符合要求。<br>3. 可以使用REPLACE替代INSERT，来覆盖旧行。对于包含唯一关键字值，并复制了旧行的新行，在进行处理时，REPLACE可以作为INSERT IGNORE的同类子句：新行被用于替换旧行，而不是被丢弃。<br><br><br></code></pre></td></tr></table></figure><h4 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># values<br>INSERT INTO users (username, email, birthdate, is_active)<br>VALUES<br>    (&#x27;test1&#x27;, &#x27;test1@runoob.com&#x27;, &#x27;1985-07-10&#x27;, true),<br>    (&#x27;test2&#x27;, &#x27;test2@runoob.com&#x27;, &#x27;1988-11-25&#x27;, false),<br>    (&#x27;test3&#x27;, &#x27;test3@runoob.com&#x27;, &#x27;1993-05-03&#x27;, true);<br>    <br>#set <br><br># select <br><br><br>INSERT INTO pet VALUES (&#x27;Puffball&#x27;,&#x27;Diane&#x27;,&#x27;hamster&#x27;,&#x27;f&#x27;,&#x27;1999-03-30&#x27;,NULL);<br>  <br></code></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT DELAYED语法<br>INSERT DELAYED ...<br>用于INSERT语句的DELAYED选项是MySQL相对于标准SQL的扩展。如果您的客户端不能等待INSERT完成，则这个选项是非常有用的。当您使用MySQL进行日志编写时，这是非常常见的问题。您也可以定期运行SELECT和UPDATE语句，这些语句花费的时间较长。<br><br><br></code></pre></td></tr></table></figure><h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#单表语法：<br>DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name<br>    [WHERE where_definition]<br>    [ORDER BY ...]<br>    [LIMIT row_count]<br><br>#多表语法：<br>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]<br>    tbl_name[.*] [, tbl_name[.*] ...]<br>    FROM table_references<br>    [WHERE where_definition]<br>或：<br>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]<br>    FROM tbl_name[.*] [, tbl_name[.*] ...]<br>    USING table_references<br>    [WHERE where_definition]<br><br>参数<br>delete ： sql的关键字，表示执行删除操作<br>low_priority： 指定删除任务的优先级较低，DELETE的执行被延迟，直到没有其它客户端读取本表时再执行。<br>quick： 用于在MySQL中，快速删除数据而不会扫描整个表格。在其他数据库中可能没有这个选项。<br>where where_definition: 用于指定删除哪些行。【如果省略这个条件，将删除表中所有数据。】<br>ignore 执行删除时忽略任何错误，继续执行删除操作。<br>order by 指定删除数据时的排序规则。<br>limit  指定要删除的行数的限制。如果不指定，则删除符合条件的所有行。<br>using|on 允许使用表之间的连接关系来删除数据。table_references 是一个连接表（JOIN）的列表，用于指定如何连接表格以进行删除操作。<br>table_references 参看 select.join<br></code></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>限制<br>1. 您不能在一个多表DELETE语句中使用ORDER BY或LIMIT。<br>2. 本语法允许在名称后面加.*，以便与Access相容。<br>3. 如果您使用的多表DELETE语句包括InnoDB表，并且这些表受外键的限制，则MySQL优化程序会对表进行处理，改变原来的从属关系。在这种情况下，该语句出现错误并返回到前面的步骤。要避免此错误，您应该从单一表中删除，并依靠InnoDB提供的ON DELETE功能，对其它表进行相应的修改。<br>4. 当引用表名称时，您必须使用别名（如果已给定）：<br># 下面的例子，没有给别名，就不需要<br>DELETE t1 FROM test AS t1, test2 WHERE ...<br>5. 跨数据库进行多表删除的时候，引用表是不能使用别名<br>DELETE test1.tmp1, test2.tmp2 FROM test1.tmp1, test2.tmp2 WHERE ...<br>6. 目前，您不能从一个表中删除，同时又在子查询中从同一个表中选择。<br><br><br><br>案例<br># 当搜索待删除的行时，这些语句使用所有三个表，但是只从表t1和表t2中删除对应的行。<br>DELETE t1, t2 FROM t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;<br>DELETE FROM t1, t2 USING t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;<br><br></code></pre></td></tr></table></figure><h4 id="demo-2"><a href="#demo-2" class="headerlink" title="demo"></a>demo</h4><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># MySQL中采用的一个Oracle SQL扩展<br>TRUNCATE [TABLE] tbl_name<br><br>1. 清空一个表，逻辑上说，该语句与用于删除所有行的DELETE语句等同，但是在有些情况下，两者在使用上有所不同<br>a, truncate 会取消并重新创建表，这比一行一行的删除行要快很多<br>b, truncate 不能保证对事务是安全的；在进行事务处理和表锁定的过程中尝试进行删减，会发生错误。<br>c, truncate  被删除的行的数目没有被返回。<br>d, 只要表定义文件tbl_name.frm是合法的，则可以使用TRUNCATE TABLE把表重新创建为一个空表，即使数据或索引文件已经被破坏<br>e, 表管理程序不记得最后被使用的AUTO_INCREMENT值，但是会从头开始计数。即使对于MyISAM和InnoDB也是如此。MyISAM和InnoDB通常不再次使用序列值<br>f, 当被用于带分区的表时，TRUNCATE TABLE会保留分区；即，数据和索引文件被取消并重新创建，同时分区定义（.par）文件不受影响。<br><br></code></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Single-table语法：<br>UPDATE [LOW_PRIORITY] [IGNORE] tbl_name<br>    SET col_name1=expr1 [, col_name2=expr2 ...]<br>    [WHERE where_definition]<br>    [ORDER BY ...]<br>    [LIMIT row_count]<br>    <br>    <br>Multiple-table语法：<br>UPDATE [LOW_PRIORITY] [IGNORE] table_references<br>    SET col_name1=expr1 [, col_name2=expr2 ...]<br>    [WHERE where_definition]<br>    <br>UPDATE语法可以用新值更新原有表行中的各列。<br>LOW_PRIORITY： <br>如果使用了， 则UPDATE的执行被延迟了，直到没有其它的客户端从表中读取为止。<br>IGNORE<br>在更新过程中出现错误，更新语句也不会中断。【如果出现了重复关键字冲突，则这些行不会被更新。如果列被更新后，新值会导致数据转化错误，则这些行被更新为最接近的合法的值。】<br>SET<br>子句指示要修改哪些列和要给予哪些值。<br>WHERE<br>子句指定应更新哪些行。如果没有WHERE子句，则更新所有的行。<br>ORDER BY<br>1. 按照被指定的顺序对行进行更新。先排序然后进行更新<br>2. 不能用于multiple-table UPDATE<br>limit<br>1. 用于给定一个限值，限制可以被更新的行的数目。<br>2. 只要发现可以满足WHERE子句的row_count行，则该语句中止，不论这些行是否被改变。<br>3. 不能用于multiple-table UPDATE<br> <br><br>    <br>=======================<br>1. UPDATE赋值被从左到右评估。 <br>UPDATE persondata SET age=age*2, age=age+1 # 语句对年龄列加倍，然后再进行增加：<br><br>2. 把一列设置为其当前含有的值，则MySQL会注意到这一点，但不会更新。<br>3. not null 列更新为 null。则该列被设置到与列类型对应的默认值，并且累加警告数。对于数字类型，默认值为0；对于字符串类型，默认值为空字符串(&#x27;&#x27;)；对于日期和时间类型，默认值为“zero”值<br>4. UPDATE会返回实际被改变的行的数目。Mysql_info() C API函数可以返回被匹配和被更新的行的数目，以及在UPDATE过程中产生的警告的数量。<br>5. multiple-table UPDATE语句可以使用在SELECT语句中允许的任何类型的联合，比如LEFT JOIN。<br><br><br><br><br></code></pre></td></tr></table></figure><h4 id="demo-3"><a href="#demo-3" class="headerlink" title="demo"></a>demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 多表联合更新<br>UPDATE items,month <br>SET items.price=month.price<br>WHERE items.id=month.id;<br><br><br><br></code></pre></td></tr></table></figure><h4 id="待整理-1"><a href="#待整理-1" class="headerlink" title="待整理"></a>待整理</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas">在一个被更改的multiple-<span class="hljs-keyword">table</span> <span class="hljs-keyword">UPDATE</span>中，有些列被引用。您只需要这些列的<span class="hljs-keyword">UPDATE</span>权限。有些列被读取了，但是没被修改。您只需要这些列的<span class="hljs-keyword">SELECT</span>权限。<br><br>如果您使用的multiple-<span class="hljs-keyword">table</span> <span class="hljs-keyword">UPDATE</span>语句中包含带有外键限制的InnoDB表，则MySQL优化符处理表的顺序可能与上下层级关系的顺序不同。在此情况下，语句无效并被 回滚。同时，更新一个单一表，并且依靠<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span>功能。该功能由InnoDB提供，用于对其它表进行相应的修改。请参见15.2.6.4节，“<span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>约束”。<br><br>目前，您不能在一个子查询中更新一个表，同时从同一个表中选择。<br><br></code></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata">如果你需要重复运行查询(比如说，每天或每周)，可以把它编成一个脚本，则每次执行时不必重新键入。 <br>可以通过拷贝并编辑脚本文件从类似的现有的查询生成一个新查询。 <br>当你正在开发查询时，批模式也是很有用的，特别对多行命令或多语句命令序列。如果你犯了一个错误，你不必重新输入所有内容，只需要编辑脚本来改正错误，然后告诉mysql再次执行脚本。 <br>如果你有一个产生多个输出的查询，你可以通过一个分页器而不是盯着它翻屏到屏幕的顶端来运行输出： <br>·                <span class="hljs-keyword">shell</span>&gt; mysql &lt; batch-<span class="hljs-keyword">file</span> | <span class="hljs-keyword">more</span><br>你可以捕捉文件中的输出以便进行进一步的处理： <br>·                <span class="hljs-keyword">shell</span>&gt; mysql &lt; batch-<span class="hljs-keyword">file</span> &gt; mysql.<span class="hljs-keyword">out</span><br>你可以将脚本分发给另外的人，以便他们也能运行命令。 <br>某些情况不允许交互地使用，例如, 当你从一个cron任务中运行查询时。在这种情况下，你必须使用批模式。<br></code></pre></td></tr></table></figure><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOAD DATA <span class="hljs-keyword">LOCAL</span> INFILE <span class="hljs-string">&#x27;/path/pet.txt&#x27;</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> pet;<br>你愿意，你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符<br><br><br><br>mysql <span class="hljs-operator">-</span>h host <span class="hljs-operator">-</span>u <span class="hljs-keyword">user</span> <span class="hljs-operator">-</span>ppassword <span class="hljs-operator">&lt;</span> xx.sql<br>参数：<br><span class="hljs-comment">-- force  语句出现错误的时候，仍旧相执行脚本</span><br><br></code></pre></td></tr></table></figure><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> source xxx.sql<br><br>等价于<br>mysql<span class="hljs-operator">&gt;</span> \. filename<br></code></pre></td></tr></table></figure><h1 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h1><h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h2><ul><li><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE animals (<br>     id MEDIUMINT NOT NULL AUTO_INCREMENT,<br>     name CHAR(30) NOT NULL,<br>     PRIMARY KEY (id)<br> );<br> <br>INSERT INTO animals (name) VALUES <br>    (&#x27;dog&#x27;),(&#x27;cat&#x27;),(&#x27;penguin&#x27;),<br>    (&#x27;lax&#x27;),(&#x27;whale&#x27;),(&#x27;ostrich&#x27;);<br><br>SELECT * FROM animals;<br>将返回：<br><br>+----+---------+<br>| id | name    |<br>+----+---------+<br>|  1 | dog     |<br>|  2 | cat     |<br>|  3 | penguin |<br>|  4 | lax     |<br>|  5 | whale   |<br>|  6 | ostrich |<br>+----+---------+<br><br>1. 获取自增的最新值。【mysql函数： last_insert_id()】【c函数：mysql_insert_id()】来查询最新的AUTO_INCREMENT值。<br>    a. 这些函数与具体连接有关，因此其返回值不会被其它执行插入功能的连接影响。<br>    b. 对于多行插入,从插入的第一行实际返回AUTO_INCREMENT关键字。在复制设置中，通过该函数可以在其它服务器上正确复制多行插入。<br><br><br><br></code></pre></td></tr></table></figure></li><li><p>MyISAM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 下面的不太懂？？？？<br>[1] 可以在第二栏指定AUTO_INCREMENT以及多列索引。此时，AUTO_INCREMENT列生成的值的计算方法为：MAX(auto_increment_column) + 1 WHERE prefix=given-prefix。如果想要将数据放入到排序的组中可以使用该方法。<br>[2]在这种情况下（AUTO_INCREMENT列是多列索引的一部分），如果你在任何组中删除有最大AUTO_INCREMENT值的行，将会重新用到AUTO_INCREMENT值。对于MyISAM表也如此,对于该表一般不重复使用AUTO_INCREMENT值。<br>[3]如果AUTO_INCREMENT列是多索引的一部分，MySQL将使用该索引生成以AUTO_INCREMENT列开始的序列值。。例如，如果animals表含有索引PRIMARY KEY (grp, id)和INDEX(id)，MySQL生成序列值时将忽略PRIMARY KEY。结果是，该表包含一个单个的序列，而不是符合grp值的序列<br>[4]要想以AUTO_INCREMENT值开始而不是1，你可以通过CREATE TABLE或ALTER TABLE来设置该值，如下所示:<br>ALTER TABLE tbl AUTO_INCREMENT = 100;<br><br><br>CREATE TABLE animals (<br>    grp ENUM(&#x27;fish&#x27;,&#x27;mammal&#x27;,&#x27;bird&#x27;) NOT NULL,<br>    id MEDIUMINT NOT NULL AUTO_INCREMENT,<br>    name CHAR(30) NOT NULL,<br>    PRIMARY KEY (grp,id)<br>);<br> <br>INSERT INTO animals (grp,name) VALUES <br>    (&#x27;mammal&#x27;,&#x27;dog&#x27;),(&#x27;mammal&#x27;,&#x27;cat&#x27;),<br>    (&#x27;bird&#x27;,&#x27;penguin&#x27;),(&#x27;fish&#x27;,&#x27;lax&#x27;),(&#x27;mammal&#x27;,&#x27;whale&#x27;),<br>    (&#x27;bird&#x27;,&#x27;ostrich&#x27;);<br> <br>SELECT * FROM animals ORDER BY grp,id;<br>将返回：<br><br>+--------+----+---------+<br>| grp    | id | name    |<br>+--------+----+---------+<br>| fish   |  1 | lax     |<br>| mammal |  1 | dog     |<br>| mammal |  2 | cat     |<br>| mammal |  3 | whale   |<br>| bird   |  1 | penguin |<br>| bird   |  2 | ostrich |<br>+--------+----+---------+<br><br></code></pre></td></tr></table></figure></li><li><p>BDB</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">同 MyISAM<br></code></pre></td></tr></table></figure></li><li><p>注意</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">a. 因为AUTO_INCREMENT列必须编制索引。<br>若设置为主键则需要定义为NOT NULL，主键列不能为NULL<br>当向该列插入一个 null 值(建议)或者0时，此列被设置为下一个序列的值，通常情况是 value+1, 此处 value 是当前表中的列的最大值。<br>b. auto_increment 序列是从 1 开始的，该列是一种整数烈性。 注意 1.0 不是整数<br>b. 对于MyISAM表，您可以在ALTER TABLE之前执行SET INSERT_ID=value来设置第一个序号，也可以使用AUTO_INCREMENT=value表选项来设置<br>c. 如果值大于AUTO_INCREMENT列中的最大值，则您可以使用用于InnoDB表的ALTER TALBE...AUTO_INCREMENT=value表选项，来为新行设置序号。如果值小于列中当前的最大值，不会出现错误信息，当前的序列值也不改变。<br>d. 使用MyISAM表时，如果您不更改AUTO_INCREMENT列，则序列号不受影响。如果您取消一个AUTO_INCREMENT列，然后添加另一个AUTO_INCREMENT列，则序号重新排列，从1开始。<br> <br></code></pre></td></tr></table></figure><h1 id="语句控制"><a href="#语句控制" class="headerlink" title="语句控制"></a>语句控制</h1><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1.</span> 有匹配的返回配置的 <span class="hljs-keyword">when</span> 后面的 <span class="hljs-keyword">then</span> 的 <span class="hljs-keyword">result</span> ,如果 没有匹配的返回 <span class="hljs-keyword">else</span> 中的内容， 如果没有 <span class="hljs-keyword">else</span> 则返回 <span class="hljs-keyword">null</span> <br><span class="hljs-number">2.</span> <span class="hljs-keyword">CASE</span>表达式的默认返回值类型是任何返回值的相容集合类型，但具体情况视其所在语境而定<br>   如果用在字符串语境中，则返回结果味字符串。如果用在数字语境中，则返回结果为十进制值、实值或整数值<br># <br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">value</span> <br><span class="hljs-keyword">WHEN</span> [compare<span class="hljs-operator">-</span><span class="hljs-keyword">value</span>]  <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">result</span><br>    [<span class="hljs-keyword">WHEN</span> [compare<span class="hljs-operator">-</span><span class="hljs-keyword">value</span>] <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">result</span> ...] <br>    [<span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">result</span>]<br>    <span class="hljs-keyword">END</span> <br><br># <br><span class="hljs-keyword">CASE</span> <br><span class="hljs-keyword">WHEN</span> [<span class="hljs-keyword">condition</span>] <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">result</span> <br>[<span class="hljs-keyword">WHEN</span> [<span class="hljs-keyword">condition</span>] <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">result</span> ...] <br>[<span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">result</span>] <br><span class="hljs-keyword">END</span> <br><br><br><br>案例<br><span class="hljs-keyword">select</span><br><span class="hljs-keyword">case</span> <br><span class="hljs-keyword">when</span> <span class="hljs-built_in">MAX</span>( gxsj ) <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>  <span class="hljs-keyword">then</span> <span class="hljs-number">1949</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">MAX</span>( gxsj )<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">AS</span> maxtime<br><span class="hljs-keyword">from</span> ODS_WUSUO.WSZB<br><br><br></code></pre></td></tr></table></figure><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">语法<br>IF(expr1,expr2,expr3) <br>expr1 是TRU <br>expr1 是<br>expr1<br>是 TRUE :   (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL) ：返回值为 expr2<br>         是 FALSE                                   ：返回值为 expr3<br>         是 整数： 则为 true, 其他的则需要使用比较运算符进行比较<br>         <br>默认返回值<br>    expr2 或者 expr3 返回值有一个是<br>     <br><br><br><br>案例<br>mysql&gt; SELECT IF(1&gt;2,2,3);<br>-&gt; 3<br><br>mysql&gt; SELECT IF(0.1,1,0);<br>-&gt; 0  -- 原因是 0.1 被转化为整数值，从而引起一个对 IF(0)的检验<br><br><br></code></pre></td></tr></table></figure><ul><li>默认返回值类型</li></ul><table><thead><tr><th><strong>表达式</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td><em>expr2</em> 或<em>expr3</em>  返回值为一个字符串。</td><td>字符串</td></tr><tr><td><em>expr2</em> 或<em>expr3</em>  返回值为一个浮点值。</td><td>浮点</td></tr><tr><td><em>expr2</em> 或  <em>expr3</em> 返回值为一个整数。</td><td>整数</td></tr><tr><td><em>expr2</em> 和<em>expr3</em>  都是字符串，且其中任何一个字符串区分大小写</td><td>区分大小写</td></tr></tbody></table><h2 id="null-if"><a href="#null-if" class="headerlink" title="null-if"></a>null-if</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">IFNULL(expr1,expr2)<br>expr1 ≠ <span class="hljs-keyword">NULL</span>  返回 expr1<br>expr1 <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span>  返回 expr2<br><br><span class="hljs-built_in">NULLIF</span>(expr1,expr2) <br>expr1 <span class="hljs-operator">=</span> expr2   返回 <span class="hljs-keyword">NULL</span><br>expr1 ≠ expr2   返回  expr1<br></code></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 操作符的优先级和 mysql 的模式有关，但是 () 最高<br>:=<br><br>||, OR, XOR<br><br>&amp;&amp;, AND<br><br>NOT<br><br>BETWEEN, CASE, WHEN, THEN, ELSE<br><br>=, &lt;=&gt;, &gt;=, &gt;, &lt;=, &lt;, &lt;&gt;, !=, IS, LIKE, REGEXP, IN<br><br>|<br><br>&amp;<br><br>&lt;&lt;, &gt;&gt;<br><br>-, +<br><br>*, /, DIV, %, MOD<br><br>^<br><br>- (一元减号), ~ (一元比特反转)<br><br>!<br><br>BINARY, COLLATE<br><br></code></pre></td></tr></table></figure><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-number">0</span>或 <span class="hljs-built_in">NULL</span>意味着假而其它值意味着真。布尔运算的默认真值是<span class="hljs-number">1</span><br><br>在<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>中，<br><span class="hljs-number">1.</span> 两个<span class="hljs-built_in">NULL</span>值视为相同。<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br><span class="hljs-number">1.</span> 如果运行 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-params">...</span> ASC，则<span class="hljs-built_in">NULL</span>值出现在最前面，<br><span class="hljs-number">2.</span> 若运行<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-params">...</span> DESC，则<span class="hljs-built_in">NULL</span>值出现在最后面。<br><br></code></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">“_” 匹配任何单个字符，<br>“<span class="hljs-operator">%</span>” 匹配任意数目字符(包括零字符)。<br><br>注意：<br><span class="hljs-number">1.</span> 注意使用<span class="hljs-keyword">SQL</span>模式时，不能使用<span class="hljs-operator">=</span>或<span class="hljs-operator">!=</span>；而应使用<span class="hljs-keyword">LIKE</span>或<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span>比较操作符。<br><br></code></pre></td></tr></table></figure><h2 id="四则"><a href="#四则" class="headerlink" title="四则"></a>四则</h2><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th>a</th><th>b</th><th>操作符</th></tr></thead><tbody><tr><td>有 null</td><td>有 null</td><td>null-safe 等算符 &lt;&#x3D;&gt;   【正常比较: 两个操作码均为NULL时，其所得值为1而不为NULL，而当一个操作码为NULL时，其所得值为0而不为NULL。】<br />其他运算符   【结果均为 null】</td></tr><tr><td>字符串</td><td>字符串</td><td>按照字符串比较，字符串比较不区分大小写，并使用现有字符集</td></tr><tr><td>整数</td><td>整数</td><td>按照整数比较</td></tr><tr><td>数字</td><td>字符串</td><td>1. MySQL 不能使用列中的索引进行快速查找，原因是许多不同的字符串都可被转换为数值 1: ‘1’、 ‘ 1’、 ‘1a’<br /></td></tr><tr><td></td><td></td><td></td></tr><tr><td>TIMESTAMP 或 DATETIME 列</td><td>常数</td><td>1. 行比较前将常数转为 timestamp。这样做的目的是为了使ODBC的进行更加顺利<br />2. 注意，这不适合IN()中的参数!为了更加可靠，在进行对比时通常使用完整的  datetime&#x2F;date&#x2F;time字符串。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><ul><li>在其它情况下，参数作为浮点数进行比较</li></ul><h2 id="算数计算符"><a href="#算数计算符" class="headerlink" title="算数计算符"></a>算数计算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-, +<br><br>*, /, DIV(取商), %, MOD(取余数)<br><br>^<br><br>- (一元减号, 负号), ~ (一元比特反转)<br><br><br><br><br>1, -、 +和 *而言, 若两个参数均为正数，则其计算结果的精确度为 BIGINT (64比特)，若其中一个参数为无符号整数， 而其它参数也是整数, 则结果为无符号整数<br>2, <br></code></pre></td></tr></table></figure><h2 id="匹配符"><a href="#匹配符" class="headerlink" title="匹配符"></a>匹配符</h2><h3 id=""><a href="#" class="headerlink" title="&lt;&#x3D;&gt;"></a>&lt;&#x3D;&gt;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">NULL-safe equal.<br>    mysql&gt; SELECT 1 &lt;=&gt; 1, NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULL   <br>    mysql&gt; 1, 1, 0<br>    <br>is<br>mysql&gt; SELECT 1 IS TRUE, 0 IS FALSE, NULL IS UNKNOWN;<br>mysql&gt; 1, 1, 1<br>mysql&gt; SELECT 1 IS NOT UNKNOWN, 0 IS NOT UNKNOWN, NULL IS NOT UNKNOWN;<br>mysql&gt; 1, 1, 0<br><br><br><br></code></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql">expr LIKE pat [ESCAPE &#x27;escape-char&#x27;] <br>expr NOT LIKE pat [ESCAPE &#x27;escape-char&#x27;] <br>escape : 执行转义字符<br><br>like 使用的两种通配符<br>%匹配任何数目的字符，甚至包括零字符， 即 字符格式 &gt;= 0<br>_ 只能匹配一种字符, 字符个数 =1<br> <br> <br>特点：<br>1. 返回1 (TRUE) 或 0 (FALSE)。 若 expr 或 pat 中任何一个为 NULL,则结果为 NULL。<br>2. like 区分大小写<br>2.  由于 MySQL在字符串中使用 C转义语法(例如, 用‘\n’代表一个换行字符)，在LIKE字符串中，必须将用到的‘\’双写。例如， 若要查找 ‘\n’, 必须将其写成 ‘\\n’。而若要查找 ‘\’, 则必须将其写成 it as ‘\\\\’;原因是反斜线符号会被语法分析程序剥离一次，在进行模式匹配时，又会被剥离一次，最后会剩下一个反斜线符号接受匹配。 <br><br> <br> <br>-- 要指定一个不同的转义字符,可使用ESCAPE语句：如果没有指定 ESCAPE字符, 则假设为‘\’<br>mysql&gt; SELECT &#x27;David_&#x27; LIKE &#x27;David|_&#x27; ESCAPE &#x27;|&#x27;;<br> -&gt; 1<br><br><br>-- 在MySQL中, LIKE 允许出现在数字表达式中。 (这是标准SQL LIKE 的延伸）。 <br>mysql&gt; SELECT 10 LIKE &#x27;1%&#x27;;<br>-&gt; 1<br><br>在确定字符类型时，REGEXP 和 RLIKE 使用当前字符集 (默认为cp1252 Latin1 )。 警告：这些操作符不支持多字节字元。<br><br><br></code></pre></td></tr></table></figure><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">expr</span> REGEXP pat <span class="hljs-keyword">expr</span> RLIKE pat <br><br><span class="hljs-number">1.</span> 若<span class="hljs-keyword">expr</span> 匹配 pat，则返回 <span class="hljs-number">1</span>; 否则返回<span class="hljs-number">0</span>。若 <span class="hljs-keyword">expr</span> 或 pat 任意一个为 <span class="hljs-built_in">NULL</span>, 则结果为 <span class="hljs-built_in">NULL</span>。 RLIKE 是REGEXP的同义词, 作用是为mSQL 提供兼容性。<br><span class="hljs-number">2.</span> REGEXP 不区分大小写, 除非将其同二进制字符串同时使用<br><br>详情见 mysql 正则表达<br></code></pre></td></tr></table></figure><h2 id="范围比较"><a href="#范围比较" class="headerlink" title="范围比较"></a>范围比较</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">between ... and ...<br><br>比较规则<br>    1. 若所有参数都是同一类型，则上述关系相当于表达式   (min &lt;= expr AND expr &lt;= max)。<br>    2. 不同种类型进行比较， 则进行类型转换<br>    <br>返回值<br>expr BETWEEN min AND max ：<br>假如expr大于或等于 min 且expr 小于或等于max, 则BETWEEN 的返回值为1,或是0<br><br><br>in<br></code></pre></td></tr></table></figure><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">介绍<br>所有逻辑 操作符的求值所得结果均为 <span class="hljs-literal">TRUE</span>、<span class="hljs-literal">FALSE</span>或 <span class="hljs-keyword">NULL</span> (<span class="hljs-literal">UNKNOWN</span>)<br>体现为  <span class="hljs-number">1</span> (<span class="hljs-literal">TRUE</span>)、 <span class="hljs-number">0</span> (<span class="hljs-literal">FALSE</span>)和 <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><h3 id="not-和-！"><a href="#not-和-！" class="headerlink" title="not 和 ！"></a>not 和 ！</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">使用特例<br>当操作数为<span class="hljs-number">0</span> 时，所得值为 <span class="hljs-number">1</span> ；<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-number">0</span>;<br><span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br> <br>当操作数为非零值时，所得值为  <span class="hljs-number">0</span> ，<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-number">10</span>;<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><br><br>当操作数为<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>时，所得的返回值为 <span class="hljs-keyword">NULL</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">NULL</span><br><br></code></pre></td></tr></table></figure><h3 id="and-和"><a href="#and-和" class="headerlink" title="and 和 &amp;&amp;"></a>and 和 &amp;&amp;</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">当所有操作数均为非零值、并且不为<span class="hljs-keyword">NULL</span>时，计算所得结果为  <span class="hljs-number">1</span> ，<br>当一个或多个操作数为<span class="hljs-number">0</span> 时，所得结果为 <span class="hljs-number">0</span> ，<br>其余情况返回值为 <span class="hljs-keyword">NULL</span> <br><br><span class="hljs-number">1.</span> 两个操作数<br>真： <span class="hljs-number">1</span> , 非<span class="hljs-number">0</span><br>假： <span class="hljs-number">0</span><br>伪假： <span class="hljs-keyword">null</span> <br>    a.  有假则结果假。 有 <span class="hljs-number">0</span> 结果为 <span class="hljs-number">0</span>， 有 <span class="hljs-keyword">null</span> 结果为 <span class="hljs-keyword">null</span>, 同时<span class="hljs-number">0</span>和<span class="hljs-keyword">null</span> 的为 <span class="hljs-number">0</span><br>案例<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-operator">=</span><span class="hljs-operator">=</span>》 <span class="hljs-keyword">null</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span>  <span class="hljs-number">0</span><br><br><br></code></pre></td></tr></table></figure><h3 id="or-和"><a href="#or-和" class="headerlink" title="or 和 ||"></a>or 和 ||</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1.</span> 两个操作数，有真为真<br>真： <span class="hljs-number">1</span> , 非<span class="hljs-number">0</span><br>假： <span class="hljs-number">0</span><br>伪假： <span class="hljs-keyword">null</span> <br>    a. 有真结果就是 <span class="hljs-number">1</span>, 否则就是 <span class="hljs-number">0</span><br>    b. 有 <span class="hljs-keyword">null</span> 结果就是 <span class="hljs-keyword">null</span><br>    <br>    <br>案例<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">NULL</span>;  <span class="hljs-operator">=</span><span class="hljs-operator">=</span>》  <span class="hljs-keyword">NULL</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">NULL</span>;  <span class="hljs-operator">=</span><span class="hljs-operator">=</span>》 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">作用<br>a XOR b 的计算等同于  (a <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> b)) <span class="hljs-keyword">OR</span> ((<span class="hljs-keyword">NOT</span> a)和 b)。 <br>规律<br>a. <br><br>待总结<br>逻辑XOR。当任意一个操作数为 <span class="hljs-keyword">NULL</span>时，返回值为<span class="hljs-keyword">NULL</span>。对于非   <span class="hljs-keyword">NULL</span> 的操作数，假如一个奇数操作数为非零值，则计算所得结果为  <span class="hljs-number">1</span> ，否则为  <span class="hljs-number">0</span> 。<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> XOR <span class="hljs-number">1</span>;<br>        <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> XOR <span class="hljs-number">0</span>;<br>        <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> XOR <span class="hljs-keyword">NULL</span>;<br>        <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">NULL</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> XOR <span class="hljs-number">1</span> XOR <span class="hljs-number">1</span>;<br>        <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br><br><br><br></code></pre></td></tr></table></figure><h1 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">子程序： 就是值存储过程和函数<br>特点：<br>一个子程序要么是一个程序要么是一个函数。使用CALL语句来调用程序，程序只能用输出变量传回值。就像别其它函数调用一样，函数可以被从语句外调用（即通过引用函数名），函数能返回标量值。存储子程序也可以调用其它存储子程序。 <br><br>1. 一个存储子程序或函数与特定的数据库相联系<br>a.  当一个子程序被调用时，一个隐含的USE db_name 被执行（当子程序终止时停止执行）。存储子程序内的USE语句时不允许的<br>b. 你可以使用数据库名限定子程序名。这可以被用来引用一个不在当前数据库中的子程序。比如，要引用一个与test数据库关联的存储程序p或函数f，你可以说CALL test.p()或test.f()。<br>c. 数据库移除的时候，与它关联的所有存储子程序也都被移除<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>存储过程</th><th>函数</th></tr></thead><tbody><tr><td>修改数据库</td><td>可以修改数据库的内容</td><td>是不允许修改数据库的</td></tr><tr><td>调用方式</td><td>不能直接嵌入到查询中，需要通过特定的语法来调用执行</td><td>可以嵌入到SQL语句中直接调用</td></tr><tr><td>返回值</td><td>返回零个或多个结果集</td><td>只能返回单个值</td></tr><tr><td>用途</td><td>更适用于执行一系列的操作、数据处理和任务执行</td><td>通常用于计算并返回单个值。</td></tr></tbody></table><h2 id="暂时不懂"><a href="#暂时不懂" class="headerlink" title="暂时不懂"></a>暂时不懂</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">为进行复制，使用NOW()函数（或它的同义词）或RAND()函数会不必要地使得一个子程序非确定。对NOW()而言，二进制日志包括时间戳并被正确复制。RAND() 只要在一个子程序被内应用一次也会被正确复制。（你可以把子程序执行时间戳和随机数种子认为强制输入，它们在主从上是同样的。） <br><br>当前来讲，DETERMINISTIC特征被接受，但还没有被优化程序所使用。然而如果二进制日志功能被允许了，这个特征影响到MySQL是否会接受子程序定义。请参阅<span class="hljs-number">20.4</span>节，“存储子程序和触发程序的二进制日志功能”。 <br><br>一些特征提供子程序使用数据的内在信息。CONTAINS <span class="hljs-keyword">SQL</span>表示子程序不包含读或写数据的语句。<span class="hljs-keyword">NO</span> <span class="hljs-keyword">SQL</span>表示子程序不包含<span class="hljs-keyword">SQL</span>语句。READS <span class="hljs-keyword">SQL</span> DATA表示子程序包含读数据的语句，但不包含写数据的语句。MODIFIES <span class="hljs-keyword">SQL</span> DATA表示子程序包含写数据的语句。如果这些特征没有明确给定，默认的是CONTAINS <span class="hljs-keyword">SQL</span>。 <br><br><span class="hljs-keyword">SQL</span> <span class="hljs-keyword">SECURITY</span>特征可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是<span class="hljs-keyword">DEFINER</span>。在<span class="hljs-keyword">SQL</span>:<span class="hljs-number">2003</span>中者是一个新特性。创建者或调用者必须由访问子程序关联的数据库的许可。在MySQL <span class="hljs-number">5.1</span>中，必须有<span class="hljs-keyword">EXECUTE</span>权限才能执行子程序。必须拥有这个权限的用户要么是定义者，要么是调用者，这取决于<span class="hljs-keyword">SQL</span> <span class="hljs-keyword">SECURITY</span>特征是如何设置的。 <br><br>MySQL存储sql_mode系统变量设置，这个设置在子程序被创建的时候起作用，MySQL总是强制使用这个设置来执行子程序。 <br><br><span class="hljs-keyword">COMMENT</span>子句是一个MySQL的扩展，它可以被用来描述存储程序。这个信息被<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span>和 <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span>语句来显示。 <br><br>MySQL允许子程序包含DDL语句，如<span class="hljs-keyword">CREATE</span>和<span class="hljs-keyword">DROP</span>。MySQL也允许存储程序（但不是存储函数）包含<span class="hljs-keyword">SQL</span> 交互语句，如<span class="hljs-keyword">COMMIT</span>。存储函数不可以包含那些做明确的和绝对的提交或者做回滚的语。<span class="hljs-keyword">SQL</span>标准不要求对这些语句的支持，<span class="hljs-keyword">SQL</span>标准声明每个DBMS提供商可以决定是否允许支持这些语句。 <br><br>存储子程序不能使用<span class="hljs-keyword">LOAD</span> DATA INFILE。 <br><br>返回结果包的语句不能被用在存储函数种。这包括不使用<span class="hljs-keyword">INTO</span>给变量读取列值的<span class="hljs-keyword">SELECT</span>语句，<span class="hljs-keyword">SHOW</span> 语句，及其它诸如<span class="hljs-keyword">EXPLAIN</span>这样的语句。对于可在函数定义时间被决定要返回一个结果包的语句，发生一个允许从函数错误返回结果包的<span class="hljs-keyword">Not</span>（ER_SP_NO_RETSET_IN_FUNC）。对于只可在运行时决定要返回一个结果包的语句， 发生一个不能在给定上下文错误返回结果包的<span class="hljs-keyword">PROCEDURE</span> %s （ER_SP_BADSELECT)。<br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">控制流程函数<br>存储过程/函数体 中的流程控制是不一样的<br></code></pre></td></tr></table></figure><h1 id="子程序-存储过程"><a href="#子程序-存储过程" class="headerlink" title="子程序 - 存储过程"></a>子程序 - 存储过程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>基础介绍</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">MySQL5<span class="hljs-number">.0</span> 版本开始支持存储过程。<br><br>大多数 <span class="hljs-keyword">SQL</span> 语句都是针对一个或多个表的单条语句。并非所有的操作都那么简单。经常会有一个完整的操作需要多条语句才能完成。<br><br>存储过程简单来说，就是为以后的使用而保存的一条或多条 MySQL 语句的集合。可将其视为批处理文件。虽然他们的作用不仅限于批处理。<br><br>存储过程思想上很简单，就是数据库 <span class="hljs-keyword">SQL</span> 语言层面的代码封装与重用。 <br></code></pre></td></tr></table></figure><ul><li>优点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1. 通过把处理封装在容易使用的单元中，简化复杂的操作；<br>2. 简化对变动的管理。如果表名、列名或业务逻辑有变化。只需要更改存储过程的代码，使用它的人员不会改自己的代码；<br>3. 通常存储过程有助于提高应用程序的性能。当创建的存储过程被编译之后，就存储在数据库中。 但是，MySQL 实现的存储过程略有不同。 MySQL 存储过程按需编译。在编译存储过程之后，MySQL 将其放入缓存中。MySQL 为每个连接维护自己的存储过程高速缓存。如果应用程序在单个连接中多次使用存储过程，则使用编译版本，否则存储过程的工作方式类似于查询；<br>4. 存储过程有助于减少应用程序和数据库服务器之间的流量，因为应用程序不必发送多个冗长的 SQL 语句，而只用发送存储过程的名称和参数；<br>5. 存储的程序对任何应用程序都是可重用的和透明的。存储过程将数据库接口暴露给所有应用程序，以便开发人员不必开发存储过程中已支持的功能；<br>6. 存储的程序是安全的。数据库管理员可以向访问数据库中存储过程的应用程序授予适当的权限，而不向基础数据库表提供任何权限。<br> <br></code></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 如果使用大量存储过程，那么使用这些存储过程的每个连接的内存使用量将会大大增加。 此外，如果您在存储过程中过度使用大量逻辑操作，则 CPU 使用率也会增加，因为 MySQL 数据库最初的设计侧重于高效的查询，不利于逻辑运算；<br><span class="hljs-bullet">2.</span> 存储过程的构造使得开发具有复杂业务逻辑的存储过程变得更加困难；<br><span class="hljs-bullet">3.</span> 很难调试存储过程。只有少数数据库管理系统允许您调试存储过程。不幸的是，MySQL 不提供调试存储过程的功能；<br><span class="hljs-bullet">4.</span> 开发和维护存储过程并不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可能会导致应用程序开发和维护阶段的问题。 <br></code></pre></td></tr></table></figure><ul><li>其他</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#介绍<br>一个存储程序是可以被存储在服务器中的一套SQL语句。一旦它被存储了，客户端不需要再重新发布单独的语句，而是可以引用存储程序来替代。<br>存储过程就是具有名字的一段代码，用来完成一个特定的功能。<br>创建的存储过程保存在数据库的数据字典中<br><br>#优势<br>1， 当用不同语言编写多客户应用程序，或多客户应用程序在不同平台上运行且需要执行相同的数据库操作之时<br>2， 更为安全。。比如，银行对所有普通操作使用存储程序。这提供一个坚固而安全的环境，程序可以确保每一个操作都被妥善记入日志。在这样一个设置中，应用程序和用户不可能直接访问数据库表，但是仅可以执行指定的存储程序。<br>3. 存储程序可以提供改良后的性能，因为只有较少的信息需要在服务器和客户算之间传送<br>    存储过程可封装，并隐藏复杂的商业逻辑。<br>    存储过程可以回传值，并可以接受参数。 <br>    存储过程可以用在数据检验，强制实行商业逻辑等。<br><br><br>#缺点<br>1. 增加数据库服务器系统的负荷，因为更多的工作在服务器这边完成，更少的在客户端（应用程序）那边完成上。如果许多客户端机器（比如网页服务器）只由一个或少数几个数据库服务器提供服务，可以考虑一下存储程序。<br>2. 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。<br>3. 存储过程的性能调校与撰写，受限于各种数据库系统。<br><br>#限制<br>    存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。<br></code></pre></td></tr></table></figure><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] PROCEDURE sp_name ([proc_parameter[,...]])<br>    [characteristic ...] routine_body<br> <br># 参数 <br>proc_parameter:<br>    [ IN | OUT | INOUT ] param_name type<br> <br>#  存储过程的特征<br>characteristic:<br>    COMMENT &#x27;string&#x27;   # 注释<br>  | LANGUAGE SQL # 使用什么语言写<br>  | [NOT] DETERMINISTIC # 存储过程是否具有确定的<br>  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; # 对数据库的影响<br>  | SQL SECURITY &#123; DEFINER | INVOKER &#125; #指定存储过程的执行权限级别的属性<br> <br># 存储体/函数体·<br>routine_body:<br>　　Valid SQL routine statement<br>　<br> ====================================================<br>函数小括号<br>即使没有参数，小括号也不能省略<br>参数<br>    输入值使用in参数。<br>    返回值使用out参数。<br>    inout参数就尽量的少用。<br>    <br><br><br></code></pre></td></tr></table></figure><h2 id="demo-4"><a href="#demo-4" class="headerlink" title="demo"></a>demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimoter $$<br>create procedure 函数名(入参/出参 参数名 参数类型)<br>begin<br>select p_in;<br>set p_in=2;<br>select p_in;<br>end$$<br><br><br><br><br>mysql&gt; delimiter //<br>mysql&gt; CREATE PROCEDURE simpleproc (OUT param1 INT)<br>    -&gt; BEGIN<br>    -&gt;   SELECT COUNT(*) INTO param1 FROM t;<br>    -&gt; END<br>    -&gt; //<br>Query OK, 0 rows affected (0.00 sec)<br><br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE 存储过程名([[IN |OUT |INOUT ] 参数名 数据类形...])<br><br>参数一共有三种：<br>    IN 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）<br>    OUT 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）<br>    INOUT 输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）<br></code></pre></td></tr></table></figure><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimoter $$<br>create procedure in_param(in p_in int)<br>begin<br>select p_in;<br>set p_in=2;<br>select p_in;<br>end$$<br><br>delimiter ;<br>set @p_in=1;<br>mysql&gt; call in_param(@p_in);<br>+------+<br>| p_in |<br>+------+<br>|    1 |<br>+------+<br> <br>+------+<br>| P_in |<br>+------+<br>|    2 |<br>+------+<br><br># p_in 在存储过程中被修改，但并不影响 @p_in 的值，因为前者为局部变量、后者为全局变量<br>mysql&gt; select @p_in;<br>+-------+<br>| @p_in |<br>+-------+<br>|     1 |<br>+-------+<br></code></pre></td></tr></table></figure><h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter $$<br>create procedure out_param(out p_out int)<br>begin<br>select p_out;<br>set p_out=2;<br>select p_out;<br>end$$<br>delimiter ;<br><br>mysql&gt; set @p_out=1;<br> <br>mysql&gt; call out_param(@p_out);<br>#因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为null<br>+-------+<br>| p_out |<br>+-------+<br>|  NULL |<br>+-------+<br>　　<br>+-------+<br>| p_out |<br>+-------+<br>|     2 |<br>+-------+<br> <br>mysql&gt; select @p_out;<br>#调用了out_param存储过程，输出参数，改变了p_out变量的值<br>+--------+<br>| @p_out |<br>+--------+<br>|      2 |<br>+--------+<br>　　<br><br></code></pre></td></tr></table></figure><h3 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delimiter $$<br>create procedure inout_param(inout p_inout int)<br>begin<br>select p_inout;<br>set p_inout=2;<br>select p_inout;<br>end $$<br>delimiter ;<br><br>mysql&gt; call inout_param(@p_inout);<br>+---------+<br>| p_inout |<br>+---------+<br>|       1 |<br>+---------+<br> <br>+---------+<br>| p_inout |<br>+---------+<br>|       2 |<br>+---------+<br> <br>mysql&gt; select @p_inout;<br>+----------+<br>| @p_inout |<br>+----------+<br>|        2 |<br>+----------+<br>#调用了inout_param存储过程，接受了输入的参数，也输出参数，改变了变量<br></code></pre></td></tr></table></figure><h2 id="存储过程特征"><a href="#存储过程特征" class="headerlink" title="存储过程特征"></a>存储过程特征</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#  存储过程的特征<br>characteristic:<br>    COMMENT &#x27;string&#x27;   # 注释<br>  | LANGUAGE SQL # 使用什么语言写<br>  | [NOT] DETERMINISTIC<br>  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;<br>  | SQL SECURITY &#123; DEFINER | INVOKER &#125;<br><br>    <br>存储过程特征<br>1.  LANGUAGE SQL：指定了存储过程使用的语言类型。对于绝大多数情况，MySQL的存储过程是使用SQL语言编写的。然而，并非所有的数据库管理系统都仅限于使用SQL语言编写存储过程。一些数据库允许存储过程使用其他编程语言编写，比如PL/SQL（Oracle）、T-SQL（SQL Server）或者使用类似于JavaScript、Python等的脚本语言。<br>2. determictic: 确定性：如果一个存储过程被标记为确定性（DETERMINISTIC），那么对于给定的输入参数，它总是产生相同的输出。换句话说，无论何时调用具有相同参数的存储过程，都会得到相同的结果。这在某些情况下非常重要，尤其是当存储过程执行的操作是基于输入参数并且不依赖于外部因素时。 确定性对于数据库引擎来说很重要，因为它会影响到数据库的查询优化和缓存。确定性的存储过程更容易被优化和缓存，因为相同的输入总是产生相同的输出，而非确定性的存储过程则更难被优化，因为无法预测其输出。<br><br>3. 存储过程对数据库影响的属性。这些属性的定义有助于数据库管理系统优化存储过程的执行方式，尤其是在涉及到缓存、权限管理以及性能优化方面。指定正确的属性可以帮助数据库系统更好地理解和处理存储过程，以提高执行效率和安全性。<br>CONTAINS SQL: 这表示存储过程包含SQL语句。大多数存储过程都属于这个类别，因为它们通常包含执行SQL查询或更新的语句。<br>NO SQL: 表示存储过程不包含任何SQL语句。它可能是一个计算型的过程，不涉及数据库的读取或写入操作，可能执行一些逻辑运算或控制流操作。<br>READS SQL DATA: 表示存储过程可能会读取数据库中的数据，但不会修改（写入）数据。它可能会执行SELECT语句或者一些只读的操作。<br>MODIFIES SQL DATA: 表示存储过程可能会修改数据库中的数据，可能包括INSERT、UPDATE、DELETE等会改变数据库内容的操作。<br><br>4. 权限。选择适当的SQL SECURITY级别取决于存储过程的目的以及安全需求。使用DEFINER级别可以确保存储过程在固定的权限下执行，而INVOKER级别则允许存储过程根据调用者的权限动态执行。不同的数据库管理系统可能对SQL SECURITY的实现有所不同，因此在具体使用时，需要参考相应数据库的文档以了解具体的行为和限制。<br><br>SQL SECURITY是用来指定存储过程的执行权限级别的属性。<br><br>DEFINER: 当存储过程以定义者（DEFINER）的权限级别执行时，它将以存储过程的创建者（定义者）的权限来执行。这意味着无论谁调用存储过程，都会以创建者的权限来执行其中的SQL语句。这通常用于确保存储过程以创建者的权限执行，无论调用者的权限是什么。<br><br>INVOKER: 当存储过程以调用者（INVOKER）的权限级别执行时，它将以调用者的权限来执行。换句话说，存储过程内部的SQL语句将按照调用者的权限级别来执行。这对于需要根据调用者权限动态执行SQL语句的情况很有用。<br><br><br></code></pre></td></tr></table></figure><h2 id="存储-函数体"><a href="#存储-函数体" class="headerlink" title="存储&#x2F;函数体"></a>存储&#x2F;函数体</h2><h3 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">delimeter <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> 防止语句被解析 <br></code></pre></td></tr></table></figure><h3 id="begin-end"><a href="#begin-end" class="headerlink" title="begin  end"></a>begin  end</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 复合语句: 来包含多个语句<br>[begin_label:] BEGIN<br>　　[statement_list]<br>　　　　……<br>END [end_label]  <br><br>begin 与end 表示过程主体的开始和结束，相当于 Java 定义方法的一对大括号；<br></code></pre></td></tr></table></figure><h3 id="if-1"><a href="#if-1" class="headerlink" title="if"></a>if</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF search_condition THEN statement_list<br>[ELSEIF search_condition THEN statement_list] ...<br>[ELSE statement_list]<br>END IF<br><br><br>create procedure test2(in num int)<br>begin<br>if num&lt;0 then<br>select &#x27;负数&#x27;<br>elseif num=0 then<br>select &#x27;不是正数也不是负数&#x27;<br>else<br>select &#x27;正数&#x27;<br>end if;<br>end;<br></code></pre></td></tr></table></figure><h3 id="case-1"><a href="#case-1" class="headerlink" title="case"></a>case</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE case_value<br>    WHEN when_value THEN statement_list<br>    [WHEN when_value THEN statement_list] ...<br>    [ELSE statement_list]<br>END CASE<br> <br>CASE<br>    WHEN search_condition THEN statement_list<br>    [WHEN search_condition THEN statement_list] ...<br>    [ELSE statement_list]<br>END CASE<br><br><br># 适合范围值判断<br>create procedure test1(in num int)<br>begin<br>case <br>when num &lt; 0 then select &#x27;负数&#x27;;<br>when num = 0 then select &#x27;不是正数也不是负数&#x27;;<br>when num &gt; 0 then select &#x27;正数&#x27;;<br>end case;<br>end;<br><br># 适合准确值判断<br>create procedure test2(in num int)<br>begin<br>case num<br>when 1 then select &#x27;1&#x27;;<br>when 2 then select &#x27;2&#x27;;<br>else select &#x27;不确定输入的是几&#x27;;<br>end case;<br>end;<br></code></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[begin_label:] WHILE search_condition DO<br>    statement_list<br>END WHILE [end_label]<br><br><br>#定义存储过程，实现 1+...+10<br>create producer test(out sum int)<br>begin<br>declare num int default 0;<br>set num = 0;<br>while num &lt; 10 do<br>set num = num + 1;<br>set sum = sum + num;-3--<br>end while;<br>end<br><br><br>call test(@sum)  -- 调用存储过程<br>select @sum  -- 获取结果<br></code></pre></td></tr></table></figure><h3 id="repeat-循环"><a href="#repeat-循环" class="headerlink" title="repeat 循环"></a>repeat 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[begin_label:] REPEAT<br>    statement_list<br>UNTIL search_condition<br>END REPEAT [end_label]<br><br><br>用法<br>repeat语句的用法和 java中的 do…while 语句类似，都是先执行循环操作，再判断条件，区别是 repeat表达<br>式值为 false时才执行循环操作，直到表达式值为 true停止。<br><br>demo <br>create procedure test(out sum int)<br>begin <br>declare num int default 0;<br>set sum = 0;<br>repeat<br>set num = num + 1;<br>set sum = sum + num;<br>util num &gt;= 10<br>end repeat;<br>end;<br><br>call test(@sum); -- 调用过程<br>select @sum -- 查询结果<br><br></code></pre></td></tr></table></figure><h3 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[begin_label:] LOOP<br>    statement_list<br>END LOOP [end_label]<br><br>1. 无限循环，需要使用 leave 退出<br><br>create procedure test(out sum int)<br>begin<br>declare num int default 0;<br>set sum = 0;<br>loop_flag: loop<br>set num = num + 1;<br>set sum = sum + num;<br>if num &gt;= 10 then leave loop_flag;<br>end if;<br>end loop loop_flag;<br>end;<br>call test(@sum) -- 调用过程<br>select @sum -- 查询变量<br><br></code></pre></td></tr></table></figure><h3 id="leave-break"><a href="#leave-break" class="headerlink" title="leave &#x3D;&#x3D;&gt; break"></a>leave &#x3D;&#x3D;&gt; break</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LEAVE label<br># 等效于 java 中的 break<br>这个语句被用来退出任何被标注的流程控制构造。它和BEGIN ... END或循环一起被使用。<br><br><br></code></pre></td></tr></table></figure><h3 id="iterete-continue"><a href="#iterete-continue" class="headerlink" title="iterete &#x3D;&#x3D;&gt; continue"></a>iterete &#x3D;&#x3D;&gt; continue</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ITERATE label<br># 等效于 java 中的 continue<br>ITERATE只可以出现在LOOP, REPEAT, 和WHILE语句内。ITERATE意思为：“再次循环。” <br><br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 直接使用 navicate 即可<br>查询存储过程<br>show procedure status;<br><br>显示特定数据库的存储过程<br>show procedure status where db=&#x27;test&#x27;;<br><br>显示特定模式的存储过程，要求显示莫名成中包含 tes 的存储过程<br>show procedure status where name like &#x27;%tes%&#x27;<br><br>删除存储过程 test<br>drop procedure test;<br></code></pre></td></tr></table></figure><h1 id="子程序-函数"><a href="#子程序-函数" class="headerlink" title="子程序 - 函数"></a>子程序 - 函数</h1><h2 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. RETURNS字句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。 <br># 2. <br>CREATE FUNCTION sp_name ([func_parameter[,...]]) RETURNS type<br>    [characteristic ...] routine_body<br>    <br>    proc_parameter:<br>    [ IN | OUT | INOUT ] param_name type<br>    <br>    func_parameter:<br>    param_name type<br><br><br>type:<br>    Any valid MySQL data type<br><br>routine_body:<br># 合法的SQL过程语句。可以使用复合语句语法，复合语句可以包含声明，循环和其它控制结构语句<br>    Valid SQL procedure statement or statements<br><br><br><br>==================<br>1. CREATE FUNCTION语句被用在更早的MySQL版本上以支持UDF （自定义函数）。 UDF继续被支持，即使现在有了存储函数。UDF会被认为一个外部存储函数。然而，不要让存储函数与UDF函数共享名字空间。 <br><br><br><br></code></pre></td></tr></table></figure><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">version</span><span class="hljs-params">()</span></span>  mysql数据库的版本<br><br></code></pre></td></tr></table></figure><h3 id="待整理-2"><a href="#待整理-2" class="headerlink" title="待整理"></a>待整理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">COALESCE(value,...) : <br>[coalesce]返回值为列表当中的第一个非 NULL值，全部都是 NULL 值得情况下返回值为 NULL <br><br>GREATEST(value1,value2,...) [greatest]<br>    1. 当有2或多个参数时，返回值为最大(最大值的)参数。比较参数所依据的规律同LEAST()相同。<br>    2. 没有参数，则返回 null<br>    <br>expr IN (value,...) <br>expr 为IN列表中的任意一个值，则其返回值为 1 , 否则返回值为0<br>1. 如果 value 都是常数， 则使用二分法进行搜索<br>2. 如果 expr 是个区分大小的字符串，则字符串比较也按照区分大小的方式进行<br>3. 为了同SQL 标准相一致，在左侧表达式为NULL的情况下，或是表中找不到匹配项或是表中一个表达式为NULL 的情况下，IN的返回值均为NULL<br>4. IN 列表中所列值的个数仅受限于 max_allowed_packet 值<br><br>expr NOT IN (value,...) 等价于 NOT (expr IN (value,...)) 。 <br><br>ISNULL(expr) <br>1. expr 为NULL，那么ISNULL() 的返回值为 1，否则返回值为 0。 <br>2. 同 IS NULL比较操作符具有一些相同的特性<br><br>INTERVAL(N,N1,N2,N3,...) [interval]  ??????<br><br><br>LEAST(value1,value2,...)  [least]<br>1. 返回参数中的最小值 ？？？？？？？？？<br>假如返回值被用在一个 INTEGER 语境中，或是所有参数均为整数值，则将其作为整数值进行比较。 <br>    假如返回值被用在一个 REAL语境中，或所有参数均为实值，则 将其作为实值进行比较。 <br>    假如任意一个参数是一个区分大小写的字符串，则将参数按照区分大小写的字符串进行比较。 <br>    在其它情况下，将参数作为区分大小写的字符串进行比较。 <br>    假如任意一个自变量为NULL，则 LEAST()的返回值为NULL 。<br><br></code></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">什么是视图<br>视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的。<br><br>　　通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用视图动态生成。<br><br>基表：用来创建视图的表叫做基表base table<br></code></pre></td></tr></table></figure><ul><li><p>优点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。<br><br>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。<br><br>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响<br></code></pre></td></tr></table></figure></li><li><p>缺点</p></li></ul><h2 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [OR REPLACE]   <br>　　[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]  <br>　　[DEFINER = &#123; user | CURRENT_USER &#125;]  <br>　　[SQL SECURITY &#123; DEFINER | INVOKER &#125;]<br>VIEW view_name [(column_list)]  <br>AS select_statement  <br>　　[WITH [CASCADED | LOCAL] CHECK OPTION]<br><br> <br>使用<br>视图一旦创建完毕，就可以像一个普通表那样使用，视图主要用来查询<br><br>权限：<br>1. create view 权限， select 每一列权限<br>2. select 权限<br>3. or replace : drop 权限<br> <br> # 总结<br>　   使用root用户定义一个视图(推荐使用第一种)：u1、u2<br>　　　　1）u1作为定义者定义一个视图，u1对基表有select权限，u2对视图有访问权限：u2是以定义者的身份访问可以查询到基表的内容；<br>　　　　2）u1作为定义者定义一个视图，u1对基表没有select权限，u2对视图有访问权限，u2对基表有select权限：u2访问视图的时候是以调用者的身份，此时调用者是u2，可以查询到基表的内容。<br><br><br>限制：<br>·         SELECT语句不能包含FROM子句中的【子查询】<br>·         SELECT语句不能引用系统或用户变量。<br>·         SELECT语句不能引用预处理语句参数。<br>·         在存储子程序内，定义不能引用子程序参数或局部变量。<br>·         在定义中引用的表或视图必须存在。但是，创建了视图后，能够舍弃定义引用的表或视图。要想检查视图定义是否存在这类问题，可使用CHECK TABLE语句。<br>·         在定义中不能引用TEMPORARY表，不能创建TEMPORARY视图。<br>·         在视图定义中命名的表必须已存在。<br>·         不能将触发程序与视图关联在一起。<br>·         如果创建了视图，并通过更改系统变量更改了查询处理环境，会影响从视图获得的结果<br></code></pre></td></tr></table></figure><ul><li>create [or replace]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create 创建视图<br>or replace 替换已有的视图<br><br></code></pre></td></tr></table></figure><ul><li>ALGORITHM</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALGORITHM：表示视图选择算法 <br>1. 对于 MERGE合并[将视图的语句与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分]，会将引用视图的语句的文本与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分。<br>2. 对于 TEMPTABLE临时表[将视图的结果存入临时表，然后使用临时表执行语句]，视图的结果将被置于临时表中，然后使用它执行语句。MERGE算法要求视图中的行和基表中的行具有一对一的关系。如果不具有该关系。必须使用临时表取而代之。如果视图包含下述结构中的任何一种，将失去一对一的关系：<br>·         聚合函数（SUM(), MIN(), MAX(), COUNT()等）。<br>·         DISTINCT <br>·         GROUP BY <br>·         HAVING <br>·         UNION或UNION ALL <br>·         仅引用文字值（在该情况下，没有基本表）。<br> <br>3. 对于 UNDEFINED【未定义的,默认】。<br>总结： 1.如果可能，mysql倾向于MERGE而不是TEMPTABLE，这是因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。<br>总结： 2. 明确选择TEMPTABLE的1个原因在于，创建临时表之后、并在完成语句处理之前，能够释放基表上的锁定。与MERGE算法相比，锁定释放的速度更快，这样，使用视图的其他客户端不会被屏蔽过长时间。<br><br></code></pre></td></tr></table></figure><ul><li>DEFINER</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DEFINER<br>指出谁是视图的创建者或定义者<br>definer= &#x27;用户名&#x27;@&#x27;登录主机&#x27;<br>    如果不指定该选项，则创建视图的用户就是定义者，指定关键字CURRENT_USER(当前用户)和不指定该选项效果相同<br></code></pre></td></tr></table></figure><ul><li>SQL SECURITY { DEFINER | INVOKER }</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SQL SECURITY选项：要查询一个视图，首先必须要具有对视图的select权限。<br><br>　　但是，如果同一个用户对于视图所访问的表没有select权限，那会怎么样？<br><br>SQL SECURITY选项决定执行的结果：<br><br>　　①SQL SECURITY DEFINER：定义(创建)视图的用户必须对视图所访问的表具有select权限，也就是说将来其他用户访问表的时候以定义者的身份，此时其他用户并没有访问权限。<br><br>　　②SQL SECURITY INVOKER：访问视图的用户必须对视图所访问的表具有select权限。<br><br>缺省SQL SECURITY选项等同于SQL SECURITY DEFINER<br></code></pre></td></tr></table></figure><ul><li>view name</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">viwe_name 视图名<br>1、 表和视图共享数据库中相同的名称空间，因此，数据库不能包含具有相同名称的表和视图<br>2、 视图必须具有唯一的列名，不得有重复，就像基表那样。默认情况下，由SELECT语句检索的列名将用作视图列名。要想为视图列定义明确的名称，可使用可选的column_list子句，列出由逗号隔开的ID。column_list中的名称数目必须等于SELECT语句检索的列数。<br>1. 视图属于数据库，默认在当前数据数据库创建视图.要想在给定数据库中明确创建视图，创建时，应将名称指定为db_name.view_name。 <br></code></pre></td></tr></table></figure><ul><li>select_statement</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select_statement  <br>1. 是一种SELECT语句，它给出了视图的定义。该语句可从基表或其他视图进行选择。 <br>2、SELECT语句检索的列可以是对表列的简单引用。也可以是使用函数、常量值、操作符等的表达式。<br>3、对于SELECT语句中不合格的表或视图，将根据默认的数据库进行解释。通过用恰当的数据库名称限定表或视图名，视图能够引用表或其他数据库中的视图<br>4、<br></code></pre></td></tr></table></figure><ul><li>WITH CHECK OPTION</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">定义时可以带上WITH CHECK OPTION约束<br>[WITH [CASCADED | LOCAL] CHECK OPTION]：表<br>对于可以执行DML操作的视图，需要带上，对视图所做的DML操作的结果，不能违反视图的WHERE条件的限制。视图在更新时保证在视图的权限范围之内【推荐使用，可以保证数据的安全性 】 <br>　　cascade 表示更新视图的时候，要满足视图和表的相关条件【检查所有的视图，默认值】<br>　　local表示更新视图的时候，要满足该视图定义的一个条件即可.【只检查将要更新的视图本身】<br></code></pre></td></tr></table></figure><h3 id="demo-创建视图"><a href="#demo-创建视图" class="headerlink" title="demo-创建视图"></a>demo-创建视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 从一个表创建视图<br>create view v_F_players(编号，名字，性别，电话)<br>as<br>select PLAYERNO,NAME,GENDER,PHONE from PLAYERS <br>where GENDER=&#x27;A&#x27;；<br>with check option;<br><br>select * from v_F_players；  -- 调用<br><br># 从两个表创建视图<br># 如果创建视图时不明确指定视图的列名，那么列名就和定义视图的select子句中的列名完全相同；<br># 如果显式的指定视图的列名就按照指定的列名<br>create view v_match<br>as<br>select a.PLAYERNO,a.NAME, WON, MARCHNO, c.TEAMNO, c.DIVISION <br>from<br>PLAYERS a, MATCHES b, TEAMS c<br>where a.PLAYERNO=b.PLAYERNO and b.TEAMNO=c.TEAMNO;<br></code></pre></td></tr></table></figure><h3 id="demo-with-check-option"><a href="#demo-with-check-option" class="headerlink" title="demo_with-check-option"></a>demo_with-check-option</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建视图<br>create view v_test<br>as<br>select * from PLAYERS<br>where birth_date &lt; &#x27;1960-01-01&#x27;<br>with check option;<br><br># 更新<br>update v_test<br>set BIRTH_DATE=&#x27;1970-09-01&#x27;<br>where PLAYERNO=39;<br><br># 抛出异常<br>ERROR 1369 (HY000): CHECK OPTION failed <br>&#x27;TENNIS.v_veterans&#x27;<br>因为违反了视图中的WHERE birth_date &lt; &#x27;1960-01-01&#x27;子句，所以抛出异常；<br>利用with check option约束限制，保证更新视图是在该视图的权限范围之内。<br></code></pre></td></tr></table></figure><h3 id="demo-视图嵌套"><a href="#demo-视图嵌套" class="headerlink" title="demo_视图嵌套"></a>demo_视图嵌套</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create view v_ear_venterans<br>as<br>select * from v_venterans<br>where JOINED &lt; 1980;<br><br></code></pre></td></tr></table></figure><h2 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 删除视图是指删除数据库中已存在的视图，删除视图时，只能删除视图的定义，不会删除数据，也就是说不动基表：<br>DROP VIEW [IF EXISTS]<br>    view_name [, view_name] ...<br>    [RESTRICT | CASCADE]<br><br> <br>DROP VIEW: 能够删除1个或多个视图。必须在每个视图上拥有DROP权限。<br><br>[IF EXISTS]: 这是一个可选的部分，表示如果视图存在，则执行删除操作。如果视图不存在，而这个选项被指定了，那么不会出现错误，命令会继续执行而不会中断，将为每个不存在的视图生成NOTE。<br><br>view_name [, view_name] ...: 这里是要删除的视图的名称列表。你可以在一个 DROP VIEW 命令中同时指定多个视图名称，用逗号分隔开。<br><br>[RESTRICT | CASCADE]: 这是针对存在依赖关系的情况下的操作选项：<br>RESTRICT: 如果其他对象依赖于要删除的视图，那么会阻止删除操作，并返回错误信息。<br>CASCADE: 如果其他对象依赖于要删除的视图，会先删除这些依赖于该视图的对象，然后再删除视图本身。<br>所以，这个语法允许你安全地<br></code></pre></td></tr></table></figure><h2 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]<br>    VIEW view_name [(column_list)]<br>    AS select_statement<br>    [WITH [CASCADED | LOCAL] CHECK OPTION]<br>1.该语句用于更改已有视图的定义<br>2.该语句需要具有针对视图的CREATE VIEW和DROP权限，也需要针对SELECT语句中引用的每一列的某些权限。<br><br></code></pre></td></tr></table></figure><h2 id="查询-3"><a href="#查询-3" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE VIEW view_name<br>获取 create view 的完整语句，该语句给出了1个创建给定视图的CREATE VIEW语句。<br></code></pre></td></tr></table></figure><h2 id="DML-更新"><a href="#DML-更新" class="headerlink" title="DML_更新"></a>DML_更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 因为视图本身没有数据，因此对视图进行的dml操作最终都体现在基表中<br># 视图的DML操作，不是所有的视图都可以做DML操作。<br>　　①select子句中包含distinct<br>　　②select子句中包含组函数<br>　　③select语句中包含group by子句<br>　　④select语句中包含order by子句<br>　　⑤select语句中包含union 、union all等集合运算符<br>　　⑥where子句中包含相关子查询<br>　　⑦from子句中包含多个表<br>　　⑧如果视图中有计算列，则不能更新<br>　　⑨如果基表中有某个具有非空约束的列未出现在视图定义中，则不能做insert操作<br><br><br>某些视图是可更新的。也就是说，可以在诸如UPDATE、DELETE或INSERT等语句中使用它们，以更新基表的内容。对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。还有一些特定的其他结构，这类结构会使得视图不可更新。更具体地讲，如果视图包含下述结构中的任何一种，那么它就是不可更新的：<br><br>·         聚合函数（SUM(), MIN(), MAX(), COUNT()等）。<br>·         DISTINCT <br>·         GROUP BY <br>·         HAVING <br>·         UNION或UNION ALL <br>·         位于选择列表中的子查询<br>·         Join <br>·         FROM子句中的不可更新视图<br>·         WHERE子句中的子查询，引用FROM子句中的表。<br>·         仅引用文字值（在该情况下，没有要更新的基本表）。<br>·         ALGORITHM = TEMPTABLE（使用临时表总会使视图成为不可更新的）。<br><br>混合了简单列引用和导出列的视图是不可插入的，但是，如果仅更新非导出列，视图是可更新的。考虑下述视图：<br><br>CREATE VIEW v AS SELECT col1, 1 AS col2 FROM t;<br>该视图是不可插入的，这是因为col2是从表达式导出的。但是，如果更新时不更新col2，它是可更新的。这类更新是允许的：<br><br>UPDATE v SET col1 = 0;<br>下述更新是不允许的，原因在于，它试图更新导出列：<br><br>UPDATE v SET col2 = 0;<br><br></code></pre></td></tr></table></figure><h2 id="DML-插入"><a href="#DML-插入" class="headerlink" title="DML_插入"></a>DML_插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">关于可插入性（可用INSERT语句更新），如果它也满足关于视图列的下述额外要求，可更新的视图也是可插入的：<br>·         不得有重复的视图列名称。<br>·         视图必须包含没有默认值的基表中的所有列。<br>·         视图列必须是简单的列引用而不是导出列。导出列不是简单的列引用，而是从表达式导出的。下面给出了一些导出列示例：<br>·                3.14159<br>·                col1 + 3<br>·                UPPER(col2)<br>·                col3 / col4<br>·                (subquery)<br><br></code></pre></td></tr></table></figure><h2 id="不懂"><a href="#不懂" class="headerlink" title="不懂"></a>不懂</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">在视图定义中允许使用ORDER BY，但是，如果从特定视图进行了选择，而该视图使用了具有自己ORDER BY的语句，它将被忽略。<br><br>对于定义中的其他选项或子句，它们将被增加到引用视图的语句的选项或子句中，但效果未定义。例如，如果在视图定义中包含LIMIT子句，而且从特定视图进行了选择，而该视图使用了具有自己LIMIT子句的语句，那么对使用哪个LIMIT未作定义。相同的原理也适用于其他选项，如跟在SELECT关键字后的ALL、DISTINCT或SQL_SMALL_RESULT，并适用于其他子句，如INTO、FOR UPDATE、LOCK IN SHARE MODE、以及PROCEDURE。<br><br><br><br>在某些情况下，能够更新多表视图，假定它能使用MERGE算法进行处理。为此，视图必须使用内部联合（而不是外部联合或UNION）。此外，仅能更新视图定义中的单个表，因此，SET子句必须仅命名视图中某一表的列。即使从理论上讲也是可更新的，不允许使用UNION ALL的视图，这是因为，在实施中将使用临时表来处理它们。<br><br>对于多表可更新视图，如果是将其插入单个表中，INSERT能够工作。不支持DELETE。<br><br>对于可更新视图，可给定WITH CHECK OPTION子句来防止插入或更新行，除非作用在行上的select_statement中的WHERE子句为“真”。<br><br>在关于可更新视图的WITH CHECK OPTION子句中，当视图是根据另一个视图定义的时，LOCAL和CASCADED关键字决定了检查测试的范围。LOCAL关键字对CHECK OPTION进行了限制，使其仅作用在定义的视图上，CASCADED会对将进行评估的基表进行检查。如果未给定任一关键字，默认值为CASCADED。请考虑下述表和视图集合的定义：<br><br>mysql&gt; CREATE TABLE t1 (a INT);<br>mysql&gt; CREATE VIEW v1 AS SELECT * FROM t1 WHERE a &lt; 2<br>    -&gt; WITH CHECK OPTION;<br>mysql&gt; CREATE VIEW v2 AS SELECT * FROM v1 WHERE a &gt; 0<br>    -&gt; WITH LOCAL CHECK OPTION;<br>mysql&gt; CREATE VIEW v3 AS SELECT * FROM v1 WHERE a &gt; 0<br>    -&gt; WITH CASCADED CHECK OPTION;<br>这里，视图v2和v3是根据另一视图v1定义的。v2具有LOCAL检查选项，因此，仅会针对v2检查对插入项进行测试。v3具有CASCADED检查选项，因此，不仅会针对它自己的检查对插入项进行测试，也会针对基本视图的检查对插入项进行测试。在下面的语句中，介绍了这些差异：<br><br>ql&gt; INSERT INTO v2 VALUES (2);<br>Query OK, 1 row affected (0.00 sec)<br>mysql&gt; INSERT INTO v3 VALUES (2);<br>ERROR 1369 (HY000): CHECK OPTION failed &#x27;test.v3&#x27;<br>视图的可更新性可能会受到系统变量updatable_views_with_limit的值的影响。请参见5.3.3节，“服务器系统变量”。<br><br>INFORMATION_SCHEMA包含1个VIEWS表，从该表可获取关于视图对象的信息。请参见23.1.15节，“INFORMATION_SCHEMA VIEWS表”。<br><br><br><br></code></pre></td></tr></table></figure><h2 id="不懂2"><a href="#不懂2" class="headerlink" title="不懂2"></a>不懂2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mysql">六、视图查询语句的处理<br><br>示例：所有有罚款的球员的信息<br><br>创建视图：<br><br>mysql&gt; create view cost_raisers<br>    -&gt; as<br>    -&gt; select * from PLAYERS<br>    -&gt; where playerno in (select playerno from PENALTIES);<br>查询视图：<br><br>mysql&gt; select playerno from cost_raisers<br>    -&gt; where town=&#x27;Stratford&#x27;;<br>+----------+<br>| PLAYERNO |<br>+----------+<br>|        6 |<br>+----------+ <br>1、替代方法：<br><br>　　先把select语句中的视图名使用定义视图的select语句来替代；<br><br>　　再处理所得到的select语句。<br><br>mysql&gt; select playerno from<br>　　 -&gt; (<br>    -&gt;   select * from PLAYERS<br>    -&gt;   where playerno in-&gt;   　　(select playerno from PENALTIES)<br>    -&gt; )as viewformula<br>    -&gt; where town=&#x27;Stratford&#x27;;<br>+----------+<br>| PLAYERNO |<br>+----------+<br>|        6 |<br>+----------+<br>2、具体化方法：<br><br>　　先处理定义视图的select语句，这会生成一个中间的结果集；<br><br>　　然后，再在中间结果上执行select查询。<br><br>mysql&gt; select &lt;列名&gt; from &lt;中间结果&gt;;　<br></code></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">触发器（Trigger） <br>执行时期： 在操作者对表进行「增删改」 之前（或之后）被触发，自动执行一段事先写好的 SQL 代码。<br>[before|after] insert <br>[before|after] update<br>[before|after] delete    <br></code></pre></td></tr></table></figure><h2 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER trigger_name trigger_time trigger_event<br>    ON tbl_name FOR EACH ROW trigger_stmt<br>  <br>  <br>限制<br>1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。例如，对于某一表，不能有两个BEFORE UPDATE触发程序。但可以有1个BEFORE UPDATE触发程序和1个BEFORE INSERT触发程序，<br>    <br>trigger_name 触发器的名字<br><br>trigger_time 触发器执行时机<br>这里设置触发器是在关键动作执行之前触发，还是执行之后触发。<br>触发程序的动作时间。它可以是BEFORE或AFTER，以指明触发程序是在激活它的语句之前或之后触发。<br><br>trigger_event 触发器监测的对象.<br>触发器可以监测 INSERT、UPDATE、DELETE 的操作，当监测的命令对触发器关联的表进行操作时，触发器就被激活了。<br># trigger_event与以表操作方式激活触发程序的SQL语句并不很类似，这点很重要,注意看例子<br>    INSERT：将新行插入表时激活触发程序，例如，通过INSERT、LOAD DATA和REPLACE语句。<br>    UPDATE：更改某一行时激活触发程序，例如，通过UPDATE语句。<br>    DELETE：从表中删除某一行时激活触发程序，例如，通过DELETE和REPLACE语句。<br>    # 特例<br>    可能会造成混淆的例子之一是INSERT INTO .. ON DUPLICATE UPDATE ...语法：BEFORE INSERT触发程序对于每一行将激活，后跟AFTER INSERT触发程序，或BEFORE UPDATE和AFTER UPDATE触发程序，具体情况取决于行上是否有重复键。<br>    <br><br><br>tbl_name表名<br>将这个触发器与数据库中的表进行关联，触发器定义在表上，也附着在表上，如果这个表被删除了，那么这个触发器也随之被删除。<br>必须引用永久性表。不能将触发程序与TEMPORARY表或视图关联起来。<br><br><br>FOR EACH ROW：<br>这句表示只要满足触发器触发条件，触发器都会被执行，也就是说带上这个参数后，触发器将监测每一行对关联表操作的代码，一旦符合条件，触发器就会被触发。<br><br><br>trigger_stmt [触发器主体代码]：<br>这里是当满足触发条件后，被触发执行的代码主体。这里可以是一句 SQL 语句，也可以是多行命令。如果是多行命令，那么这些命令要写在 BEGIN...END 之间[一句sql可以省略begin，但是最好不要省略]<br></code></pre></td></tr></table></figure><h2 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql 待汇总</title>
    <link href="/2024/04/21/mysql/mysql%20%E5%BE%85%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/21/mysql/mysql%20%E5%BE%85%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><table><thead><tr><th><strong>特性</strong></th><th><strong>MySQ系列</strong></th></tr></thead><tbody><tr><td>Foreign keys</td><td>3.23（针对InnoDB存储引擎）</td></tr><tr><td>Unions</td><td>4.0</td></tr><tr><td>Subqueries</td><td>4.1</td></tr><tr><td>R-trees</td><td>4.1（针对MyISAM 存储引擎）</td></tr><tr><td>Stored procedures</td><td>5.0</td></tr><tr><td>Views</td><td>5.0</td></tr><tr><td>Cursors</td><td>5.0</td></tr><tr><td>XA transactions</td><td>5.0</td></tr><tr><td>Foreign keys</td><td>5.1（在3.23中实施，对于InnoDB）</td></tr><tr><td>Triggers</td><td>5.0和5.1</td></tr><tr><td>Full outer joins</td><td>5.1</td></tr><tr><td>Constraints</td><td>5.1（在3.23中实施，对于InnoDB）</td></tr><tr><td>Partitioning</td><td>5.1</td></tr><tr><td>Pluggable Storage Engine API</td><td>5.1</td></tr><tr><td>Row-Based Replication</td><td>5.1</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql 日志</title>
    <link href="/2024/04/21/mysql/mysql%20%E6%97%A5%E5%BF%97/"/>
    <url>/2024/04/21/mysql/mysql%20%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h1><ul><li><a href="http://c.biancheng.net/view/7764.html">http://c.biancheng.net/view/7764.html</a></li><li><a href="https://blog.csdn.net/nmb_jiang/article/details/105436501">https://blog.csdn.net/nmb_jiang/article/details/105436501</a></li><li><a href="https://blog.csdn.net/weixin_49472648/article/details/125824697?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-125824697-blog-105436501.235%5Ev36%5Epc_relevant_anti_vip_base&spm=1001.2101.3001.4242.2&utm_relevant_index=4">https://blog.csdn.net/weixin_49472648/article/details/125824697?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-125824697-blog-105436501.235^v36^pc_relevant_anti_vip_base&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4</a></li><li></li></ul><h1 id="mysq-日志"><a href="#mysq-日志" class="headerlink" title="mysq 日志"></a>mysq 日志</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>错误日志</li><li>查询日志  <strong>select 查询语句</strong></li><li>慢查询日志    <strong>查看执行时间长的sql，可开启慢日志查询</strong></li><li>事务日志(Redo log)</li><li>二进制日志</li><li>中继日志</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询全局日志存储的方式，注意是所有日志的存储方式<br>show variables like &#x27;log_output&#x27;<br><br># 设置<br>set global log_output=&#x27;xxx&#x27;;<br>FILE：表示日志将输出到文件中。<br>    TABLE：表示日志将输出到 MySQL 的系统表中，如 mysql.general_log 表和 mysql.slow_log 表。<br>    NONE：表示禁用日志输出。<br>    <br>log_output=&#x27;file&#x27;<br>-- 日志输出至table模式，查看日志记录<br>    SELECT * from mysql.general_log ORDER BY event_time DESC; <br> <br> <br> -- table 模式日志清楚： 不允许使用delete删除mysql.general_log ，只能用truncate<br>truncate table mysql.general_log;<br></code></pre></td></tr></table></figure><h1 id="正在执行的语句查看"><a href="#正在执行的语句查看" class="headerlink" title="正在执行的语句查看"></a>正在执行的语句查看</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 切换数据库<br>use information_schema;<br>-- 查看正在执行的SQL语句<br>show processlist;<br><br>-- 或者直接使用SQL语句查询<br>select * from information_schema.`PROCESSLIST` where info is not null;<br>————————————————<br>版权声明：本文为CSDN博主「csd_nuser」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https://blog.csdn.net/csd_nuser/article/details/121236625<br></code></pre></td></tr></table></figure><h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>作用：记录启动\关闭\日常运行过程中,状态信息,警告,错误</li><li>位置： 默认开启， 位于 datadir&#x2F;hostname.err</li></ul><h2 id="语法配置"><a href="#语法配置" class="headerlink" title="语法配置"></a>语法配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 通过 SHOW 命令可以查看错误日志文件所在的目录及文件名信息。<br>SHOW VARIABLES LIKE &#x27;log_error&#x27;;<br><br>-- 可以使用 mysqladmin 命令来开启新的错误日志，以保证 MySQL 服务器上的硬盘空间<br>-- MySQL 服务器首先会自动创建一个新的错误日志，然后将旧的错误日志更名为 filename.err-old。<br>mysqladmin -uroot -p flush-logs<br></code></pre></td></tr></table></figure><h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">默认就是开启的:  /数据路径下/hostname.err<br>-- 查询<br>select @@log_error;<br>-- 手工设定:<br>vim /etc/my.cnf<br>log_error=/var/log/mysql.log<br>log_timestamps=system<br><br>-- 重启生效<br>show variables like &#x27;log_error&#x27;;<br></code></pre></td></tr></table></figure><h1 id="查询日志-general"><a href="#查询日志-general" class="headerlink" title="查询日志-general"></a>查询日志-general</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询是否开启普通日志功能<br>show variables like &#x27;general_log&#x27;;<br><br># 开启<br>set global general_log=on;<br><br># 关闭<br>set global general_log=off;<br><br>-- 查看日志输出文件的保存路径<br>show variables like &#x27;general_log_file&#x27;;<br><br>-- 修改日志输出文件的保存路径<br>set global general_log_file=&#x27;tmp/general.log&#x27;; <br><br>#===========================================<br><br>#===========================================<br></code></pre></td></tr></table></figure><h1 id="二进制日志-binarylog"><a href="#二进制日志-binarylog" class="headerlink" title="二进制日志(binarylog)"></a>二进制日志(binarylog)</h1><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">(<span class="hljs-number">1</span>)备份恢复必须依赖二进制日志<br>(<span class="hljs-number">2</span>)主从环境必须依赖二进制日志<br><br>二进制日志（Binary <span class="hljs-keyword">Log</span>）也可叫作变更日志（<span class="hljs-keyword">Update</span> <span class="hljs-keyword">Log</span>），是 MySQL 中非常重要的日志<br>主要用于记录数据库的变化情况，即 <span class="hljs-keyword">SQL</span> 语句的 DDL 和 DML 语句，【不包含】数据记录查询操作。<br><br><br>binlog是<span class="hljs-keyword">SQL</span>层的功能。记录的是变更<span class="hljs-keyword">SQL</span>语句，不记录查询语句。<br>    DDL ：原封不动的记录当前DDL(<span class="hljs-keyword">statement</span>语句方式)。<br>    DCL ：原封不动的记录当前DCL(<span class="hljs-keyword">statement</span>语句方式)。<br>    DML ：只记录已经提交的事务DM<br></code></pre></td></tr></table></figure><h3 id="my-cnf-配置"><a href="#my-cnf-配置" class="headerlink" title="my.cnf 配置"></a>my.cnf 配置</h3><ul><li>mysqld – 二进制日志</li></ul><h2 id="语法配置-1"><a href="#语法配置-1" class="headerlink" title="语法配置"></a>语法配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>-- 默认情况下，二进制日志功能是关闭的。<br>show variables like &#x27;%log_bin%&#x27;<br><br># 查看一共多少个binlog<br>show binary logs;  <br> <br># 查看正在使用的二进制日志， <br># file：当前MySQL正在使用的文件名， Position：最后一个事件的结束位置号<br>show master status<br><br># 查看二进制事件日志<br>show binlog events in &#x27;mysql-bin.000004&#x27;<br></code></pre></td></tr></table></figure><h2 id="记录内容"><a href="#记录内容" class="headerlink" title="记录内容"></a>记录内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">L<br>    <br>位置<br><br></code></pre></td></tr></table></figure><h3 id="记录单元-event"><a href="#记录单元-event" class="headerlink" title="记录单元 -event"></a>记录单元 -event</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">介绍<br>二进制日志记录的最小单元是 <span class="hljs-keyword">event</span><br>实例<br>对于DDL,DCL,一个语句就是一个<span class="hljs-keyword">event</span><br>    对于DML语句来讲:只记录已提交的事务。<br>    例如以下列子,就被分为了<span class="hljs-number">4</span>个<span class="hljs-keyword">event</span><br>    --- <br>    <span class="hljs-keyword">begin</span>  事件<span class="hljs-number">1</span><br>    a      事件<span class="hljs-number">2</span><br>    b      事件<span class="hljs-number">3</span><br>    commit 事件<span class="hljs-number">4</span><br>    -- 下面的要结合下面的 <span class="hljs-keyword">event</span> 日志<br>    <span class="hljs-keyword">begin</span><span class="hljs-punctuation">;</span>      <span class="hljs-number">120</span>  - <span class="hljs-number">340</span><br>    DML1        <span class="hljs-number">340</span>  - <span class="hljs-number">460</span><br>    DML2        <span class="hljs-number">460</span>  - <span class="hljs-number">550</span><br>    commit<span class="hljs-punctuation">;</span>     <span class="hljs-number">550</span>  - <span class="hljs-number">760</span><br></code></pre></td></tr></table></figure><h3 id="event-日志"><a href="#event-日志" class="headerlink" title="event - 日志"></a>event - 日志</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Master [binlog]&gt;show binlog events in &#x27;mysql-bin.000003&#x27;;<br>+------------------+-----+----------------+-----------+-------------+----------------------------------------+<br>| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                   |<br>+------------------+-----+----------------+-----------+-------------+----------------------------------------+<br>| mysql-bin.000003 |   4 | Format_desc    |         6 |         123 | Server ver: 5.7.20-log, Binlog ver: 4  |<br>| mysql-bin.000003 | 123 | Previous_gtids |         6 |         154 |                                        |<br>| mysql-bin.000003 | 154 | Anonymous_Gtid |         6 |         219 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |<br>| mysql-bin.000003 | 219 | Query          |         6 |         319 | create database binlog                 |<br>| mysql-bin.000003 | 319 | Anonymous_Gtid |         6 |         384 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |<br>| mysql-bin.000003 | 384 | Query          |         6 |         486 | use `binlog`; create table t1 (id int) |<br>+------------------+-----+----------------+-----------+-------------+----------------------------------------+<br><br># 文件介绍<br>mysql-bin.000003<br>这个不是普通的问题， 你直接使用 vim  查看得到的是乱码<br>-- 文件属性查看： file mysql-bin.000003<br>-- 文件查看： mysqlbinlog mysql-bin.000003<br># 参数介绍<br>    Log_name：binlog文件名<br>    Pos：开始的position    *****<br>    Event_type：事件类型<br>    Format_desc：格式描述，每一个日志文件的第一个事件，多用户没有意义，MySQL识别binlog必要信息<br>    Server_id：mysql服务号标识<br>    End_log_pos：事件的结束位置号 *****<br>    Info：事件内容*****<br>    补充:<br>    SHOW BINLOG EVENTS<br>       [IN &#x27;log_name&#x27;]<br>       [FROM pos]<br>       [LIMIT [offset,] row_count]<br>    [root@db01 binlog]# mysql -e &quot;show binlog events in &#x27;mysql-bin.000004&#x27;&quot; |grep drop<br>    <br><br><br></code></pre></td></tr></table></figure><h4 id="截取信息进行恢复"><a href="#截取信息进行恢复" class="headerlink" title="截取信息进行恢复"></a>截取信息进行恢复</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br></code></pre></td></tr></table></figure><h4 id="gtid"><a href="#gtid" class="headerlink" title="&#x3D;&#x3D; gtid"></a>&#x3D;&#x3D; gtid</h4><h4 id="gtid-记录模式"><a href="#gtid-记录模式" class="headerlink" title="gtid 记录模式"></a>gtid 记录模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">介绍<br>GTID(Global Transaction ID)<br>是对于一个已提交事务的编号，并且是一个全局唯一的编号。<br>版本改变<br>    5.6 版本新加的特性,不开启,没有这个功能.<br>    5.7 中的GTID,即使不开也会有自动生成， 十分完善了<br>    SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;<br>案例<br>DDL、DCL 中的一个 event 就是一个事务， 就会有一个 GTID 号<br>DML 语句中从 begin 到 commit 就是一个事务， 就有一个 GTID 号<br>配置<br>配置文件中<br><br>构成<br>GTID = source_id ：transaction_id<br>dff98809-55c3-11e9-a58b-000c2928f5dd:1-6 ： 该gtid中有6个事务，编号是1-6<br><br>幂等性<br>开启GTID后,MySQL恢复Binlog时,重复GTID的事务不会再执行了<br>会影响到 binlog 恢复和主从复制<br><br></code></pre></td></tr></table></figure><h4 id="gtid查看"><a href="#gtid查看" class="headerlink" title="gtid查看"></a>gtid查看</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mysql">具备GTID后,截取查看某些事务日志:<br>--include-gtids: 截取的事务<br>--exclude-gtids： 截取的时候， 需要抛出的事务<br>mysqlbinlog <br>--include-gtids=&#x27;dff98809-55c3-11e9-a58b-000c2928f5dd:1-6&#x27;  <br>--exclude-gtids=&#x27;dff98809-55c3-11e9-a58b-000c2928f5dd:4&#x27;  <br>/data/binlog/mysql-bin.000004<br><br>---------------------<br><br><br><br><br>Master [(none)]&gt;create database gtid charset utf8;  # 创建表 gtid<br>Query OK, 1 row affected (0.01 sec)<br><br>Master [(none)]&gt;show master status ;<br>+------------------+----------+--------------+------------------+----------------------------------------+<br>| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                      |<br>+------------------+----------+--------------+------------------+----------------------------------------+<br>| mysql-bin.000004 |      326 |              |                  | dff98809-55c3-11e9-a58b-000c2928f5dd:1 |<br>+------------------+----------+--------------+------------------+----------------------------------------+<br>1 row in set (0.00 sec)<br><br>-- 中间还有其他的内容<br><br>Master [gtid]&gt;begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>Master [gtid]&gt;insert into t2 values(1);<br>Query OK, 1 row affected (0.00 sec)<br><br>Master [gtid]&gt;commit;<br>Query OK, 0 rows affected (0.01 sec)<br><br>Master [gtid]&gt;show master status ;<br>+------------------+----------+--------------+------------------+------------------------------------------+<br>| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |<br>+------------------+----------+--------------+------------------+------------------------------------------+<br>| mysql-bin.000004 |     1321 |              |                  | dff98809-55c3-11e9-a58b-000c2928f5dd:1-6 |<br>+------------------+----------+--------------+------------------+------------------------------------------+<br>1 row in set (0.00 sec)<br><br></code></pre></td></tr></table></figure><h3 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 自动清理</span><br><span class="hljs-keyword">show </span>variables like <span class="hljs-string">&#x27;%expire%&#x27;</span>;<br>expire_logs_days  <span class="hljs-number">0</span>   <br>自动清理时间,是要按照全备周期+<span class="hljs-number">1</span><br>set global expire_logs_days=<span class="hljs-number">8</span>;<br>永久生效:<br>my.cnf<br>expire_logs_days=<span class="hljs-number">15</span>;<br>企业建议,至少保留两个全备周期+<span class="hljs-number">1</span>的<span class="hljs-keyword">binlog</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># 手动清理</span><br>PURGE <span class="hljs-keyword">BINARY </span>LOGS <span class="hljs-keyword">BEFORE </span>now() - INTERVAL <span class="hljs-number">3</span> day;<br>PURGE <span class="hljs-keyword">BINARY </span>LOGS TO <span class="hljs-string">&#x27;mysql-bin.000010&#x27;</span>;<br><br><span class="hljs-comment"># 注意</span><br><span class="hljs-number">1</span>. 主库永远不要使用 reset master, 因为这样会导致从库出现问题<br>注意:不要手工 rm <span class="hljs-keyword">binlog文件</span><br><span class="hljs-keyword"></span><span class="hljs-number">1</span>. my.cnf <span class="hljs-keyword">binlog关闭掉,启动数据库</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.把数据库关闭,开启<span class="hljs-keyword">binlog,启动数据库</span><br><span class="hljs-keyword"></span>删除所有<span class="hljs-keyword">binlog,并从000001开始重新记录日志</span><br><span class="hljs-keyword"></span><br><br><br></code></pre></td></tr></table></figure><h3 id="生成新的日志"><a href="#生成新的日志" class="headerlink" title="生成新的日志"></a>生成新的日志</h3><figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs k">日志滚动: 就是所谓的生成新的日志<br><span class="hljs-number">1.</span> flush logs; <br><span class="hljs-number">2.</span> 重启mysql也会自动滚动一个新的<br><span class="hljs-number">3.</span> 日志文件达到<span class="hljs-number">1</span>G大小(max_binlog_size)<br># <span class="hljs-built_in">show</span> max_binlog_size<br>| max_binlog_size                          | <span class="hljs-number">1073741824</span>     <br>备份时,加入参数也可以自动滚动<br></code></pre></td></tr></table></figure><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="基础恢复"><a href="#基础恢复" class="headerlink" title="基础恢复"></a>基础恢复</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 注意<br>mysql 只能做过滤一个库的操作<br># 文件信息截取<br>1. 一个 at 到下一个临近的 at 就是一个事件<br># 核心就是找截取的起点和终点,查看并截取<br>--start-position=321<br>--stop-position=513<br> mysqlbinlog <br> --start-position=219 <br> --stop-position=1347<br>    /data/binlog/mysql-bin.000003 <br>    &gt;/tmp/bin.sql<br><br>案例: 使用binlog日志进行数据恢复<br>模拟:<br>1. <br>[(none)]&gt;create database binlog charset utf8;<br>2. <br>[(none)]&gt;use binlog;<br>[binlog]&gt;create table t1(id int);<br>3. <br>[binlog]&gt;insert into t1 values(1);<br>[binlog]&gt;commit;<br>[binlog]&gt;insert into t1 values(2);<br>[binlog]&gt;commit;<br>[binlog]&gt;insert into t1 values(3);<br>[binlog]&gt;commit;<br>4. <br>[binlog]&gt;drop database binlog;<br><br><br>恢复: ===<br>[(none)]&gt;show master status ;   # 确认使用的哪一个日志<br>[(none)]&gt;show binlog events in &#x27;mysql-bin.000004&#x27;; # 查看事件<br>[root@db01 binlog]mysqlbinlog --start-position=1227 --stop-position=2342 /data/binlog/mysql-bin.000004 &gt;/tmp/bin.sql # 找到起点和终点， 进行截取<br>[(none)]&gt;set sql_Log_bin=0;  # 临时关闭恢复生产时产生的新日志，因为没必要相同的日志，记录两遍<br>[(none)]&gt;source /tmp/bin.sql # 日志恢复命令<br>[(none)]&gt;set sql_Log_bin=1; # 改回设置<br><br>面试案例:<br>1. 备份策略每天全备,有全量的二进制日志<br>2.业务中一共10个库,其中一个被误drop了<br>3. 需要在其他9个库正常工作过程中进行数据恢复<br><br></code></pre></td></tr></table></figure><h4 id="gtid-数据恢复"><a href="#gtid-数据恢复" class="headerlink" title="gtid 数据恢复"></a>gtid 数据恢复</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">幂等性<br>开启GTID后,MySQL恢复Binlog时,重复GTID的事务不会再执行了<br>会影响到 binlog 恢复和主从复制<br>-- 数据恢复操作<br><br>    mysqlbinlog <br>    --skip-gtids  # 忽略援用的 gtid 信息，恢复时生成最先的 gtid 信息<br>        --include-gtids=&#x27;dff98809-55c3-11e9-a58b-000c2928f5dd:1-6&#x27;  <br>        --exclude-gtids=&#x27;dff98809-55c3-11e9-a58b-000c2928f5dd:4&#x27;  <br>        /data/binlog/mysql-bin.000004 <br>        &gt;/temp/gtid.sql<br>    set sql_log_bin=0;  # 临时关闭恢复生产时产生的新日志，因为没必要相同的日志，记录两遍<br>    source /tmp/binlog.sql # 日志恢复命令<br>    set sql_log_bin=1; # 改回设置<br></code></pre></td></tr></table></figure><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">介绍<br>mysql 提供的一种日志记录， 主要用于记录响应时间超过阀值(默认10)的 sql 语句<br><br>标准<br>    执行时间大于 long_query_time 的语句。<br>    默认(10s)<br>设置<br>    默认关闭。<br>    不是调优， 不要开启，有性能问题<br> <br><br></code></pre></td></tr></table></figure><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查看<br>SHOW VARIABLES LIKE &#x27;%slow_ query_ log%&#x27;;<br>-- 开启了慢查询日志只对前数据库生效，sql 重启失效<br>set global slow_query_log=1<br><br><br><br>-- 永久开启, 配置后，重启mysql。<br>修改配置文件 my.cnf<br>log_output=file<br>slow_query_log=on<br>slow_query_log_file = tmp/mysql-slow.log<br>log_queries_not_using_indexes=on<br>long_query_time = 1<br></code></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldumpslow -s c -t 10 /data/mysql/slow.log<br><br># 第三方工具(自己扩展)<br>https://www.percona.com/downloads/percona-toolkit/LATEST/<br>yum install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-Digest-MD5<br>toolkit工具包中的命令:<br>./pt-query-diagest  /data/mysql/slow.log<br>Anemometer基于pt-query-digest将MySQL慢查询可视化<br></code></pre></td></tr></table></figure><h3 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量<br>默认情况下，参数处于关闭状态，并保存最近<span class="hljs-number">15</span>次的运行结果<br><br></code></pre></td></tr></table></figure><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">得到返回记录集最多的<span class="hljs-number">10</span>个SQL<br>mysqldumpslow -S r-t <span class="hljs-number">10</span> /<span class="hljs-keyword">var</span>/lib/mysql/atguigu-slow.log<br>得到访问次数最多的<span class="hljs-number">10</span>个SQL<br>mysqldumpslow -s C -t <span class="hljs-number">10</span> /<span class="hljs-keyword">var</span>/lib/mysql/atguigu-slow.log<br>得到按照时间排序的前<span class="hljs-number">10</span>条里面含有左连接的查询语句<br>mysqldumpslow -s t-t <span class="hljs-number">10</span> -g <span class="hljs-string">&quot;left join&quot;</span> /<span class="hljs-keyword">var</span>/lib/mysql/atguigu-slow.log<br>另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况<br>mysqldumpslow -S r -t <span class="hljs-number">10</span> /<span class="hljs-keyword">var</span>/lib/mysql/atguigu-slow.log| more<br><br>    <br>s:是表示按照何种方式排序:<br>c:访问次数<br>|:锁定时间<br>r:返回记录<br>t:查询时间<br>al:平均锁定时间<br>ar:平均返回记录数<br>at:平均查询时间<br>t:即为返回前面多少条的数据:<br>g:后边搭配。 个正则匹配模式，大小写不敏感的:<br>    <br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>是否支持， 查看当前 mysql 版本是否支持<br>    Show variables 1ike <span class="hljs-string">&#x27;profiling&#x27;</span>;<br><span class="hljs-number">2.</span>开启功能，默认是关闭，使用前需要开启 <br>    set profil ing=on;<br><span class="hljs-number">3.</span>运行SQL<br><span class="hljs-number">4.</span>查看结果，show profiles;<br><span class="hljs-number">5.</span>诊断SQL, show profile cpu,block io <span class="hljs-keyword">for</span> query上一步前面的问题SQL数字号码;数备注国<br><span class="hljs-number">6.</span>日常开发需要注意的结论+<br><br></code></pre></td></tr></table></figure><h2 id="文档分析"><a href="#文档分析" class="headerlink" title="文档分析"></a>文档分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">converting HEAP to MyISAM查询结果太大，内存都不够用了往磁盘上搬了。<br>Creating tmp table创建临时表圜<br>拷贝数据到临时表<br>用完再删除<br>Copying to tmp table on disk把内存中临时表复制到磁盘，危险! ! !<br>locked<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/21/hello-world/"/>
    <url>/2024/04/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="文章命名规范"><a href="#文章命名规范" class="headerlink" title="文章命名规范"></a>文章命名规范</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">软件-模块<br>mysql-权限分离<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
