<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>mysql 基础 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="符号分号 sql 语句一般后面跟一个分号，有些不跟。 一般都跟 12mysql通过寻找终止分号而不是输入行的结束来决定语句在哪儿结束。（换句话说，mysql接受自由格式的输入：它收集输入行但直到看见分号才执行。）  提示符 &gt;   提示符 含义    mysql&gt; 准备好接受新命令。   -&gt; 等待多行命令的下一行。   ‘&gt; 等待下一行，等待以单引号(“’”)开始的字符串">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql 基础">
<meta property="og:url" content="https://sunshulei456.github.io/2024/04/21/mysql/mysql%20%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="符号分号 sql 语句一般后面跟一个分号，有些不跟。 一般都跟 12mysql通过寻找终止分号而不是输入行的结束来决定语句在哪儿结束。（换句话说，mysql接受自由格式的输入：它收集输入行但直到看见分号才执行。）  提示符 &gt;   提示符 含义    mysql&gt; 准备好接受新命令。   -&gt; 等待多行命令的下一行。   ‘&gt; 等待下一行，等待以单引号(“’”)开始的字符串">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="f:\1=%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\3=%E6%95%B0%E6%8D%AE%E5%BA%93\mysql\mysql%E5%9F%BA%E7%A1%80\image-20231213094607758.png">
<meta property="article:published_time" content="2024-04-20T16:38:00.000Z">
<meta property="article:modified_time" content="2024-04-21T12:51:16.219Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="f:\1=%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\3=%E6%95%B0%E6%8D%AE%E5%BA%93\mysql\mysql%E5%9F%BA%E7%A1%80\image-20231213094607758.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sunshulei456.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-mysql/mysql 基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/21/mysql/mysql%20%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2024-04-20T16:38:00.000Z" itemprop="datePublished">2024-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      mysql 基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><ol>
<li><p>sql 语句一般后面跟一个分号，有些不跟。 一般都跟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql通过寻找终止分号而不是输入行的结束来决定语句在哪儿结束。（换句话说，mysql接受自由格式的输入：它收集输入行但直到看见分号才执行。）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="提示符"><a href="#提示符" class="headerlink" title="提示符 &gt;"></a>提示符 &gt;</h2><table>
<thead>
<tr>
<th><strong>提示符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>mysql&gt;</td>
<td>准备好接受新命令。</td>
</tr>
<tr>
<td>-&gt;</td>
<td>等待多行命令的下一行。</td>
</tr>
<tr>
<td>‘&gt;</td>
<td>等待下一行，等待以单引号(“’”)开始的字符串的结束。</td>
</tr>
<tr>
<td>“&gt;</td>
<td>等待下一行，等待以双引号(“””)开始的字符串的结束。</td>
</tr>
<tr>
<td>&#96;&gt;</td>
<td>等待下一行，等待以反斜点(‘&#96;’)开始的识别符的结束。</td>
</tr>
<tr>
<td>&#x2F;*&gt;</td>
<td>等待下一行，等待以&#x2F;*开始的注释的结束。</td>
</tr>
</tbody></table>
<h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql 不区分大小写</span><br><span class="line"></span><br><span class="line">1. 在Unix下，数据库名称是区分大小写的(不像SQL关键字)，因此你必须总是以menagerie访问数据库，而不能用Menagerie、MENAGERIE或其它一些变量。对表名也是这样的。</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">风格三种</span><br><span class="line"><span class="number">1.</span> 从‘#’字符从行尾。</span><br><span class="line"><span class="number">2.</span> 从‘-- ’序列到行尾。请注意‘-- ’(双破折号)注释风格要求第<span class="number">2</span>个破折号后面至少跟一个空格符(例如空格、tab、换行符等等)。该语法与标准SQL注释语法稍有不同，</span><br><span class="line"><span class="number">3.</span> 从<span class="comment">/*序列到后面的*/</span>序列。结束序列不一定在同一行中，因此该语法允许注释跨越多行</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在MySQL中，</span><br><span class="line">	数据库:对应数据目录中的目录。</span><br><span class="line">	表:  至少对应数据库目录中的一个文件(也可能是多个，取决于存储引擎)。</span><br></pre></td></tr></table></figure>

<h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">格式</span><br><span class="line">	指用单引号(‘&#x27;’)或双引号(‘&quot;’)引起来的字符序列</span><br><span class="line">案例</span><br><span class="line">	&#x27;a string&#x27;</span><br><span class="line">	&quot;another string&quot;</span><br><span class="line">特殊</span><br><span class="line">	1. 指定字符串使用的字符集</span><br><span class="line">	SELECT _latin1&#x27;string&#x27;;</span><br><span class="line">	SELECT _latin1&#x27;string&#x27; COLLATE latin1_danish_ci;</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">	1. 如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="&#x3D;&#x3D; 特殊字符"></a>&#x3D;&#x3D; 特殊字符</h3><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table>
<thead>
<tr>
<th>\0</th>
<th>ASCII 0(NUL)字符。</th>
</tr>
</thead>
<tbody><tr>
<td>&#39;</td>
<td>单引号(‘’’)。</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号(‘“’)。</td>
</tr>
<tr>
<td>\b</td>
<td>退格符。</td>
</tr>
<tr>
<td>\n</td>
<td>换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>回车符。</td>
</tr>
<tr>
<td>\t</td>
<td>tab字符。</td>
</tr>
<tr>
<td>\Z</td>
<td>ASCII  26(控制（Ctrl）-Z)。该字符可以编码为‘\Z’，以允许你解决在Windows中ASCII  26代表文件结尾这一问题。(如果你试图使用mysql <em>db_name</em> &lt;  <em>file_name</em>，ASCII 26会带来问题）。</td>
</tr>
<tr>
<td>\</td>
<td>反斜线(‘\’)字符。</td>
</tr>
<tr>
<td>%</td>
<td>‘%’字符。参见表后面的注解。</td>
</tr>
<tr>
<td>_</td>
<td>‘_’字符。参见表后面的注解。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. \%’和‘\_’序列用于搜索可能会解释为通配符的模式匹配环境中的‘%’和‘_’文字实例。参见12.3.1节，“字符串比较函数”。请注意如果你在其它环境中使用‘\%’或‘\_’，它们返回字符串‘\%’和‘\_’，而不是‘%’和‘_’。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符串中的引号"><a href="#字符串中的引号" class="headerlink" title="字符串中的引号"></a>字符串中的引号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在字符串内用 &#x27; 引用的 &#x27; 可以写成 &#x27;&#x27;。</span><br><span class="line">2. 在字符串内用 &quot; 引用的 &quot; 可以写成 &quot;&quot;</span><br><span class="line">3. 通用在字符前面加转义字符 \</span><br><span class="line">4. 在 &quot; 中引用 &#x27; , 在 &#x27; 中引用 &quot;  ，都不需要加引号	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="字符串中插入二进制数据"><a href="#字符串中插入二进制数据" class="headerlink" title="字符串中插入二进制数据"></a>字符串中插入二进制数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果你想要在字符串列内插入二进制数据(例如BLOB)，必须通过转义序列表示下面的字符：</span><br><span class="line"></span><br><span class="line">NUL  NUL字节(ASCII 0)。用‘\0’表示该字符(反斜线后面跟一个ASCII‘0’字符)。</span><br><span class="line">\  反斜线(ASCII 92)。用‘\\’表示该字符。 </span><br><span class="line">&#x27;  单引号(ASCII 39)。用‘\&#x27;’表示该字符。</span><br><span class="line">&quot;  双引号(ASCII 34)。用‘\&quot;’表示该字符。</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">整数： </span><br><span class="line">	用一系列阿拉伯数字表示。</span><br><span class="line">浮点数： </span><br><span class="line">	使用‘.’作为十进制间隔符。</span><br><span class="line">负数：	</span><br><span class="line">	0. 分为整数和浮点数 </span><br><span class="line">	1. 均可以在前面加一个‘-’来表示负值。</span><br><span class="line">	2. 整数可以用在浮点环境中；它被解释为与浮点数等效。</span><br><span class="line">	</span><br><span class="line">十六进制</span><br><span class="line">	1. 默认类型是字符串。如果想要确保该值作为数字处理，可以使用CAST(...AS UNSIGNED)：</span><br><span class="line">	2. 在数字上下文中，十六进制数如同整数(64位精度)。</span><br><span class="line">	   在字符串上下文，如同二进制字符串，每对十六进制数字被转换为一个字符</span><br><span class="line">	   SELECT x&#x27;4D7953514C&#x27;；   -&gt; &#x27;MySQL&#x27;</span><br><span class="line">	   SELECT 0xa+0； -&gt; 10</span><br><span class="line">	   SELECT 0x5061756c； -&gt; &#x27;Paul&#x27;</span><br><span class="line">   3. 需要前缀 0x, x</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 大小写的 true, false 都可以</span><br><span class="line">常量 TRUE=1</span><br><span class="line">常量 FALAE=0</span><br></pre></td></tr></table></figure>



<h2 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以使用b<span class="string">&#x27;value&#x27;</span>符号写位字段值。<span class="keyword">value</span>是一个用<span class="number">0</span>和<span class="number">1</span>写成的二进制值。</span><br><span class="line"></span><br><span class="line">位字段符号可以方便指定分配给BIT列的值：</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (b BIT(<span class="number">8</span>));</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SET</span> b <span class="operator">=</span> b<span class="string">&#x27;11111111&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SET</span> b <span class="operator">=</span> b<span class="string">&#x27;1010&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NULL</span> </span><br><span class="line">含义： 没有数据</span><br><span class="line">特点： 不同于数字类型的<span class="number">0</span>或字符串类型的空字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">含义</span><br><span class="line">	<span class="number">1.</span> 意味着“没有值”或“未知值”，且它被看作与众不同的值</span><br><span class="line">原酸	</span><br><span class="line">	<span class="number">1.</span> 不能使用算术比较 操作符例如<span class="operator">=</span>、<span class="operator">&lt;</span>或<span class="operator">!=</span>。</span><br></pre></td></tr></table></figure>





<h1 id="识别符"><a href="#识别符" class="headerlink" title="识别符"></a>识别符</h1><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 数据库、表、索引、列和别名是识别符</span><br><span class="line"></span><br><span class="line">特例</span><br><span class="line">1. 不可以包含ASCII 0或值为255的字节</span><br><span class="line">2. 不应以空格结尾</span><br><span class="line">3. 可能避免引号识别符</span><br><span class="line"></span><br><span class="line">保存</span><br><span class="line">1. 别符用Unicode(UTF8)保存。在.frm文件中保存的表定义的识别符和在mysql数据库中的授权表保存的识别符也用Unicode(UTF8)保存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">1. 可以引起来，也可以不引起来</span><br><span class="line">2. 如果识别符是一个保留字或包含特殊字符，无论何时使用，必须将它引起来</span><br><span class="line">	保留字：  参看 mysql 保留字</span><br><span class="line">	特殊字符：指那些当前字符集、‘_’和‘$’之外的文字数字字符集</span><br><span class="line">	</span><br><span class="line">例子</span><br><span class="line">	SELECT * FROM `select` WHERE `select`.id &gt; 100;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>识别符</strong></th>
<th><strong>最大长度(字节)</strong></th>
<th><strong>允许的字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据库</td>
<td>64</td>
<td>目录名允许的任何字符，不包括‘&#x2F;’、‘\’或者‘。’</td>
</tr>
<tr>
<td>表</td>
<td>64</td>
<td>文件名允许的任何字符，不包括‘&#x2F;’、‘\’或者‘。’</td>
</tr>
<tr>
<td>列</td>
<td>64</td>
<td>所有字符</td>
</tr>
<tr>
<td>索引</td>
<td>64</td>
<td>所有字符</td>
</tr>
<tr>
<td>别名</td>
<td>255</td>
<td>所有字符</td>
</tr>
</tbody></table>
<h2 id="大小写-1"><a href="#大小写-1" class="headerlink" title="大小写"></a>大小写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">数据库和数据库表</span><br><span class="line">1. mysql 大小写是否敏感取决于操作系统</span><br><span class="line">	大多数Unix中数据库名和表名对大小写敏感，</span><br><span class="line">	Windows中对大小写不敏感。</span><br><span class="line">	mac os x 基于Unix但使用默认文件系统类型(HFS+)，对大小写不敏感。然而，Mac OS X也支持UFS卷，该卷对大小写敏感，就像Unix一样】</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">2. 列、索引、存储子程序和触发器名、列的别名： </span><br><span class="line">	不区分平台， 对大小写不敏感。</span><br><span class="line">	</span><br><span class="line">注意</span><br><span class="line">1. 数据库名，表明应该统一规范，使用大写还是小写。最好是小写</span><br><span class="line">2. MySQL中如何在硬盘上保存和使用表名和数据库名由lower_case_tables_name系统变量确定，可以在启动mysqld时设置</span><br><span class="line">   参看【参数配置中的 lower_case_name】</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 滥用用户变量会导致程序难以理解及管理</span><br><span class="line">局部变量【       】： 函数/存储过程中使用 begin ... end 中使用  declare</span><br><span class="line">用户变量【当前用户有效】： set/select @</span><br><span class="line">系统变量【所有用户有效】:  set/select @@</span><br><span class="line">	会话变量</span><br><span class="line">	全局变量</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line">在调用存储过程时，</span><br><span class="line">  1. 以declare声明的变量都会被初始化为null。</span><br><span class="line">  2. 会话变量（即@开头的变量）则不会被再初始化，在一个会话内，只须初始化一次，之后在会话内都是对上一次计算的结果，就相当于在是这个会话内的全局变量。</span><br></pre></td></tr></table></figure>



<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">使用位置</span><br><span class="line">	局部变量一般用在sql语句块中，比如存储过程的begin/end。其作用域仅限于该语句块，在该语句块执行完毕后，局部变量就消失了</span><br><span class="line">语法</span><br><span class="line">	declare var_name [, var_name]... data_type [ DEFAULT value ];</span><br><span class="line">	datatype 为 MySQL 的数据类型【列类型】，如: int, float, date,varchar(length)</span><br><span class="line">	default  默认值</span><br><span class="line">	</span><br><span class="line">限制</span><br><span class="line">	1. 局部变量声明一定要放在存储过程体的开始：</span><br><span class="line">	2. </span><br><span class="line">赋值</span><br><span class="line">	# set语句既可以用于局部变量的赋值，也可以用于用户变量的申明并赋值。</span><br><span class="line">	SET 变量名 = 表达式值 [,variable_name = expression ...]</span><br><span class="line">	----------------------------</span><br><span class="line">	declare c int default 0;</span><br><span class="line">    set c=a+b;</span><br><span class="line">    select c as C;</span><br><span class="line">	</span><br><span class="line">	# </span><br><span class="line">	select col_name[,...] into var_name[,...] table_expr [where...];</span><br><span class="line">	--------------------------</span><br><span class="line">	declare v_employee_name varchar(100);</span><br><span class="line">    declare v_employee_salary decimal(8,4);</span><br><span class="line"></span><br><span class="line">    select employee_name, employee_salary</span><br><span class="line">    into v_employee_name, v_employee_salary</span><br><span class="line">    from employees</span><br><span class="line">    where employee_id=1;</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">用处</span><br><span class="line">	以先在用户变量中保存值然后在以后引用它；这样可以将值从一个语句传递到另一个语句</span><br><span class="line">生命周期：</span><br><span class="line">     #在客户端链接到数据库实例整个过程中用户变量都是有效的</span><br><span class="line">	个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放</span><br><span class="line">语法结构</span><br><span class="line">	@标识符</span><br><span class="line">标识符：</span><br><span class="line">	1. 大小写不敏感</span><br><span class="line">	2. 由当前字符集的文字数字字符、‘.’、‘_’和‘$’组成。 默认字符集是cp1252 (Latin1)。</span><br><span class="line">	3. 用mysqld的--default-character-set选项更改字符集</span><br><span class="line">特点</span><br><span class="line">	1. 如果使用没有初始化的变量，其值是NULL。即： 未分配的变量有一个值NULL，类型为字符串。</span><br><span class="line">	2. </span><br><span class="line"></span><br><span class="line">curd</span><br><span class="line">    # 设置用户变量 -- set 语句。 set可以使用=或:=作为分配符</span><br><span class="line">    set @name=lisi, @age=13;  </span><br><span class="line">    set @name:=lisi, @age:=13;</span><br><span class="line"></span><br><span class="line">    # 设置用户变量 -- 非 set 语句， 必须使用 := , 因为 = 作为比较符号了</span><br><span class="line">    SELECT @t2:=1,@t2;</span><br><span class="line">    </span><br><span class="line">    # 变量可以参与计算</span><br><span class="line">    SELECT @t1:=(@t2:=1)+@t3:=4,@t1;</span><br><span class="line">    </span><br><span class="line">危险：</span><br><span class="line">1. SELECT语句中，表达式发送到客户端后才进行计算。这说明在HAVING、GROUP BY或者ORDER BY子句中，不能使用包含SELECT列表中所设的变量的表达式</span><br><span class="line">	SELECT (@aa:=id) AS a，(@aa+3) AS b  from tbl_name HAVING b=5；</span><br><span class="line">	hvaing 使用了select 中的别名 b, ，使用@aa。不能按期望工作：@aa不包含当前行的值，而是前面所选的行的id值</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">------------</span><br><span class="line">【后续总结】</span><br><span class="line">用户变量可以用于表达式中。目前不包括明显需要文字值的上下文中，例如SELECT语句的LIMIT子句，或者LOAD DATA语句的IGNORE number LINES子句。</span><br><span class="line"></span><br><span class="line">如果使用没有初始化的变量，其值是NULL。</span><br><span class="line"></span><br><span class="line">如果用户变量分配了一个字符串值，其字符集和校对规则与该字符串的相同。用户变量的可压缩性（coercibility）是隐含的。(即为表列值的相同的可压缩性（coercibility）。</span><br><span class="line"></span><br><span class="line">注释：在SELECT语句中，表达式发送到客户端后才进行计算。这说明在HAVING、GROUP BY或者ORDER BY子句中，不能使用包含SELECT列表中所设的变量的表达式。例如，下面的语句不能按期望工作：</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT (@aa:=id) AS a，(@aa+3) AS b 从tbl_name HAVING b=5；</span><br><span class="line">HAVING子句中引用了SELECT列表中的表达式的别名，使用@aa。不能按期望工作：@aa不包含当前行的值，而是前面所选的行的id值。</span><br><span class="line"></span><br><span class="line">一般原则是不要在语句的一个部分为用户变量分配一个值而在同一语句的其它部分使用该变量。可能会得到期望的结果，但不能保证。</span><br><span class="line"></span><br><span class="line">设置变量并在同一语句中使用它的另一个问题是变量的默认结果的类型取决于语句前面的变量类型。下面的例子说明了该点：</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @a=&#x27;test&#x27;;</span><br><span class="line">mysql&gt; SELECT @a,(@a:=20) FROM tbl_name;</span><br><span class="line">对于该 SELECT语句，MySQL向客户端报告第1列是一个字符串，并且将@a的所有访问转换为字符串，即使@a在第2行中设置为一个数字。执行完SELECT语句后，@a被视为下一语句的一个数字。</span><br><span class="line"></span><br><span class="line">要想避免这种问题，要么不在同一个语句中设置并使用相同的变量，要么在使用前将变量设置为0、0.0或者&#x27;&#x27;以定义其类型。</span><br><span class="line"></span><br><span class="line">未分配的变量有一个值NULL，类型为字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">含义</span><br><span class="line">	1. 系统运行所需要的变量，比如从配置文件中加载的变量</span><br><span class="line">	2. 服务器运行时许多变量可以修改，而不用去重启服务器</span><br><span class="line">分类</span><br><span class="line">	全局系统变量：</span><br><span class="line">	    1. 全局变量的更改可以被访问该全局变量的任何客户端看见。然而，它只影响更改后连接的客户的从该全局变量初始化的相应会话变量。不影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。</span><br><span class="line">		2. 更改全局变量，必须具有SUPER权限。</span><br><span class="line">		</span><br><span class="line">	会话系统变量</span><br><span class="line">	    1. 服务器还为每个连接的客户端维护一系列会话变量，设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其它客户端的会话变量。</span><br><span class="line">	    2. </span><br><span class="line">	</span><br><span class="line">生命周期</span><br><span class="line">	1. 当服务器启动时，它将所有全局变量初始化为默认值。[默认值可以在选项文件中或在命令行中指定的选项进行更改]</span><br><span class="line">语法</span><br><span class="line">#============== 新增，修改</span><br><span class="line">set global 变量名=变量值；</span><br><span class="line">set @@global.变量名=变量值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 默认 session </span><br><span class="line">set session buffer_size=10;</span><br><span class="line">set @@session.buffer_size=10;</span><br><span class="line">set buffer_size=10;</span><br><span class="line"></span><br><span class="line"># local 是 session 的同义词</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#============== 查询</span><br><span class="line"></span><br><span class="line">-- 全局系统变量</span><br><span class="line">select @@global.buffer_size</span><br><span class="line"></span><br><span class="line">-- 会话系统变量</span><br><span class="line">select @@session.buffer_size</span><br><span class="line"></span><br><span class="line">-- 省略。 先从 session 中找， 如果找不到再从 global 中找</span><br><span class="line">select @@buffer_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#============= 等价</span><br><span class="line">show  global variables like &#x27;buffer_size&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="结构式系统变量"><a href="#结构式系统变量" class="headerlink" title="结构式系统变量"></a>结构式系统变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没看懂</span><br></pre></td></tr></table></figure>



<h1 id="列类型"><a href="#列类型" class="headerlink" title="列类型"></a>列类型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">众多列类型： 带符号/无符号整数，1、2、3、4、8字节长，FLOAT，DOUBLE，CHAR，VARCHAR，TEXT，BLOB，DATE，TIME，DATETIME，TIMESTAMP，YEAR，SET，ENUM，以及OpenGIS空间类型。请参见第11章：列类型。 </span><br><span class="line"></span><br><span class="line">定长和可变长度记录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MySQL支持所有标准SQL数值数据类型</span><br><span class="line">	严格数据类型[整型]： integer, samllint, decimal, numeric</span><br><span class="line">	近似数据类型[小数]： float, real, double percision</span><br><span class="line">	</span><br><span class="line">大小</span><br><span class="line">计算公式： 最大值 max= 2 ^ （字节数*4）</span><br><span class="line">    1. 无符号：最大值[max-1, 因为有个 0] ， 最小值[0]</span><br><span class="line">    2. 有符号：max/2,  最大值[max/2-1, 因为有个 0] ， 最小值[max/2]</span><br><span class="line">    </span><br><span class="line">显示宽度：</span><br><span class="line">    介绍： </span><br><span class="line">        类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4)) </span><br><span class="line">    作用：</span><br><span class="line">        1. 值的实际位数小于指定的值的位数的时候， 会在左侧使用 0 填充宽度 </span><br><span class="line">          声明为INT(5) ZEROFILL的列，值4检索为00004</span><br><span class="line">        2. 显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。 </span><br><span class="line">符号</span><br><span class="line">    语法： 所有整数类型可以有一个可选(非标准)属性UNSIGNED</span><br><span class="line">    使用： 列内只允许非负数和该列需要较大的上限数值范围时可以使用无符号值， 防止负值保存到列中</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">1. 一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>字节</strong></th>
<th></th>
<th>有符号&#x2F;无符号</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>tiny_int</td>
<td></td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>small_int</td>
<td></td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>medium_int</td>
<td></td>
</tr>
<tr>
<td>INT&#x2F;INTEGER</td>
<td>4</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>big_int</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">非标语法</span><br><span class="line">	FLOAT(M,D)</span><br><span class="line">	REAL(M,D)</span><br><span class="line">	DOUBLE PRECISION(M,D)</span><br><span class="line">	-- “(M,D)”表示该值一共显示M位整数，其中D位位于小数点后面</span><br><span class="line">	-- D 默认是 0， 可省略</span><br><span class="line">	DECIMAL(M, D)</span><br><span class="line">	NUMERIC</span><br><span class="line">	-- M 默认是 10， D 默认是 0,  可省略</span><br><span class="line">	</span><br><span class="line">案例使用</span><br><span class="line">	FLOAT(7,4)的一个列可以显示为-999.9999</span><br><span class="line">	FLOAT(7,4)列内插入999.00009，近似结果是999.0001。 【MySQL保存值时进行四舍五入】</span><br><span class="line">	</span><br><span class="line">注意</span><br><span class="line">	1. 同义词： double == double precision , real == double precision </span><br><span class="line">		除非SQL服务器模式包括REAL_AS_FLOAT选项。</span><br><span class="line">		</span><br><span class="line">精确精度		</span><br><span class="line">含义： </span><br><span class="line">	保存必须为确切精度的值，例如货币数据。当声明该类型的列时，可以(并且通常要)指定精度和标度；例如：</span><br><span class="line">	salary DECIMAL(5,2) ： 5是精度，2是标度。精度表示保存值的主要位数，标度表示小数点后面可以保存的位数。</span><br><span class="line"></span><br><span class="line">待总结</span><br><span class="line">	DECIMAL或NUMERIC的最大位数是65，但具体的DECIMAL或NUMERIC列的实际范围受具体列的精度或标度约束。如果此类列分配的值小数点后面的位数超过指定的标度允许的范围，值被转换为该标度。(具体操作与操作系统有关，但一般结果均被截取到允许的位数）。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节单精度， 0到23</td>
<td>近似精度</td>
</tr>
<tr>
<td>double</td>
<td>8字节双精度， 24到53</td>
<td>近似精度</td>
</tr>
<tr>
<td>decimal</td>
<td>最大位数是65</td>
<td>精确精度</td>
</tr>
<tr>
<td>numeric</td>
<td>最大位数是65</td>
<td>精确精度</td>
</tr>
</tbody></table>
<h3 id="bit位"><a href="#bit位" class="headerlink" title="bit位"></a>bit位</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用</span><br><span class="line">	<span class="number">1.</span> 可用来保存位字段值，【参看字面量<span class="comment">--位字段】 </span></span><br><span class="line">语法结构</span><br><span class="line">	BIT(M)类型允许存储M位值。</span><br><span class="line">	M： 范围为<span class="number">1</span>到<span class="number">64</span></span><br><span class="line">特点：</span><br><span class="line"><span class="number">1.</span> 如果为BIT(M)列分配的值的长度小于M位，在值的左边用<span class="number">0</span>填充。</span><br><span class="line">  例如，为BIT(<span class="number">6</span>)列分配一个值b<span class="string">&#x27;101&#x27;</span>，其效果与分配b<span class="string">&#x27;000101&#x27;</span>相同。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sql裁剪"><a href="#sql裁剪" class="headerlink" title="sql裁剪"></a>sql裁剪</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line">	当要在一个数值列内保存一个超出该列允许范围的值时</span><br><span class="line">mysql 动作</span><br><span class="line">	MySQL的操作取决于此时有效的SQL模式。</span><br><span class="line">	1. 如果模式未设置，MySQL将值裁剪到范围的相应端点，并保存裁减好的值。</span><br><span class="line">	2. 如果模式设置为traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据SQL标准插入会失败</span><br><span class="line">	</span><br><span class="line">案例</span><br><span class="line">	如果INT列是UNSIGNED，列范围的大小相同，但其端点会变为到0和4294967295。如果你试图保存-9999999999和9999999999，以非严格模式保存到列中的值是0和4294967296。</span><br><span class="line">	如果在浮点或定点列中分配的值超过指定(或默认)精度和标度规定的范围，MySQL以非严格模式保存表示范围相应端点的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h2><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line"><span class="number">1.</span> 不要使用两位格式的年份</span><br><span class="line"></span><br><span class="line">格式字符串</span><br><span class="line"> <span class="number">1.</span> 年份的格式可以用 YY， 但是不建议用</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">时间字符串解析    </span><br><span class="line">  datatime ：YYYY-MM-DD HH:MM:SS </span><br><span class="line">  date: YYYY-MM-DD</span><br><span class="line">  <span class="number">1.</span> 允许不严格的语法：任何标点符都可以用做日期部分或时间部分之间的间割符。</span><br><span class="line">  例如，<span class="string">&#x27;98-12-31 11:30:45&#x27;</span>、<span class="string">&#x27;98.12.31 11+30+45&#x27;</span>、<span class="string">&#x27;98/12/31 11*30*45&#x27;</span>和<span class="string">&#x27;98@12@31 11^30^45&#x27;</span>是等价的。</span><br><span class="line">  <span class="number">2.</span> 对于取消分割符的字符串，只能解析年份是 YYYY 格式的</span><br><span class="line">   <span class="number">19970523091528</span>  被解释为<span class="string">&#x27;1997-05-23 09:15:28&#x27;</span></span><br><span class="line">   <span class="number">19970523</span> 被解释为 <span class="string">&#x27;1997-05-23&#x27;</span>，</span><br><span class="line">   <span class="number">971332</span> 是不合法的(它有一个没有意义的月和日部分)，将变为<span class="string">&#x27;0000-00-00 。</span></span><br><span class="line"><span class="string">  3. 无效的时间类型日期，会被转换为对应的&quot;零值&quot;</span></span><br><span class="line"><span class="string">  4. 月，日， 时分秒，不足两位的，可以不用指定两位</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="number">1979</span>-<span class="number">6</span>-<span class="number">9</span><span class="string">&#x27;与&#x27;</span><span class="number">1979</span>-<span class="number">06</span>-09<span class="string">&#x27;是相同的</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="number">1979</span>-<span class="number">10</span>-<span class="number">30</span> <span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span><span class="string">&#x27;与&#x27;</span><span class="number">1979</span>-<span class="number">10</span>-<span class="number">30</span> <span class="number">01</span>:<span class="number">02</span>:<span class="number">03</span><span class="string">&#x27;相同。</span></span><br><span class="line"><span class="string">  5. 根据字符串长度进行切割，数字值应为6、8、12或者14位长,从左向右解释字符串内出现的各部分，以发现年、月、日、小时、分和秒值。</span></span><br><span class="line"><span class="string">    如果一个数值是 8 或 14 位长，则假定为YYYYMMDD或YYYYMMDDHHMMSS格式，前4位数表示年。</span></span><br><span class="line"><span class="string">    如果数字是 6 或 12 位长，则假定为YYMMDD或YYMMDDHHMMSS格式，前2位数表示年。</span></span><br><span class="line"><span class="string">    其它数字被解释为仿佛用零填充到了最近的长度。</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="number">9903</span><span class="string">&#x27; 认为它表示1999年3月，MySQL将在你的表内插入一个“零”日期值。这是因为年和月值是99和03，但日部分完全丢失，因此该值不是一个合法的日期, 合法的应该是 &#x27;</span><span class="number">990300</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">   6. 值&#x27;</span><span class="number">10</span>:<span class="number">11</span>:<span class="number">12</span><span class="string">&#x27;由于‘:’间割符看上去可能象时间值，但如果用于日期上下文值则被解释为年&#x27;</span><span class="number">2010</span>-<span class="number">11</span>-<span class="number">12</span><span class="string">&#x27;。值&#x27;</span><span class="number">10</span>:<span class="number">45</span>:<span class="number">15</span><span class="string">&#x27;被转换为&#x27;</span><span class="number">0000</span>-<span class="number">00</span>-<span class="number">00</span><span class="string">&#x27;因为&#x27;</span><span class="number">45</span><span class="string">&#x27;不是合法月。</span></span><br><span class="line"><span class="string">   7. 非严格模式，MySQL服务器只对日期的合法性进行基本检查：年、月和日的范围分别是1000到9999、00到12和00到31。任何包含超出这些范围的部分的日期被转换成&#x27;</span><span class="number">0000</span>-<span class="number">00</span>-<span class="number">00</span><span class="string">&#x27;。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">两位年份转换规则：</span></span><br><span class="line"><span class="string">1. 00-69范围的年值转换为2000-2069。</span></span><br><span class="line"><span class="string">2. 70-99范围的年值转换为1970-1999。</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">时间类型转换</span></span><br><span class="line"><span class="string">1. 如果你为一个DATETIME或TIMESTAMP对象分配一个DATE值，结果值的时间部分被设置为&#x27;</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span><span class="string">&#x27;，因为DATE值未包含时间信息。</span></span><br><span class="line"><span class="string">2. 如果你为一个DATE对象分配一个DATETIME或TIMESTAMP值，结果值的时间部分被删除，因为DATE值未包含时间信息。</span></span><br><span class="line"><span class="string">3. 所以使用相同的格式指定时间值，不要乱转换时间戳， </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">总结       </span></span><br><span class="line"><span class="string">  1. 使用严格模式： 非法日期不被接受，并且不转换。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	</span></span><br></pre></td></tr></table></figure>

<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">时间字符串格式</span><br><span class="line"></span><br><span class="line">格式</span><br><span class="line">	<span class="number">1.</span>  <span class="string">&#x27;D HH:MM:SS.fraction&#x27;</span>格式的字符串。还可以使用下面任何一种“非严格”语法：<span class="string">&#x27;HH:MM:SS.fraction&#x27;</span>、<span class="string">&#x27;HH:MM:SS&#x27;</span>、<span class="string">&#x27;HH:MM&#x27;</span>、<span class="string">&#x27;D HH:MM:SS&#x27;</span>、<span class="string">&#x27;D HH:MM&#x27;</span>、<span class="string">&#x27;D HH&#x27;</span>或<span class="string">&#x27;SS&#x27;</span>。这里D表示日，可以取<span class="number">0</span>到<span class="number">34</span>之间的值。请注意MySQL还不保存分数。</span><br><span class="line">	<span class="number">2.</span> 无分隔符的 <span class="string">&#x27;HHMMSS&#x27;</span>格式</span><br><span class="line">	例如，<span class="string">&#x27;101112&#x27;</span>被理解为<span class="string">&#x27;10:11:12&#x27;</span>，但<span class="string">&#x27;109712&#x27;</span>是不合法的(它有一个没有意义的分钟部分)，将变为<span class="string">&#x27;00:00:00&#x27;</span>。</span><br><span class="line">	<span class="number">3.</span> 含有时间分隔符的 HH:MM:SS </span><br><span class="line">	如果时、分或者秒值小于<span class="number">10</span>，则不需要指定两位数。<span class="string">&#x27;8:3:2&#x27;</span>与<span class="string">&#x27;08:03:02&#x27;</span>相同。</span><br><span class="line">	<span class="number">4.</span> 无分隔符的其他模式</span><br><span class="line">	a. 没有冒号，MySQL解释值时假定最右边的两位表示秒(MySQL解释TIME值为过去的时间而不是当天的时间）: 可能认为<span class="string">&#x27;1112&#x27;</span>和<span class="number">1112</span>表示<span class="string">&#x27;11:12:00&#x27;</span>(<span class="number">11</span>点过<span class="number">12</span>分)，但MySQL将它们解释为<span class="string">&#x27;00:11:12&#x27;</span>(<span class="number">11</span>分，<span class="number">12</span> 秒)。</span><br><span class="line">	b. 含有冒汗，TIME值中使用冒号则肯定被看作当天的时间。也就是说，<span class="string">&#x27;11:12&#x27;</span>表示<span class="string">&#x27;11:12:00&#x27;</span>，而不是<span class="string">&#x27;00:11:12&#x27;</span></span><br><span class="line">	<span class="number">5</span>、无效TIME值被转换为<span class="string">&#x27;00:00:00&#x27;</span>。</span><br><span class="line">      请注意由于<span class="string">&#x27;00:00:00&#x27;</span>本身是一个合法TIME值，只从表内保存的一个<span class="string">&#x27;00:00:00&#x27;</span>值还不能说出原来的值是 <span class="string">&#x27;00:00:00&#x27;</span>还是不合法的值。</span><br><span class="line">                                 </span><br><span class="line">                                 </span><br><span class="line">time 字符串截断</span><br><span class="line">  <span class="number">1.</span> 超出TIME范围但合法的值被裁为范围最接近的端点。例如，<span class="string">&#x27;-850:00:00&#x27;</span>和<span class="string">&#x27;850:00:00&#x27;</span>被转换为<span class="string">&#x27;-838:59:59&#x27;</span>和<span class="string">&#x27;838:59:59&#x27;</span> </span><br><span class="line">                                 </span><br></pre></td></tr></table></figure>

<h3 id="年"><a href="#年" class="headerlink" title="年"></a>年</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line">	YEAR类型是一个单字节类型用于表示年</span><br><span class="line">格式</span><br><span class="line">·         四位字符串，范围为&#x27;1901&#x27;到&#x27;2155&#x27;。</span><br><span class="line">·         四位数字，范围为1901到2155。</span><br><span class="line">·         函数返回的结果，其值适合YEAR上下文，例如NOW()。</span><br><span class="line">-- 下面的都不建议用： MySQL内部使用四位来保存年。</span><br><span class="line">·         两位字符串，范围为&#x27;00&#x27;到&#x27;99&#x27;。&#x27;00&#x27;到&#x27;69&#x27;和&#x27;70&#x27;到&#x27;99&#x27;范围的值被转换为2000到2069和1970到1999范围的YEAR值。</span><br><span class="line">·         两位整数，范围为1到99。1到69和70到99范围的值被转换为2001到2069和1970到1999范围的YEAR值。请注意两位整数范围与两位字符串范围稍有不同，因为你不能直接将零指定为数字并将它解释为2000。你必须将它指定为一个字符串&#x27;0&#x27;或&#x27;00&#x27;或它被解释为0000。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">年-字符串转换</span><br><span class="line">1. 非法YEAR值被转换为0000。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2000年(Y2K) 问题</span><br><span class="line">1. MySQL本身对于2000年(Y2K)是安全的， MySQL本身对于2000年(Y2K)是安全的</span><br><span class="line">2. 对于年份只有 2 个的年份，mysql 会做出自己猜测，但是不一定符合业务或者正确使用，所以【请使用四位年份】</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table>
<thead>
<tr>
<th><strong>列类型</strong></th>
<th>零值</th>
<th>检索格式</th>
<th>支持范围</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>‘0000-00-00 00:00:00’</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>‘1000-01-01 00:00:00’到’9999-12-31 23:59:59’</td>
</tr>
<tr>
<td>DATE</td>
<td>‘0000-00-00’</td>
<td>YYYY-MM-DD</td>
<td>‘1000-01-01’到 ‘9999-12-31’</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>00000000000000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TIME</td>
<td>‘00:00:00’</td>
<td>‘HH:MM:SS’</td>
<td>从’-838:59:59’到’838:59:59’</td>
</tr>
<tr>
<td>YEAR</td>
<td>0000</td>
<td>YYYY</td>
<td>1901到2155</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 要想计算用于保存具体CHAR、VARCHAR或者TEXT列值的字节数，需要考虑该列使用的字符集。在具体情况中，当使用Unicode时，必须记住所有Unicode字符使用相同的字节数。为了细分用于不同类Unicode字符使用的存储，</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>类型</th>
<th>观察</th>
<th>存储或检索过程</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>char</td>
<td>不进行大小写转换</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>varchar</td>
<td>不进行大小写转换</td>
</tr>
<tr>
<td>BINARY</td>
<td>binary</td>
<td></td>
</tr>
<tr>
<td>VARBINARY</td>
<td>var-binary</td>
<td></td>
</tr>
<tr>
<td>BLOB</td>
<td>blob</td>
<td></td>
</tr>
<tr>
<td>TEXT</td>
<td>text</td>
<td></td>
</tr>
<tr>
<td>ENUM</td>
<td>enum</td>
<td></td>
</tr>
<tr>
<td>SET</td>
<td>set</td>
<td></td>
</tr>
</tbody></table>
<h3 id="char-和-varchar"><a href="#char-和-varchar" class="headerlink" title="char 和 varchar"></a>char 和 varchar</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">1. 声明的长度就是你想要保存的最大字符长度</span><br><span class="line"></span><br><span class="line">裁剪</span><br><span class="line">	1、分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。</span><br><span class="line">		a. 如果被裁掉的字符不是空格，则会产生一条警告。</span><br><span class="line">		b. 如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入</span><br><span class="line">		注意： 严格模式下，不会进行裁剪，会直接进行报错</span><br><span class="line">		</span><br><span class="line">待补充</span><br><span class="line">对于尾部填充字符被裁剪掉或比较时将它们忽视掉的情形，如果列的索引需要唯一的值，在列内插入一个只是填充字符数不同的值将会造成复制键值错误。</span><br><span class="line">CHAR BYTE是CHAR BINARY的别名。这是为了保证兼容性。</span><br><span class="line">ASCII属性为CHAR列分配latin1字符集。UNICODE属性分配ucs2字符集</span><br></pre></td></tr></table></figure>

<ul>
<li><p>区别</p>
<table>
<thead>
<tr>
<th></th>
<th>char</th>
<th>varchar</th>
</tr>
</thead>
<tbody><tr>
<td>长度</td>
<td>声明时的长度</td>
<td>保存需要的字符，根据字符实际的长度开辟长度</td>
</tr>
<tr>
<td>检索保存</td>
<td>当保存CHAR值时，在它们的右边填充空格以达到指定的长度。<br />当检索到CHAR值时，尾部的空格被删除掉</td>
<td>保存和检索时尾部的空格仍保留，符合标准SQL <br />不进行填充</td>
</tr>
<tr>
<td>比较</td>
<td>不需要考虑任何尾部空格</td>
<td>不需要考虑任何尾部空格</td>
</tr>
</tbody></table>
</li>
<li><p>使用</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th>CHAR(4)</th>
<th><strong>存储需求</strong></th>
<th>VARCHAR(4)</th>
<th><strong>存储需求</strong></th>
</tr>
</thead>
<tbody><tr>
<td>‘’</td>
<td>‘  ‘</td>
<td>4个字节</td>
<td>‘’</td>
<td>1个字节</td>
</tr>
<tr>
<td>‘ab’</td>
<td>‘ab ‘</td>
<td>4个字节</td>
<td>‘ab ‘</td>
<td>3个字节</td>
</tr>
<tr>
<td>‘abcd’</td>
<td>‘abcd’</td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
<tr>
<td>‘abcdefgh’</td>
<td>‘abcd’</td>
<td>4个字节</td>
<td>‘abcd’</td>
<td>5个字节</td>
</tr>
</tbody></table>
<h3 id="binary-和-var-binary"><a href="#binary-和-var-binary" class="headerlink" title="binary 和 var-binary"></a>binary 和 var-binary</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line">	1. bianry 是二进制字符串，内容只能有0和1组成。说明没有字符集，并且排序和比较基于列值字节的数值值。</span><br><span class="line">	2. 注意：</span><br><span class="line">	3. 长度为字节长度而不是字符长度</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>





<h3 id="blob-和-text"><a href="#blob-和-text" class="headerlink" title="blob 和 text"></a>blob 和 text</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blob </span><br><span class="line">介绍</span><br><span class="line">	二进制大文件对象</span><br><span class="line">种类</span><br><span class="line">	tiny-blob, blob</span><br></pre></td></tr></table></figure>



<ul>
<li><p>类型</p>
<table>
<thead>
<tr>
<th></th>
<th>blob</th>
<th>text</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>二进制字符串（字节字符串）</td>
<td>非二进制字符串(字符字符串)</td>
</tr>
<tr>
<td>比较</td>
<td>BLOB列没有字符集，并且排序和比较基于列值字节的数值值</td>
<td>1. TEXT列有一个字符集，并且根据字符集的 校对规则对值进行排序和比较。<br />2. 比较时将用空格对TEXT进行扩充以适合比较的对象，正如CHAR和VARCHAR</td>
</tr>
<tr>
<td>存储和检索</td>
<td>1. 不存在大小写<br />2. 不删除尾部空格<br />3. 必须指定索引前缀的长度<br />4. 不能有默认值<br />5.</td>
<td>不存在大小写</td>
</tr>
<tr>
<td>理解</td>
<td>足够大的 var-binary</td>
<td>足够大的 varchar</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​	</p>
</li>
<li><p>区别</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>tiny-blob</td>
<td></td>
</tr>
<tr>
<td>blob</td>
<td></td>
</tr>
<tr>
<td>medium-blob</td>
<td></td>
</tr>
<tr>
<td>long-blob</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>tiny-text</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td></td>
</tr>
<tr>
<td>medium-text</td>
<td></td>
</tr>
<tr>
<td>long-text</td>
<td></td>
</tr>
</tbody></table>
<h2 id="枚举集合"><a href="#枚举集合" class="headerlink" title="枚举集合"></a>枚举集合</h2><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line">	1. 一个字符串对象， 用来枚举对象</span><br><span class="line">	2. 用于一个字段配以一个枚举值</span><br></pre></td></tr></table></figure>



<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line">	set: 计算机中用于存储无序且唯一的元素集合。</span><br><span class="line">	mysql_set:   用于一个字段配置多个枚举值</span><br><span class="line">使用</span><br><span class="line">	该类型的字段可以包含0个或多个成员，但成员个数的上限为64。设置字段值时，可以取 取值范围内的 0 个或多个值。</span><br><span class="line">	该类型的字段，能包含多个成员。上为64个</span><br><span class="line">特点</span><br><span class="line">	1. 插入的数据有重复值。会自动去重</span><br><span class="line">		下面的 插入(&#x27;A,B,B&#x27;) 得到的是 A,B</span><br><span class="line">	2. 向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误</span><br><span class="line">		下面的 插入(&#x27;A,B,D&#x27;) 会报错</span><br><span class="line">	3. 当创建表时，SET成员值的尾部空格将自动被删除</span><br><span class="line">	4. 大小写：</span><br><span class="line">		使用定义的时候指定的大小写</span><br><span class="line">	5. SET值按数字顺序排序。NULL值排在非NULL SET值的前面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">占用空间</span><br><span class="line">	根据初始化的成员个数来计算的， 8个成员一个字节，最多有 8 个字节</span><br><span class="line">	</span><br><span class="line">案例1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例2</span><br><span class="line">1. 用数字保存SET值</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>案例1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line">CREATE TABLE test_set(</span><br><span class="line">s SET (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#向表中插入数据： 插入的数据必须是前面指定的</span><br><span class="line">INSERT INTO test_set (s) VALUES (&#x27;A&#x27;), (&#x27;A,B&#x27;);</span><br><span class="line"></span><br><span class="line"># 查询</span><br><span class="line">SELECT * FROM test_set;</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A，B</span><br></pre></td></tr></table></figure>



<ul>
<li><p>案例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 如果给 set 列分配了 9 ，其二进制形式为1001，因此第1个和第4个SET值成员&#x27;a&#x27;和&#x27;d&#x27;被选择，结果值为 &#x27;a,d&#x27;。</span><br><span class="line">？？？？</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>SET<strong>成员</strong></th>
<th><strong>十进制值</strong></th>
<th><strong>二进制值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>‘a’</td>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>‘b’</td>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>‘c’</td>
<td>4</td>
<td>0100</td>
</tr>
<tr>
<td>‘d’</td>
<td>8</td>
<td>1000</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="空间数据类型"><a href="#空间数据类型" class="headerlink" title="空间数据类型"></a>空间数据类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION: 用于存储空间数据（地理信息、几何图形等）。</span><br></pre></td></tr></table></figure>



<h2 id="列存储汇总"><a href="#列存储汇总" class="headerlink" title="列存储汇总"></a>列存储汇总</h2><h3 id="数值-1"><a href="#数值-1" class="headerlink" title="数值"></a>数值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重点： </span><br><span class="line">	[int] 4 字节</span><br><span class="line">	float 4/8</span><br><span class="line">	double 8</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>列类型</strong></th>
<th><strong>存储需求</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2个字节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3个字节</td>
</tr>
<tr>
<td>INT, INTEGER</td>
<td>4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8个字节</td>
</tr>
<tr>
<td>FLOAT(<em>p</em>)</td>
<td>如果0 &lt;&#x3D; <em>p</em> &lt;&#x3D;  24为4个字节, 如果25 &lt;&#x3D;  <em>p</em> &lt;&#x3D;  53为8个字节</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4个字节</td>
</tr>
<tr>
<td>DOUBLE [PRECISION], item REAL</td>
<td>8个字节</td>
</tr>
<tr>
<td>DECIMAL(<em>M</em>,<em>D</em>)<br />NUMERIC(<em>M</em>,<em>D</em>)</td>
<td>变长；参见下面的讨论<br />如果M&gt;D，为M+2否则为D+2, 依赖于 M 和 D 的值</td>
</tr>
<tr>
<td>BIT(<em>M</em>)</td>
<td>大约(<em>M</em>+7)&#x2F;8个字节</td>
</tr>
</tbody></table>
<p><img src="F:\1=学习笔记\3=数据库\mysql\mysql基础\image-20231213094607758.png" alt="image-20231213094607758"></p>
<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><table>
<thead>
<tr>
<th><strong>列类型</strong></th>
<th><strong>存储需求</strong></th>
<th></th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3个字节</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01&#x2F;9999-12-31</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8个字节</td>
<td>YYYY-MM-DD hh:mm:ss</td>
<td>‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4个字节</td>
<td>YYYY-MM-DD hh:mm:s</td>
<td>‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC</td>
</tr>
<tr>
<td>TIME</td>
<td>3个字节</td>
<td>HH:MM:SS</td>
<td>结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07 ‘-838:59:59’&#x2F;‘838:59:59’</td>
</tr>
<tr>
<td>YEAR</td>
<td>1个字节</td>
<td>YYYY</td>
<td>1901&#x2F;2155</td>
</tr>
</tbody></table>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>L： 每个类型的存储需求取决于列值的实际长度</li>
</ul>
<table>
<thead>
<tr>
<th><strong>列类型</strong></th>
<th><strong>存储需求</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(<em>M</em>)</td>
<td>M个字符，0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 255</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR(<em>M</em>)</td>
<td>M个字符，其中<em>L</em>  &lt;&#x3D; <em>M</em> 且0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 65535(参见下面的注释) 变长字符串</td>
<td></td>
</tr>
<tr>
<td>BINARY(<em>M</em>)</td>
<td><em>M</em>个字节，0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 255</td>
<td></td>
</tr>
<tr>
<td>VARBINARY(<em>M</em>)</td>
<td><em>L</em>+1个字节，其中<em>L</em>  &lt;&#x3D; <em>M</em> 且0 &lt;&#x3D; <em>M</em>  &lt;&#x3D; 255</td>
<td></td>
</tr>
<tr>
<td>TINYBLOB, TINYTEXT</td>
<td><em>L</em>+1个字节，其中<em>L</em>  &lt; 28</td>
<td>不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td>BLOB, TEXT</td>
<td><em>L</em>+2个字节，其中<em>L</em>  &lt; 216</td>
<td>二进制形式的长文本数据， 长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB, MEDIUMTEXT</td>
<td><em>L</em>+3个字节，其中<em>L</em>  &lt; 224</td>
<td>可变类型</td>
</tr>
<tr>
<td>LONGBLOB, LONGTEXT</td>
<td><em>L</em>+4个字节，其中<em>L</em>  &lt; 232</td>
<td></td>
</tr>
<tr>
<td>ENUM(‘<em>value1</em>‘,’<em>value2</em>‘,…)</td>
<td>1或2个字节，取决于枚举值的个数(最多65,535个值)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="列类型选择"><a href="#列类型选择" class="headerlink" title="列类型选择"></a>列类型选择</h2><ul>
<li><p>为了优化存储，在任何情况下均应使用最精确的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用精度为65位十进制数(基于10)对DECIMAL 列进行所有基本计算(+、-、*、/)。参见11.1.1节，“数值类型概述”。</span><br><span class="line"></span><br><span class="line">使用双精度操作对DECIMAL值进行计算。如果准确度不是太重要或如果速度为最高优先级，DOUBLE类型即足够了。为了达到高精度，可以转换到保存在BIGINT中的定点类型。这样可以用64位整数进行所有计算，根据需要将结果转换回浮点值。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="&#x3D;&#x3D; 数据库操作"></a>&#x3D;&#x3D; 数据库操作</h1><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">元数据操作</span><br><span class="line">create</span><br><span class="line">drop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可以省略的</span><br><span class="line">在语法介绍中，方括号（“[”和“]”）用于指明可选字或子句。例如，在下面的语句中，IF EXISTS是可选的： </span><br><span class="line">DROP TABLE [IF EXISTS] tbl_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多选一</span><br><span class="line">当某一语法成分由多个可选项组成时，可选项应用竖线“|”分开。当可能选择一组选择中的某一成员时，可选项将列在方括号（“[”和“]”）</span><br><span class="line">TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</span><br><span class="line"></span><br><span class="line"># 必选则一个</span><br><span class="line">当必须选择一组选择中的某一成员时，可选项将列在大括号（“&#123;”和“&#125;”）中。</span><br><span class="line">&#123;DESCRIBE | DESC&#125; tbl_name [col_name | wild]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">省略号（…）表明省略了语句的某一选择，通常是为了提供复杂语法的简短表述。</span><br><span class="line">	INSERT ... SELECT是后跟SLECT语句的INSERT语句的简短形式。</span><br><span class="line">省略号还能指明语句的前部分语法元素可重复。</span><br><span class="line">	RESET reset_option [,reset_option] ...</span><br></pre></td></tr></table></figure>

<ul>
<li>数据定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">在MySQL中，数据定义（Data Definition）指的是定义数据库、表格、列和相关数据库对象的过程。这包括创建、修改和删除数据库中的数据结构。常见的数据定义操作包括以下几种：</span><br><span class="line"></span><br><span class="line">1. **创建数据库（CREATE DATABASE）**：用于创建新的数据库。</span><br><span class="line"></span><br><span class="line">2. **创建表格（CREATE TABLE）**：用于在数据库中创建新的表格，指定表格的列、数据类型、约束条件等。</span><br><span class="line"></span><br><span class="line">3. **修改表格结构（ALTER TABLE）**：用于修改现有表格的结构，如添加、删除、修改列，添加索引等。</span><br><span class="line"></span><br><span class="line">4. **删除表格（DROP TABLE）**：用于从数据库中删除不再需要的表格及其相关数据。</span><br><span class="line"></span><br><span class="line">5. **创建索引（CREATE INDEX）**：用于在表格的列上创建索引，以提高数据检索效率。</span><br><span class="line"></span><br><span class="line">6. **定义视图（CREATE VIEW）**：用于创建虚拟的表格视图，使用户可以以特定的方式查看数据，而不实际修改原始表格。</span><br><span class="line"></span><br><span class="line">7. **定义存储过程和函数（CREATE PROCEDURE / CREATE FUNCTION）**：用于创建可在数据库中执行的存储过程和函数，以便在需要时重复使用特定的操作或计算。</span><br><span class="line"></span><br><span class="line">8. **定义触发器（CREATE TRIGGER）**：用于在特定的数据库事件（如插入、更新、删除等）发生时自动触发执行特定的操作。</span><br><span class="line"></span><br><span class="line">数据定义操作是数据库管理的重要部分，它定义了数据库中存储数据的结构和规则，确保数据的一致性、完整性和安全性。</span><br></pre></td></tr></table></figure>





<h2 id="表元数据"><a href="#表元数据" class="headerlink" title="表元数据"></a>表元数据</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">    [USING index_type]</span><br><span class="line">    ON tbl_name (index_col_name,...)</span><br><span class="line"> </span><br><span class="line">index_col_name:</span><br><span class="line">    col_name [(length)] [ASC | DESC]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="引擎擎操作"><a href="#引擎擎操作" class="headerlink" title="引擎擎操作"></a>引擎擎操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询引擎: 找出你的服务器支持哪个存储引擎，执行下面的语句</span><br><span class="line"><span class="keyword">show</span> engines;</span><br><span class="line"><span class="comment">-- 结果含义</span></span><br><span class="line">yes: 支持并激活</span><br><span class="line"><span class="keyword">no</span>: 不支持</span><br><span class="line">disabled: 支持该特性但是禁用</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;have%&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="创建-create"><a href="#创建-create" class="headerlink" title="创建 - create"></a>创建 - create</h2><ul>
<li>语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create database if not exists test default character set， default COLLATE</span><br><span class="line">create database if not exists test character set utf8,  COLLATE utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name</span><br><span class="line">    [create_specification [, create_specification] ...]</span><br><span class="line"> </span><br><span class="line">create_specification:</span><br><span class="line">    [DEFAULT] CHARACTER SET charset_name   -- 数据库使用的默认字符集</span><br><span class="line">  | [DEFAULT] COLLATE collation_name --  数据库的排序规则</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. mysql 中 database 和 schema 是同义词， 可以互换使用， 同指数据库的集合和结构</span><br><span class="line">2. 数据库模式： 通常用来描述数据库中的结构，包括表、视图、存储过程、函数、触发器等对象的定义。这些对象定义了数据库中数据的组织形式和操作方式。</span><br><span class="line">3. 有些目录包含文件，这些文件与数据库中的表对应。MySQL中的数据库的执行方法与这些目录的执行方法相同。因为当数据库刚刚被创建时，在数据库中没有表，所以CREATE DATABASE只创建一个目录。这个目录位于MySQL数据目录和db.opt文件之下</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database self_name</span><br></pre></td></tr></table></figure>



<h2 id="修改-alter"><a href="#修改-alter" class="headerlink" title="修改 - alter"></a>修改 - alter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ALTER &#123;DATABASE | SCHEMA&#125; [db_name]</span><br><span class="line">    alter_specification [, alter_specification] ...</span><br><span class="line"></span><br><span class="line">alter_specification:</span><br><span class="line">    [DEFAULT] CHARACTER SET charset_name  # 修改字符集</span><br><span class="line">  | [DEFAULT] COLLATE collation_name  # 修改排序方式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. alter database 是修改数据库的全局属性，这些特性储存在数据库目录中的db.opt文件中</span><br><span class="line">2. 数据库名省略，对应默认数据库</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name</span><br><span class="line"></span><br><span class="line">drop database if exists test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1. 如果您对一个带有符号链接的数据库使用DROP DATABASE，则链接和原数据库都被取消</span><br><span class="line">2. DROP DATABASE会返回已被取消的表的数目。此数目相当于被取消的.frm文件的数目。</span><br><span class="line">3. 是删除创建数据库的时候创建的文件：</span><br><span class="line">	.BAK  .DAT  .HSH </span><br><span class="line">    .MRG  .MYD  .ISD</span><br><span class="line">    .MYI  .db   .frm</span><br><span class="line">4. 如果在MySQL删除了上述这些文件之后，在数据库目录中仍保留有其它文件和目录，则数据库目录不能被取消。在这种情况下，您必须人工取消所有保留下的文件或目录，并再次发送DROP DATABASE语句。 </span><br></pre></td></tr></table></figure>

<h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use database	</span><br><span class="line">	可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。</span><br><span class="line">	该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句：</span><br><span class="line">	即： 后面使用数据表的时候，不用使用 数据库.数据表 来定位表</span><br><span class="line">注意</span><br><span class="line">1. 使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表</span><br><span class="line">mysql-&gt;use test1</span><br><span class="line">mysql-&gt;select * from test2.student    # 这个语句是正常的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方式一</span><br><span class="line">mysql [-h 127.0.0.1] -u root opprimeton -D 数据库名称</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前用户能使用的数据库。请注意如果没有SHOW DATABASES权限，则不能看见所有数据库</span><br><span class="line">show databases;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#选择使用的数据库, </span><br><span class="line">#表示接下来执行的语句是在这个数据库中执行的</span><br><span class="line">use self_database_name;</span><br><span class="line"></span><br><span class="line"># 当前使用的是哪个数据库</span><br><span class="line"># 如果你还没选择任何数据库，结果是NULL。</span><br><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>



<h1 id="数据表-表元数据"><a href="#数据表-表元数据" class="headerlink" title="数据表_表元数据"></a>数据表_表元数据</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="表创建"><a href="#表创建" class="headerlink" title="表创建"></a>表创建</h3><ul>
<li>使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#方式一</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(50) NOT NULL,</span><br><span class="line">    email VARCHAR(100) NOT NULL,</span><br><span class="line">    birthdate DATE,</span><br><span class="line">    is_active BOOLEAN DEFAULT TRUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">CREATE TABLE orders (</span><br><span class="line">    order_id INT AUTO_INCREMENT,</span><br><span class="line">    product_id INT,</span><br><span class="line">    quantity INT,</span><br><span class="line">    PRIMARY KEY (order_id),</span><br><span class="line">    FOREIGN KEY (product_id) REFERENCES products(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE pet (</span><br><span class="line">	name VARCHAR(20), </span><br><span class="line">	owner VARCHAR(20), </span><br><span class="line">	species VARCHAR(20), </span><br><span class="line">	sex CHAR(1), </span><br><span class="line">	birth DATE, </span><br><span class="line">	death DATE</span><br><span class="line">	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>语法结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span><br><span class="line">    [(create_definition,...)]  ## 列定义，列创建</span><br><span class="line">    [table_options]  # 表属性</span><br><span class="line">    [partition_options]  # 表</span><br><span class="line">    [select_statement] # 创建表的时候，填充的数据</span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name</span><br><span class="line">    [(] LIKE old_tbl_name [)];</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">create_definition:</span><br><span class="line">    column_definition column_constraint   # 列定义语句  列约束语句    列外键  列索引 </span><br><span class="line">      </span><br><span class="line">参数     </span><br><span class="line">tempoaray:</span><br><span class="line">      1. 只有在当前连接情况下，TEMPORARY表才是可见的。当连接关闭时，TEMPORARY表被自动取消。这意味着两个不同的连接可以使用相同的临时表名称，同时两个临时表不会互相冲突，也不与原有的同名的非临时表冲突。（原有的表被隐藏，直到临时表被取消时为止。）您必须拥有CREATE TEMPORARY TABLES权限，才能创建临时表。</span><br><span class="line"></span><br><span class="line">if [not] exists</span><br><span class="line">      1. 用于防止表存在发生错误</span><br><span class="line">      2. 原有表的结构与 create table 语句中表示的表的结构是否相同，这一样没有验证</span><br><span class="line">      3. 如果在 create table ... select 语句中使用 if not exists, 不论表是否已经存在，由 select 部分选择的记录都会被插入</span><br><span class="line">      </span><br><span class="line">注意      </span><br><span class="line">1. 表名</span><br><span class="line">    表名可以指定为 db_name.tbl_name 以便特定的数据库中创建表，即不论是否在当前库，都可以创建表。注意：`mydb`.`mytbl`是合法的，但是`mydb.mytbl`不合法。</span><br><span class="line">2. 如果没有指定是 null 或者 not null， 列在创建的时候默认是 null</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h3 id="列定义"><a href="#列定义" class="headerlink" title="列定义"></a>列定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">create_definition:</span><br><span class="line">    column_definition   # 列定义语句 </span><br><span class="line">    </span><br><span class="line">column_definition:</span><br><span class="line">    	col_name      # 列名称</span><br><span class="line">    	type           # 列类型</span><br><span class="line">    	[NOT NULL | NULL]  # 创建表的时候，自动填充为 null ，默认(null)</span><br><span class="line">    	[DEFAULT default_value] # 列指定的默认值， 不指定默认是 null</span><br><span class="line">        [AUTO_INCREMENT] # 用于在插入新行时自动为该列生成唯一递增的值，通常用于主键字段。</span><br><span class="line">        [UNIQUE [KEY] | [PRIMARY] KEY]  # 唯一键，主键，主键就是唯一键</span><br><span class="line">        [COMMENT &#x27;string&#x27;] # 列的注解信息，一般会设置为中文名</span><br><span class="line">        [reference_definition外键] # 外键约束，用来连接当前表的列到另一个表的列，建立表之间的关系。</span><br><span class="line">        </span><br><span class="line">        | [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...)  # 约束，主键</span><br><span class="line">        | KEY    # 约束，索引 key</span><br><span class="line">        | INDEX [index_name] [index_type] (index_col_name,...) # 普通的索引</span><br><span class="line">        | [CONSTRAINT [symbol]] UNIQUE [INDEX]   # 约束， 唯一索引</span><br><span class="line">                [index_name] [index_type] (index_col_name,...)</span><br><span class="line">        | [FULLTEXT|SPATIAL] [INDEX] [index_name] (index_col_name,...)   # 全文索引，表空间索引</span><br><span class="line">        | [CONSTRAINT [symbol]] FOREIGN KEY # 约束，外键</span><br><span class="line">                [index_name] (index_col_name,...) [reference_definition]</span><br><span class="line">        | CHECK (expr)  #  定义了列中值的约束条件，确保符合指定的表达式。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">注意</span><br><span class="line">1. USE KEY、IGNORE KEY和FORCE KEY是USE INDEX、IGNORE INDEX和FORCE INDEX的同义词。</span><br><span class="line">2. AUTO_INCREMENT 自增, 参看常用参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="列类型-1"><a href="#列类型-1" class="headerlink" title="列类型"></a>列类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type:</span><br><span class="line">    TINYINT[(length)] </span><br><span class="line">    	[UNSIGNED] # 默认是有符号整数，除非指定为 unsinged 无符号整数</span><br><span class="line">    	[ZEROFILL] # 填充的数据长度不够指定的长度，是否需要左侧填充 0</span><br><span class="line">  | SMALLINT[(length)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | INT[(length)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | INTEGER[(length)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | BIGINT[(length)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]</span><br><span class="line">  | DATE</span><br><span class="line">  | TIME</span><br><span class="line">  | TIMESTAMP</span><br><span class="line">  | DATETIME</span><br><span class="line">  | CHAR(length) [BINARY | ASCII | UNICODE]</span><br><span class="line">  | VARCHAR(length) [BINARY]</span><br><span class="line">  | TINYBLOB</span><br><span class="line">  | BLOB</span><br><span class="line">  | MEDIUMBLOB</span><br><span class="line">  | LONGBLOB</span><br><span class="line">  | TINYTEXT [BINARY]</span><br><span class="line">  | TEXT [BINARY]</span><br><span class="line">  | MEDIUMTEXT [BINARY]</span><br><span class="line">  | LONGTEXT [BINARY]</span><br><span class="line">  | ENUM(value1,value2,value3,...)</span><br><span class="line">  | SET(value1,value2,value3,...)</span><br><span class="line">  | spatial_type  # 空间坐标类型</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="列索引"><a href="#列索引" class="headerlink" title="列索引"></a>列索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index_col_name:</span><br><span class="line">	# 以 ASC或DESC为结尾用于指定递增或递减索引值存储。目前，这些关键词被分析，但是被忽略；索引值均以递增顺序存储。</span><br><span class="line">    col_name [(length)] [ASC | DESC]</span><br></pre></td></tr></table></figure>





<h3 id="列外键"><a href="#列外键" class="headerlink" title="列外键"></a>列外键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reference_definition:</span><br><span class="line">    REFERENCES tbl_name [(index_col_name,...)]</span><br><span class="line">               [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]</span><br><span class="line">               [ON DELETE reference_option] #  参考表中的数据被删除时，对外键的影响</span><br><span class="line">               [ON UPDATE reference_option] #  这部分是指定当参考表中的数据被更新时，对外键的影响</span><br><span class="line"> </span><br><span class="line">reference_option:</span><br><span class="line">    RESTRICT | CASCADE | SET NULL | NO ACTION</span><br><span class="line">    # RESTRICT 表示阻止删除，</span><br><span class="line">    # CASCADE 表示级联删除，</span><br><span class="line">    # SET NULL 表示将外键设为 NULL，</span><br><span class="line">    # NO ACTION 表示不执行任何操作（默认行为）。</span><br><span class="line"></span><br><span class="line">-- ---------------------------------------------------------------</span><br><span class="line">MATCH FULL 表示所有外键列都必须有对应的值，</span><br><span class="line">MATCH PARTIAL 表示一些列可以为 NULL，</span><br><span class="line">MATCH SIMPLE 表示只要有一个外键列有值即可</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="表属性"><a href="#表属性" class="headerlink" title="表属性"></a>表属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">table_option:</span><br><span class="line">    &#123;ENGINE|TYPE&#125; = engine_name   # 指定表的存储引擎，比如 InnoDB、MyISAM 等。存储引擎决定了表的特性和支持的功能。</span><br><span class="line">  | AUTO_INCREMENT = value  # 设置表中自增长列的起始值和步长</span><br><span class="line">  | AVG_ROW_LENGTH = value  # 指定表中每行数据的平均长度，这有助于优化存储空间分配。</span><br><span class="line">  | [DEFAULT] CHARACTER SET charset_name [COLLATE collation_name] # 定义表的默认字符集和校对规则。</span><br><span class="line">  | CHECKSUM = &#123;0 | 1&#125; # 控制表在存储时是否使用校验和来保护数据完整性</span><br><span class="line">  | COMMENT = &#x27;string&#x27; # 允许添加对表的注释描述。</span><br><span class="line">  | CONNECTION = &#x27;connect_string&#x27; # 用于连接到远程服务器的连接参数。</span><br><span class="line">  | MAX_ROWS = value  #  分别指定表的最大和最小行数，这些值可以用来优化存储空间分配。</span><br><span class="line">  | MIN_ROWS = value</span><br><span class="line">  | PACK_KEYS = &#123;0 | 1 | DEFAULT&#125; # 控制索引的压缩方式。</span><br><span class="line">  | PASSWORD = &#x27;string&#x27; # 设置 MySQL 用户密码</span><br><span class="line">  | DELAY_KEY_WRITE = &#123;0 | 1&#125; # 延迟索引写入，提高写入性能。</span><br><span class="line">  | ROW_FORMAT = &#123;DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT&#125;  # 设置行的存储格式。x</span><br><span class="line">  | UNION = (tbl_name[,tbl_name]...) # 创建联合表。</span><br><span class="line">  | INSERT_METHOD = &#123; NO | FIRST | LAST &#125; # 指定在插入数据时处理重复键的方式。</span><br><span class="line">  | DATA DIRECTORY = &#x27;absolute path to directory&#x27; # 定表数据和索引的存储目录。</span><br><span class="line">  | INDEX DIRECTORY = &#x27;absolute path to directory&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">partition_options:</span><br><span class="line">    PARTITION BY</span><br><span class="line">           [LINEAR] HASH(expr)</span><br><span class="line">        |  [LINEAR] KEY(column_list)</span><br><span class="line">        |  RANGE(expr)</span><br><span class="line">        |  LIST(column_list)</span><br><span class="line">    [PARTITIONS num]</span><br><span class="line">    [  SUBPARTITION BY</span><br><span class="line">           [LINEAR] HASH(expr)</span><br><span class="line">         | [LINEAR] KEY(column_list)</span><br><span class="line">      [SUBPARTITIONS(num)]  </span><br><span class="line">    ]</span><br><span class="line">    [(partition_definition), [(partition_definition)], ...]</span><br><span class="line"> </span><br><span class="line">partition_definition:</span><br><span class="line">    PARTITION partition_name</span><br><span class="line">        [VALUES &#123; </span><br><span class="line">                  LESS THAN (expr) | MAXVALUE </span><br><span class="line">                | IN (value_list) &#125;]</span><br><span class="line">        [[STORAGE] ENGINE [=] engine-name]</span><br><span class="line">        [COMMENT [=] &#x27;comment_text&#x27; ]</span><br><span class="line">        [DATA DIRECTORY [=] &#x27;data_dir&#x27;]</span><br><span class="line">        [INDEX DIRECTORY [=] &#x27;index_dir&#x27;]</span><br><span class="line">        [MAX_ROWS [=] max_number_of_rows]</span><br><span class="line">        [MIN_ROWS [=] min_number_of_rows]</span><br><span class="line">        [TABLESPACE [=] (tablespace_name)]</span><br><span class="line">        [NODEGROUP [=] node_group_id]</span><br><span class="line">        [(subpartition_definition), [(subpartition_definition)], ...]</span><br><span class="line"> </span><br><span class="line">subpartition_definition:</span><br><span class="line">    SUBPARTITION logical_name</span><br><span class="line">        [[STORAGE] ENGINE [=] engine-name]</span><br><span class="line">        [COMMENT [=] &#x27;comment_text&#x27; ]</span><br><span class="line">        [DATA DIRECTORY [=] &#x27;data_dir&#x27;]</span><br><span class="line">        [INDEX DIRECTORY [=] &#x27;index_dir&#x27;]</span><br><span class="line">        [MAX_ROWS [=] max_number_of_rows]</span><br><span class="line">        [MIN_ROWS [=] min_number_of_rows]</span><br><span class="line">        [TABLESPACE [=] (tablespace_name)]</span><br><span class="line">        [NODEGROUP [=] node_group_id]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="表填充"><a href="#表填充" class="headerlink" title="表填充"></a>表填充</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[IGNORE | REPLACE] [AS] SELECT ...   (Some legal select statement)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个 select_statement 是在创建表的时候，可以选择将新表的数据来自另一个已存在的表。它允许你执行一个 SELECT 查询来定义新表的初始数据。这个 SELECT 查询可以是任何合法的查询语句，你可以使用 IGNORE 或者 REPLACE 关键字来指定当遇到重复数据时的处理方式。</span><br><span class="line"></span><br><span class="line">IGNORE: 如果在插入新数据时遇到重复的唯一键值，会忽略这些重复的行而不报错。</span><br><span class="line">REPLACE: 如果遇到重复的唯一键值，会替换掉旧的数据行。</span><br><span class="line">例如，假设你有一个现有的表 old_table，你可以通过以下方式创建一个新表 new_table 并从 old_table 中选择数据：</span><br><span class="line"></span><br><span class="line">CREATE TABLE new_table LIKE old_table;</span><br><span class="line">或者，你可以在创建新表的同时从旧表中选择数据：</span><br><span class="line">CREATE TABLE new_table SELECT * FROM old_table;</span><br><span class="line">这样就会将 old_table 中的所有数据复制到 new_table 中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h3><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 修改表名</span><br><span class="line">alter table t rename test</span><br><span class="line"></span><br><span class="line"># 添加一个新的列</span><br><span class="line">alter table t add d TIMESTAMP</span><br><span class="line"></span><br><span class="line"># 给列添加索引</span><br><span class="line">alter table t add index(d) , add index(a)</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line">alter table t drop column d</span><br><span class="line"></span><br><span class="line"># 添加一个自增列</span><br><span class="line"># c编制了索引（作为PRIMARY KEY），因为AUTO_INCREMENT列必须编制索引。同时我们定义c为NOT NULL，因为主键列不能为NULL。</span><br><span class="line">alter table t add d int unsinged not null AUTO_INCREMENT add primary key(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># alter 进行重命名： ALTER TABLE my_table CHANGE old_column new_column 数据类型;</span><br><span class="line"> ALTER TABLE t1 CHANGE a b INTEGER</span><br><span class="line"> </span><br><span class="line"> # alter 更改列的类型: 新旧列的名称一致</span><br><span class="line">  ALTER TABLE t1 CHANGE a a INTEGER</span><br><span class="line">  ALTER TABLE t1 MODIFY b INTEGER NOT NULL;</span><br><span class="line">  </span><br><span class="line">  #取消外键</span><br><span class="line">   ALTER TABLE yourtablename DROP FOREIGN KEY fk_symbol;</span><br><span class="line">   </span><br><span class="line">   #把表默认的字符集和所有字符列（CHAR, VARCHAR, TEXT）改为新的字符集</span><br><span class="line">   ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;</span><br><span class="line">   #-- 上面语句会出现问题：有一列使用一种字符集（如latin1），但是存储的值实际上使用了其它的字符集（如utf8）</span><br><span class="line">   #-- 原因： 当您转换到BLOB列或从BLOB列转换过来时，并没有发生转换</span><br><span class="line">   #-- 如果您指定CONVERT TO CHARACTER SET为二进制，则TEXT列被转换到相应的二进制字符串类型（BINARY, VARBINARY, BLOB）。这意味着这些列将不再有字符集，接下来的CONVERT TO操作也将不适用于这些列。</span><br><span class="line">   ALTER TABLE t1 CHANGE c1 c1 BLOB;</span><br><span class="line">   ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   # 要仅仅改变一个表的默认字符集</span><br><span class="line">   ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name;</span><br><span class="line">   </span><br><span class="line"># 在表中增加一个新的分区p3，该分区用于储存小于2002的值   </span><br><span class="line">alter table t1 add partition  p1 values less than (2000)</span><br></pre></td></tr></table></figure>



<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">ALTER [IGNORE] TABLE tbl_name</span><br><span class="line">    alter_specification [, alter_specification] ...</span><br><span class="line">    </span><br><span class="line">alter_specification:</span><br><span class="line">  # ---------------------------------------------------------------------</span><br><span class="line">  # 添加一个新的列，可以指定其位置为表的首列或某列之后,默认是添加到最后</span><br><span class="line">    ADD [COLUMN] column_definition [FIRST | AFTER col_name ]  </span><br><span class="line">  # 修改列的默认值或删除默认值(指定列的新默认值，或删除旧的默认值)==》如果旧的默认值被删除同时列值为NULL，则新的默认值为NULL。如果列值不能为NULL，MySQL会指定一个默认值</span><br><span class="line">  | ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;</span><br><span class="line">  # 修改列名称和定义，可指定新列的位置</span><br><span class="line">  | CHANGE [COLUMN] old_col_name column_definition</span><br><span class="line">        [FIRST|AFTER col_name]</span><br><span class="line">  # 改列的定义，可以更改数据类型等。</span><br><span class="line">  # MODIFY是Oracle对ALTER TABLE的扩展</span><br><span class="line">  | MODIFY [COLUMN] column_definition [FIRST | AFTER col_name]</span><br><span class="line">  # 删除指定的列。</span><br><span class="line">  | DROP [COLUMN] col_name</span><br><span class="line">  # 一次性添加多个列</span><br><span class="line">  | ADD [COLUMN] (column_definition,...)</span><br><span class="line"></span><br><span class="line">  # ---------------------------------------------------------------------</span><br><span class="line">  # 添加主键约束，指定主键的列和类型</span><br><span class="line">  # 如果您向表中添加UNIQUE KEY或PRIMARY KEY，则UNIQUE KEY或PRIMARY KEY会被储存在非唯一索引之前，这样MySQL就可以尽早地检查出重复关键字</span><br><span class="line">  | ADD [CONSTRAINT [symbol]]</span><br><span class="line">        PRIMARY KEY [index_type] (index_col_name,...)</span><br><span class="line">  # 添加唯一约束，确保列或列组合的唯一性。</span><br><span class="line">  | ADD [CONSTRAINT [symbol]]</span><br><span class="line">        UNIQUE [index_name] [index_type] (index_col_name,...)</span><br><span class="line">  # 添加外键约束，指定外键的列和参考表的相关定义。</span><br><span class="line">  | ADD [CONSTRAINT [symbol]]</span><br><span class="line">        FOREIGN KEY [index_name] (index_col_name,...)</span><br><span class="line">        [reference_definition]</span><br><span class="line">  # 删除主键。</span><br><span class="line">  # 在MySQL较早的版本中，如果没有主索引，则DROP PRIMARY KEY会取消表中的第一个UNIQUE索引</span><br><span class="line">  # MySQL 5.1中对没有主键的表使用DROP PRIMARY KEY，则会出现错误信息。</span><br><span class="line">  | DROP PRIMARY KEY  </span><br><span class="line">  # 删除指定的外键约束。</span><br><span class="line">  | DROP FOREIGN KEY fk_symbol    </span><br><span class="line"></span><br><span class="line"> # ---------------------------------------------------------------------</span><br><span class="line">  # 添加一个索引，可以指定索引的名称、类型以及涉及的列。</span><br><span class="line">  | ADD INDEX [index_name] [index_type] (index_col_name,...)</span><br><span class="line">  # 加全文或空间索引。      </span><br><span class="line">  | ADD [FULLTEXT|SPATIAL] [index_name] (index_col_name,...) </span><br><span class="line">  # 删除指定的索引: 为 mysql 的扩展</span><br><span class="line">  | DROP INDEX index_name </span><br><span class="line">  # 禁止索引的使用: 在进行成批插入操作前先使关键字禁用可以大大地加快速度</span><br><span class="line">  | DISABLE KEYS</span><br><span class="line">  # 启用索引的使用</span><br><span class="line">  | ENABLE KEYS</span><br><span class="line">   # ---------------------------------------------------------------------</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">  #  重命名表</span><br><span class="line">  | RENAME [TO] new_tbl_name</span><br><span class="line">  # 对表中的数据按照指定列排序</span><br><span class="line">  | ORDER BY col_name</span><br><span class="line">  # 修改表的字符集和校对规则。</span><br><span class="line">  | CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]</span><br><span class="line">  # 带不带 default 都是等价的，只用于更改默认的表字符集。</span><br><span class="line">  | [DEFAULT] CHARACTER SET charset_name [COLLATE collation_name]</span><br><span class="line">  # 丢弃表空间</span><br><span class="line">  | DISCARD TABLESPACE</span><br><span class="line">  #  导入表空间</span><br><span class="line">  | IMPORT TABLESPACE</span><br><span class="line">  # 表级别的选项</span><br><span class="line">  | table_options</span><br><span class="line">   # ---------------------------------------------------------------------</span><br><span class="line">   </span><br><span class="line">  # 1. 不能使用ALTER TABLE向一个没有进行分区的表添加分区。</span><br><span class="line">  # 2. 对于没有明确命名的分区，MySQL会自动提供默认名称p0, p1, p2等</span><br><span class="line">  #  分区选项</span><br><span class="line">  | partition_options</span><br><span class="line">  # 添加分区: </span><br><span class="line">  # 1. 不支持 if [not] exists </span><br><span class="line">  | ADD PARTITION partition_definition</span><br><span class="line">  # 删除分区:</span><br><span class="line">  # 1. 如果被取消的分区其名称列于partition_names清单中，则储存在此分区中的数据也被取消。</span><br><span class="line">  # 2. 只能用于一个或者多个 range,list 分区，不能用于 hash 和 key 分区（hash和key分区使用colesce partition）</span><br><span class="line">  # 3. 不支持 if [not] exists</span><br><span class="line">  | DROP PARTITION partition_names</span><br><span class="line">  # 合并分区， 用来取消 hash 和 key 分区，取消的分区数据会被合并到没有取消的分区中</span><br><span class="line">  | COALESCE PARTITION number</span><br><span class="line">  # 重新组织分区: 更改部分分区，但不更改所有的分区</span><br><span class="line">  | REORGANIZE PARTITION partition_names INTO (partition_definitions)</span><br><span class="line">  # 分析分区</span><br><span class="line">  | ANALYZE PARTITION partition_names</span><br><span class="line">  # 检查分区</span><br><span class="line">  | CHECK PARTITION partition_names</span><br><span class="line">  # 优化分区</span><br><span class="line">  | OPTIMIZE PARTITION partition_names</span><br><span class="line">  # 重建分区</span><br><span class="line">  | REBUILD PARTITION partition_names</span><br><span class="line">  # 修复分区</span><br><span class="line">  | REPAIR PARTITION partition_names</span><br><span class="line">  # 重命名分区</span><br><span class="line">  # 1. 如果您希望对一个分区进行重命名，您必须取消分区，再重新建立；</span><br><span class="line">  # 2. 如果您希望对一个已分区的表进行重新命名，您必须取消所有分区，然后对表进行重命名，再添加被取消的分区。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">参数</span><br><span class="line">ignore:</span><br><span class="line">	如果在新表中有重复关键字，或者当STRICT模式启动后出现警告，则使用IGNORE控制ALTER TABLE的运行</span><br><span class="line">	1. 没有指定IGNORE，当重复关键字错误发生时，复制操作被放弃，返回前一步骤</span><br><span class="line">	2. 指定了IGNORE，则对于有重复关键字的行，只使用第一行，其它有冲突的行被删除。并且，对错误值进行修正，使之尽量接近正确值。</span><br><span class="line">  </span><br><span class="line">使用限制</span><br><span class="line">1. alter 的子句语法基本上跟 create 相同，  table_options 可以参考 create table 的</span><br><span class="line">2， 某些引擎不支持某些参数，会出现警告，可以使用 show warnings 查看</span><br><span class="line">3. alter table 运行时会对原表进行临时复制【除了rename选项】，在副本上进行更改，然后删除原表，再对新表进行重命名。在执行ALTER TABLE时，其它用户可以阅读原表，但是对表的更新和修改的操作将被延迟，直到新表生成为止。新表生成后，这些更新和修改信息会自动转移到新表上。</span><br><span class="line">	a. 对于MyISAM表，您可以通过把myisam_sort_buffer_size系统变量设置到一个较高的值，来加快重新创建索引（该操作是变更过程中速度最慢的一部分）的速度。</span><br><span class="line">	b. 使用 alter table 需要获得表的ALTER, INSERT和CREATE权限。</span><br><span class="line">	c. 使用ALTER TABLE tbl_name RENAME TO new_tbl_name并且没有其它选项，则MySQL只对与table tbl_name相对应的文件进行重命名。不需要创建一个临时表</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">4. mysql扩展了 alter,  </span><br><span class="line">	a. alter table 可以写入多个ADD, ALTER, DROP和CHANGE子句，中间用逗号分开</span><br><span class="line">		ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;</span><br><span class="line">	b. CHANGE col_name, DROP col_name和DROP INDEX是MySQL相对于标准SQL的扩展。</span><br><span class="line">	c. MODIFY是Oracle对ALTER TABLE的扩展。</span><br><span class="line"></span><br><span class="line">5. change, modify</span><br><span class="line">	a. 缩短列长时，列中存在有索引，并且缩短后的列长小于索引长度，则MySQL会自动缩短索引的长度。</span><br><span class="line">6. 如果列从表中被取消了，则这些列也从相应的索引中被取消。如果组成一个索引的所有列均被取消，则该索引也被取消。</span><br><span class="line">   如果一个表只包含一列，则此列不能被取消。如果您想要取消表，应使用DROP TABLE。</span><br><span class="line">   </span><br><span class="line">7.  子句兼容性</span><br><span class="line">	 Innodb存储引擎支持FOREIGN KEY和REFERENCES子句, 对于其它存储引擎，这些子句会被分析，但是会被忽略。对于所有的存储引擎，CHECK子句会被分析，但是会被忽略。接受这些子句但又忽略子句的原因是为了提高兼容性，以便更容易地从其它SQL服务器中导入代码，并运行应用程序，创建带参考数据的表</span><br><span class="line">	</span><br><span class="line">8. ALTER TABLE忽略DATA DIRECTORY和INDEX DIRECTORY表选项。	</span><br><span class="line"></span><br><span class="line">9. coalesce partition 用来删除 hash 和 key 分区的表</span><br><span class="line">    alter table t coalesce partition 2  【原本有 6 个分区】</span><br><span class="line">    a. 包含在最后一个number分区中的数据将被合并到其余的分区中。在此情况下，分区4和分区5将被合并到前4个分区中（编号为0、1、2和3的分区）。</span><br><span class="line"></span><br><span class="line">9. REORGANIZE PARTITION</span><br><span class="line">	使用方法</span><br><span class="line">	a. 把多个分区合并为一个分区。通过把多个分区的名称列入partition_names清单，并为partition_definition提供一个单一的定义，可以实现这个功能。</span><br><span class="line">	b。 把一个原有的分区拆分为多个分区。通过为partition_names命名一个分区，并提供多个partition_definitions，可以实现这个功能。</span><br><span class="line">	c. 更改使用VALUES LESS THAN定义的分区子集的范围或更改使用VALUES IN定义的分区子集的值清单。</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DROP [TEMPORARY] TABLE [IF EXISTS]</span><br><span class="line">    tbl_name [, tbl_name] ...</span><br><span class="line">    [RESTRICT | CASCADE]  # 这是在删除表时进行约束检查的选项</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">1. temporary</span><br><span class="line">	a. 用于指定删除临时表（只在当前会话中存在的表）。</span><br><span class="line">       语句只取消TEMPORARY表。</span><br><span class="line">      语句不会终止正在进行中的事务。</span><br><span class="line">      不会查验存取权。（TEMPORARY表仅对于创建该表的客户端是可见的，所以查验是不必要的。）</span><br><span class="line"></span><br><span class="line">2. if exists</span><br><span class="line">	对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。[show 语法]</span><br><span class="line">	</span><br><span class="line">1. 这是在删除表时进行约束检查的选项</span><br><span class="line">	restrict: 如果其他对象依赖于要删除的表，将会阻止删除操作</span><br><span class="line">	cascade: 如果其他对象依赖于要删除的表，将会一并删除这些依赖对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特点</span><br><span class="line">	1. 对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件</span><br><span class="line">    2. 除非您使用TEMPORARY关键词，DROP TABLE会自动提交当前的有效的事务</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询数据库中有哪些数据表</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line"># 查询某个表的元数据</span><br><span class="line"># Field显示列名字，Type是列的数据类型，Null表示列是否能包含NULL值，Key显示列是否被索引而Default指定列的默认值。</span><br><span class="line">describe self_表名</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="数据表-列元数据"><a href="#数据表-列元数据" class="headerlink" title="数据表_列元数据"></a>数据表_列元数据</h1><h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">    [USING index_type]</span><br><span class="line">    ON tbl_name (index_col_name,...)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">参数</span><br><span class="line">USING index_type</span><br><span class="line">	1. 部分储存引擎允许在创建索引时指定索引类型，如果列有多个索引类型，当没有指定index_type时，第一个类型是默认值</span><br><span class="line">		存储引擎 MyISAM  允许的索引类型  BTREE</span><br><span class="line">		存储引擎 InnoDB  允许的索引类型  BTREE</span><br><span class="line">		存储引擎 MEMORY/HEAP  允许的索引类型 HASH, BTREE</span><br><span class="line">		CREATE TABLE lookup (id INT) ENGINE = MEMORY;</span><br><span class="line">		CREATE INDEX id_index USING BTREE ON lookup (id);</span><br><span class="line">	2. TYPE type_name可以作为USING type_name的同义词，用于指定索引类型.</span><br><span class="line">		a.在索引规约语法中，位于索引类型前面的索引名称不能使用TYPE。这是因为，与USING不同，TYPE不是保留词，因此会被认为是一个索引名称</span><br><span class="line">		b.USING是首选的格式</span><br><span class="line">		</span><br><span class="line">    </span><br><span class="line">注意：    </span><br><span class="line">    </span><br><span class="line">1, CREATE INDEX被映射到一个ALTER TABLE语句上，用于创建索引</span><br><span class="line">2, CREATE INDEX允许您向已有的表中添加索引。</span><br><span class="line">   CREATE TABLE创建表时，也同时在表中创建了所有的索引</span><br><span class="line"> </span><br><span class="line">3, 多列索引</span><br><span class="line">  格式为（col1, col2,...）的一个列清单创建出一个多列索引。通过串接给定列中的值，确定索引值的格式</span><br><span class="line">  </span><br><span class="line">4. 对于CHAR和VARCHAR列，只用一列的一部分就可创建索引。创建索引时，使用col_name(length)语法，对前缀编制索引。前缀包括每列值的前length个字符。BLOB和TEXT列也可以编制索引，但是必须给出前缀长度。</span><br><span class="line">	# 创建一个索引，索引使用列名称的前10个字符。</span><br><span class="line">	CREATE INDEX part_of_name ON customer (name(10));</span><br><span class="line">     a. 多数名称的前10个字符通常不同，所以此索引不会比使用列的全名创建的索引速度慢很多。另外，使用列的一部分创建索引可以使索引文件大大减小，从而节省了大量的磁盘空间，有可能提高INSERT操作的速度</span><br><span class="line">     b. 前缀最长为255字节。对于MyISAM和InnoDB表，前缀最长为1000字节。【注意前缀的限长以字节计，而CREATE INDEX语句中的前缀长度指的是字符的数目。对于使用多字节字符集的列，在指定列的前缀长度时，要考虑这一点。】</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MYSQL5.1中：</span><br><span class="line">	a. 只有当您正在使用MyISAM, InnoDB或BDB表类型时，您可以向有NULL值的列中添加索引。</span><br><span class="line">	b. 只有当您正在使用MyISAM, BDB或InnoDB表类型时，您可以向BLOB或TEXT列中添加索引。</span><br><span class="line">5. 如果您指定的索引类型在给定的储存引擎中不合法，但是有其它的索引类型适合引擎使用，并且不会影响查询功能，则引擎应使用此类型。</span><br><span class="line">6. FULLTEXT索引只能对CHAR, VARCHAR和TEXT列编制索引，并且只能在MyISAM表中编制</span><br><span class="line">7. SPATIAL索引只能对空间列编制索引，并且只能在MyISAM表中编制</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="数据表-数据"><a href="#数据表-数据" class="headerlink" title="数据表_数据"></a>数据表_数据</h1><h2 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 按升序对动物的种类进行排序，然后按降序根据生日对各动物种类进行排序（最年轻的动物在最前面），</span><br><span class="line"># 注意DESC关键字仅适用于在它前面的列名(birth)；不影响species列的排序顺序。</span><br><span class="line">SELECT name, species, birth FROM pet ORDER BY species, birth DESC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">      [ALL | DISTINCT | DISTINCTROW ] # 用于控制返回结果集中的唯一值。ALL 返回所有匹配的行，DISTINCT 返回唯一不同的行，DISTINCTROW 在某些数据库中类似于 DISTINCT。</span><br><span class="line">      [HIGH_PRIORITY] # 这是一个查询优先级提示，用于指示数据库系统优先处理该查询。</span><br><span class="line">      [STRAIGHT_JOIN] # 强制使用指定的连接顺序，可能会影响查询优化</span><br><span class="line">      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] # 这些是用于控制查询结果集大小和缓冲的选项，用于优化查询性能。</span><br><span class="line">      [SQL_CACHE | SQL_NO_CACHE]  # 控制查询结果是否被缓存。</span><br><span class="line">      [SQL_CALC_FOUND_ROWS] # 当查询包含 LIMIT 子句时，使用这个选项可以获取在不考虑 LIMIT 的情况下，满足条件的行数。</span><br><span class="line">    select_expr, ...  # 这里是列名或表达式，表示要检索行元数据</span><br><span class="line">      [INTO OUTFILE &#x27;file_name&#x27; export_options | INTO DUMPFILE &#x27;file_name&#x27;] # 将查询结果输出到文件，可以是文本文件或二进制文件。</span><br><span class="line">    [FROM table_references  # 指定数据来自哪些表或子查询</span><br><span class="line">    	[WHERE where_definition] #  该表达式指示被选择的行必须满足的条件。</span><br><span class="line">   	    [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] # 对结果集进行分组，可以使用 WITH ROLLUP 生成额外的行汇总。</span><br><span class="line">   		[HAVING where_definition] # 类似于 WHERE，但是在分组之后对分组结果进行过滤。</span><br><span class="line">    	[ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC] , ...]  # 指定结果集的排序方式。</span><br><span class="line">    	[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] # 限制返回的行数</span><br><span class="line">    	[PROCEDURE procedure_name(argument_list)] # 可以调用存储过程来处理数据。</span><br><span class="line">    	[FOR UPDATE | LOCK IN SHARE MODE] # 控制对查询结果行的锁定方式，以确保一致性和避免并发问题。</span><br><span class="line">    ] </span><br><span class="line"># ----------------------------------------------------------------------------------------------</span><br><span class="line">1. 所有被使用的子句[必须]按语法说明中显示的顺序严格地排序</span><br><span class="line">2. </span><br><span class="line"># ----------------------------------------------------------------------------------------------</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ul>
<li><p>基础参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ALL, DISTINCT和DISTINCTROW</span><br><span class="line">	1. 指定是否重复行应被返回。</span><br><span class="line">	3. 如果这些选项没有被给定，则默认值为ALL（所有的匹配行被返回）。</span><br><span class="line">	2. DISTINCT和DISTINCTROW是同义词，用于指定结果集合中的重复行应被删除。</span><br><span class="line"></span><br><span class="line">HIGH_PRIORITY, STRAIGHT_JOIN和以SQL_为开头:  是MySQL相对于标准SQL的扩展。</span><br><span class="line">·         HIGH_PRIORITY给予SELECT更高的优先权，高于用于更新表的语句。您应该只对查询使用HIGH_PRIORITY。查询速度非常快，而且立刻被执行。SELECT HIGH_PRIORITY查询在表被锁定用于读取时被发出。即使有一个新的语句正在等待表变为空闲，查询也会运行。</span><br><span class="line">		 注意：HIGH_PRIORITY不能和SELECT语句同时使用。SELECT语句是UNION的一部分。</span><br><span class="line"></span><br><span class="line">·         STRAIGHT_JOIN用于促使优化符把表联合在一起，顺序按照这些表在FROM子句中排列的顺序。如果优化符联合表时顺序不佳，您可以使用STRAIGHT_JOIN来加快查询的速度。 ‘join语法’</span><br><span class="line"></span><br><span class="line">·         SQL_BIG_RESULT可以与GROUP BY或DISTINCT同时使用，来告知优化符结果集合有很多行。在这种情况下，MySQL直接使用以磁盘为基础的临时表（如果需要的话）。在这种情况下，MySQL还会优先进行分类，不优先使用临时表。临时表对于GROUP BY组分带有关键字。</span><br><span class="line"></span><br><span class="line">·         SQL_BUFFER_RESULT促使结果被放入一个临时表中。这可以帮助MySQL提前解开表锁定，在需要花费较长时间的情况下，也可以帮助把结果集合发送到客户端中。</span><br><span class="line"></span><br><span class="line">·         SQL_SMALL_RESULT可以与GROUP BY或DISTINCT同时使用，来告知优化符结果集合是较小的。在此情况下，MySAL使用快速临时表来储存生成的表，而不是使用分类。在MySQL 5.1中，通常不需要这样。</span><br><span class="line"></span><br><span class="line">·         SQL_CALC_FOUND_ROWS告知MySQL计算有多少行应位于结果集合中，不考虑任何LIMIT子句。行的数目可以使用SELECT FOUND_ROWS()恢复。请参见12.9.3节，“信息函数”。</span><br><span class="line"></span><br><span class="line">·         如果您正在使用一个query_cache_type值，值为2或DEMAND，则SQL_CACHE告知MySQL把查询结果存储在查询缓存中。对于使用UNION的查询或子查询，本选项会影响查询中的所有SELECT。请参见5.13节，“MySQL查询高速缓冲”。</span><br><span class="line"></span><br><span class="line">·         SQL_NO_CACHE告知MySQL不要把查询结果存储在查询缓存中。请参见5.13节，“MySQL查询高速缓冲”。对于一个使用UNION或子查询的查询，本选项会影响查询中的SELECT。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>选择到文件</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">INTO OUTFILE &#x27;file_name&#x27; export_options | INTO DUMPFILE &#x27;file_name&#x27;</span><br><span class="line">1. 把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。file_name不能是一个原有的文件。原有文件会阻止例如“/etc/passwd”的文件和数据库表被销毁。</span><br><span class="line">2. 主要作用是让您可以非常快速地把一个表转储到服务器机器上</span><br><span class="line"></span><br><span class="line">export_options</span><br><span class="line">	FIELDS和LINES子句, 这些子句与LOAD DATA INFILE语句同时使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同类型的</span><br><span class="line">	mysql –e &quot;SELECT ...&quot; &gt; file_name”的命令，来生成文件</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"># ===== 待整理</span><br><span class="line">SELECT...INTO OUTFILE是LOAD DATA INFILE的补语；用于语句的exort_options部分的语法包括部分FIELDS和LINES子句，这些子句与LOAD DATA INFILE语句同时使用。请参见13.2.5节，“LOAD DATA INFILE语法”。</span><br><span class="line"></span><br><span class="line">FIELDS ESCAPED BY用于控制如何写入特殊字符。如果FIELDS ESCAPED BY字符不是空字符，则被用于在输出中对以下字符设前缀：</span><br><span class="line"></span><br><span class="line">o        FIELDS ESCAPED BY字符</span><br><span class="line"></span><br><span class="line">o        FIELDS [OPTIONALLY] ENCLOSED BY字符</span><br><span class="line"></span><br><span class="line">o        FIELDS TERMINATED BY和LINES TERMINATED BY值的第一个字符</span><br><span class="line"></span><br><span class="line">o        ASCII 0（在编写时接在转义符后面的是ASCII ‘0’，而不是一个零值字节）</span><br><span class="line"></span><br><span class="line">如果FIELDS ESCAPED BY字符是空字符，则没有字符被转义，并且NULL被作为NULL输出，而不是作为\N输出。指定一个空的转义符不是一个好的主意。特别是当您的数据中的字段值包含刚被给予的清单中的字符时，更是如此。</span><br><span class="line"></span><br><span class="line">其原因是您必须对所有FIELDS TERMINATED BY, ENCLOSED BY, ESCAPED BY或LINES TERMINATED BY字符进行转义，才能可靠地读取文件并返回。ASCII NUL被转义，以便更容易地使用调页程序观看。</span><br><span class="line"></span><br><span class="line">生成的文件不必符合SQL语法，所以没有其它的字符需要被转义。</span><br><span class="line"></span><br><span class="line">在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。</span><br><span class="line"></span><br><span class="line">SELECT a,b,a+b INTO OUTFILE &#x27;/tmp/result.text&#x27;</span><br><span class="line">FIELDS TERMINATED BY &#x27;,&#x27; OPTIONALLY ENCLOSED BY &#x27;&quot;&#x27;</span><br><span class="line">LINES TERMINATED BY &#x27;\n&#x27;</span><br><span class="line">FROM test_table;</span><br><span class="line">·         如果您使用INTO DUMPFILE代替INTO OUTFILE，则MySQL只把一行写入到文件中，不对任何列或行进行终止，也不执行任何转义处理。如果您想要把一个BLOB值存储到文件中，则这个语句是有用的。</span><br><span class="line"></span><br><span class="line">·         注释：任何由INTO OUTFILE或INTO DUMPFILE创建的文件都可以被服务器主机上的所有用户编写。原因是，MySQL服务器不能创建这样的文件，即文件的所有者不是该文件运行时所属的用户（任何时候，您都不能出于此原因或出于其它原因把mysqld作为根段运行）。该文件必须是全局可写的，这样您就可以操作其中的内容。</span><br><span class="line"></span><br><span class="line">·         有的过程应在结果集合内处理数据。PROCEDURE子句用于对这些过程进行命名。要了解示例，请参见27.3.1节，“步骤分析”。</span><br><span class="line"></span><br><span class="line">·         存储引擎使用页面或行锁。如果您对存储引擎使用FOR UPDATE，则受到查询检验的行会被进行写锁定，直到当前事务结束为止。使用LOCK IN SHARE MODE可以设置一个共享锁。共享锁可以防止其它事务更新或删除被检验的行。请参见15.2.10.5节，“锁定读取SELECT ... FOR UPDATE和SELECT ... LOCK IN SHARE MODE”。</span><br><span class="line"></span><br><span class="line">在SELECT关键词的</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM table_references</span><br><span class="line">	1. 如果您命名的表多于一个，则您在进行一个联合操作,对于每一个被指定的表，您可以自选地指定一个别名</span><br><span class="line">	2. 可以向优化符提示如何选择索引</span><br><span class="line">	 	tbl_name [[AS] alias]  [&#123;USE|IGNORE|FORCE&#125; INDEX (key_list)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  USE INDEX: 强制查询使用指定的索引，如果这个索引不存在，查询将报错。</span><br><span class="line">  IGNORE INDEX: 强制查询忽略指定的索引，即使这个索引存在也不使用它。</span><br><span class="line">  FORCE INDEX: 强制查询使用指定的索引，如果这个索引不存在，查询会继续执行并忽略这个索引的存在</span><br><span class="line">  key_list： 是一个逗号分隔的索引列表，指定了要使用的索引。这可以是单个索引或者多个索引的组合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">虚表</span><br><span class="line">1. 在没有表被引用的情况下，允许您指定DUAL作为一个假的表名</span><br><span class="line">	SELECT 1 + 1 FROM DUAL;</span><br><span class="line">	</span><br><span class="line">	/</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where</span><br><span class="line">	1.</span><br><span class="line">	2. 在WHERE子句中，您可以使用MySQL支持的所有函数，不过总计（总结）函数除外</span><br></pre></td></tr></table></figure>



<h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group</span><br><span class="line">	1. 可以使用列名 &#123;col_name&#125;，表达式 &#123;expr&#125; 或者列的位置 &#123;position&#125; 来作为分组依据。</span><br><span class="line">	2. ASC 和 DESC 用于指定排序顺序，默认是升序（ASC）</span><br><span class="line">	3. [WITH ROLLUP]: 这是一个可选部分，用于生成包含汇总行的结果。WITH ROLLUP 可以生成一个额外的行，包含每个分组的汇总值，这个行会在结果中以 NULL 或者其他特殊标识出现，表示对应列的总计或者小计。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. SQL标准要求HAVING必须引用GROUP BY子句中的列或用于总计函数中的列。不过，MySQL支持对此工作性质的扩展，并允许HAVING因为SELECT清单中的列和外部子查询中的列。</span><br><span class="line"></span><br><span class="line">2. HAVING子句引用了一个意义不明确的列，则会出现警告</span><br><span class="line"># col2意义不明确，因为它既作为别名使用，又作为列名使用</span><br><span class="line">SELECT COUNT(col1) AS col2 </span><br><span class="line">	FROM t GROUP </span><br><span class="line">	BY col2 </span><br><span class="line">	HAVING col2 = 2;</span><br><span class="line">	</span><br><span class="line">3.  HAVING不能用于应被用于WHERE子句的条目</span><br><span class="line">   异常语句： SELECT col_name FROM tbl_name HAVING col_name &gt; 0;</span><br><span class="line">   修改语句： SELECT col_name FROM tbl_name WHERE col_name &gt; 0;</span><br><span class="line">   </span><br><span class="line">4.  HAVING子句可以引用总计函数，而WHERE子句不能引用：</span><br><span class="line">    SELECT user, MAX(salary) FROM users GROUP BY user HAVING MAX(salary)&gt;10;</span><br><span class="line">    </span><br><span class="line">5.     </span><br></pre></td></tr></table></figure>



<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">limit</span><br><span class="line">	1. LIMIT row_count: 这种形式指定了要返回的行数。例如，LIMIT 10 表示只返回查询结果的前 10 行。</span><br><span class="line">	2. LIMIT row_count OFFSET offset: 这种形式中，row_count 表示要返回的行数，offset 表示从查询结果的起始位置开始跳过的行数。例如， 表示</span><br><span class="line">	   a. 从查询结果的第 11 行开始，返回接下来的 5 行数据。</span><br><span class="line">	   	  LIMIT 5 OFFSET 10</span><br><span class="line">	   	  LIMIT 5, 10  #  LIMIT n与LIMIT 0,n等价</span><br><span class="line">	   	  。</span><br><span class="line">	3. 为了与PostgreSQL兼容，MySQL也支持</span><br><span class="line">		LIMIT row_count OFFSET offset</span><br></pre></td></tr></table></figure>

<h3 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对于已预备的语句，您可以使用位置保持符。以下语句将从tb1表中返回一行：</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @a=1;</span><br><span class="line">mysql&gt; PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?&quot;;</span><br><span class="line">mysql&gt; EXECUTE STMT USING @a;</span><br><span class="line">以下语句将从tb1表中返回第二到第六行：</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @skip=1; SET @numrows=5;</span><br><span class="line">mysql&gt; PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?, ?&quot;;</span><br><span class="line">mysql&gt; EXECUTE STMT USING @skip, @numrows; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">使用AS alias_name可以为select_expr给定一个别名。此别名用作表达式的列名，可以用于GROUP BY、ORDER BY或HAVING子句</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT CONCAT(last_name,&#x27;, &#x27;,first_name) AS full_name</span><br><span class="line">-&gt; FROM mytable ORDER BY full_name;</span><br><span class="line"></span><br><span class="line"># as 可以省略</span><br><span class="line"># 没有在两个select_expr表达式之间加逗号，则会出现一个小问题：MySQL会把第二个表达式理解为一个别名</span><br><span class="line">SELECT columna columnb FROM mytable;</span><br><span class="line"></span><br><span class="line">2. 表别名可以在 where 子句中使用， 别名使用不讲顺序</span><br><span class="line">SELECT t1.name, t2.salary </span><br><span class="line">  FROM employee t1, info t2</span><br><span class="line">  WHERE t1.name = t2.name;</span><br><span class="line"></span><br><span class="line">2. 被选择的用于输出的列可以使用列名称、列别名或列位置被引用到ORDER BY和GROUP BY子句中。列位置为整数，从1开始</span><br><span class="line">SELECT college, region AS r, seed AS s </span><br><span class="line"> 	FROM tournament</span><br><span class="line"> 	ORDER BY r, s;</span><br><span class="line"> 	</span><br><span class="line"># 不建议使用列位置，因为该语法已经从SQL标准中删除。 	</span><br><span class="line">SELECT college, region, seed </span><br><span class="line">	FROM tournament </span><br><span class="line">    ORDER BY 2, 3;</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">1. 使用AS明确地指定列的别名，把它作为习惯，是一个良好的操作规范</span><br><span class="line">2.  在一个WHERE子句中使用列别名是不允许的，因为当执行WHERE子句时，列值可能还没有被确定</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"># From table_references: 的语句</span><br><span class="line">table_references:</span><br><span class="line">    table_reference [, table_reference] …</span><br><span class="line"></span><br><span class="line">table_reference:</span><br><span class="line">    table_factor  | join_table </span><br><span class="line"></span><br><span class="line"># 使用下面的任何一行都可以</span><br><span class="line">table_factor:</span><br><span class="line">    tbl_name [[AS] alias] [&#123;USE|IGNORE|FORCE&#125; INDEX (key_list)]</span><br><span class="line">  | ( table_references )</span><br><span class="line">  | &#123; OJ table_reference LEFT OUTER JOIN table_reference ON conditional_expr &#125; # 目的只是为了保持与ODBC的兼容性</span><br><span class="line"></span><br><span class="line">join_table:</span><br><span class="line">    table_reference [INNER | CROSS] JOIN table_factor [join_condition]</span><br><span class="line">  | table_reference STRAIGHT_JOIN table_factor    #straight_join 强制 MySQL 使用特定的连接顺序。</span><br><span class="line">  | table_reference STRAIGHT_JOIN table_factor ON condition </span><br><span class="line">  | table_reference LEFT [OUTER] JOIN table_reference join_condition # 左连</span><br><span class="line">  | table_reference NATURAL [LEFT [OUTER]] JOIN table_factor # </span><br><span class="line">  | table_reference RIGHT [OUTER] JOIN table_reference join_condition # 右连</span><br><span class="line">  | table_reference NATURAL [RIGHT [OUTER]] JOIN table_factor</span><br><span class="line"> </span><br><span class="line"># -----------------------</span><br><span class="line">straignt_join</span><br><span class="line">	1. 它用于指定在查询中按照表的顺序进行连接。当你在 SQL 查询中使用 JOIN 来连接多个表时，数据库通常会尝试找到最有效的连接顺序和方法来执行这些连接，以获得最佳性能。但有时候数据库的优化并不总是最适合你的情况，这时你可能希望强制数据库按照你给定的表连接顺序来执行连接操作</span><br><span class="line">	# 查询中的 STRAIGHT_JOIN 关键字告诉数据库明确按照你给定的顺序，首先连接 users 表，然后连接 orders 表，而不是让数据库自己决定连接顺序。</span><br><span class="line">	SELECT * FROM users STRAIGHT_JOIN orders ON users.id = orders.user_id;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">natural join</span><br><span class="line">	1. 表示进行自然连接，它会自动查找两个表中具有相同列名的列，并将它们作为连接条件进行连接</span><br><span class="line">	2. 会带来一些便利，因为它自动识别相同名称的列并进行连接，但也可能存在一些潜在的问题。如果表中有多个列具有相同的名称，这可能会导致意外的连接行为，因为所有同名列都会被用作连接条件</span><br><span class="line">inner join</span><br><span class="line">	1.  两个表的NATURAL [LEFT] JOIN被定义为与INNER JOIN语义相同</span><br><span class="line">	2.  INNER JOIN和，（逗号）在无联合条件下是语义相同的</span><br><span class="line">	即： 两者都可以对指定的表计算出笛卡儿乘积（也就是说，第一个表中的每一行被联合到第二个表中的每一行）。</span><br><span class="line">	</span><br><span class="line">left|right join</span><br><span class="line">	1. 要使代码可以在数据库内移植，建议您使用LEFT JOIN代替RIGHT JOIN。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#---------------------------</span><br><span class="line"># 如果我们把一系列table_reference条目中的每个逗号都看作相当于一个内部联合，则这是一个稳妥的扩展</span><br><span class="line">SELECT * FROM t1 LEFT JOIN (t2, t3, t4) ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span><br><span class="line">等价于：</span><br><span class="line">	SELECT * </span><br><span class="line">	FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4) ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span><br><span class="line"># 方式二</span><br><span class="line">  a LEFT JOIN b USING (c1,c2,c3)</span><br><span class="line">  	ON 是用来指定连接条件的一般方式，</span><br><span class="line">  	USING 是在两个表具有相同列名的情况下更为简洁的一种写法</span><br><span class="line">	</span><br><span class="line">特点</span><br><span class="line">1. SQL标准只接受table_reference，而不是圆括号内的一系列条目</span><br><span class="line">2. MySQL中，CROSS JOIN从语法上说与INNER JOIN等同（两者可以互相替换。标准SQL中，两者是不等同的。</span><br><span class="line">   INNER JOIN与ON子句同时使用，CROSS JOIN以其它方式使用。</span><br><span class="line">3. 通常，在只含有内部联合运行的联合表达式中，圆括号可以被忽略。MySQL也支持嵌套的联合</span><br><span class="line">4. 通常，您不应对ON部分有任何条件。ON部分用于限定在结果集合中您想要哪些行。但是，您应在WHERE子句中指定这些条件</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">1. 自然联合和使用USING的联合，包括外部联合变量，依据SQL:2003标准被处理。这些变更时MySQL与标准SQL更加相符。不过，对于有些联合，这些变更会导致不同的输出列</span><br><span class="line">2.  NATURAL联合或USING联合的列会与旧版本不同。特别是，不再出现冗余的输出列，用于SELECT *扩展的列的顺序会与以前不同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">旧版本特性</span><br><span class="line">1. 在旧版本中，逗号操作符（，）和JOIN均有相同的优先权，所以联合表达式t1, t2 JOIN t3被理解为((t1, t2) JOIN t3)。现在，JOIN有更高的优先权，所以表达式被理解为(t1, (t2 JOIN t3))。这个变更会影响使用ON子句的语句，因为该子句只参阅联合操作数中的列。优先权的变更改变了对什么是操作数的理解。[本变更也适用于INNER JOIN，CROSS JOIN，LEFT JOIN和RIGHT JOIN。]</span><br><span class="line">  SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);</span><br><span class="line"></span><br><span class="line">2. SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;</span><br><span class="line">	在旧版本中，SELECT语句是合法的。现在该语句会运行失败，出现在&#x27;on clause&#x27;中未知列&#x27;i3&#x27;的错误。这是因为i3是t3中的一个表，而t3不是ON子句中的操作数。本语句应进行如下改写：</span><br><span class="line">	SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line"># 待整理</span><br><span class="line">旧版本特性</span><br><span class="line">3. 一个USING子句可以被改写为一个ON子句。ON子句对比了相应的列。例如，以下两个子句具有相同的语义：</span><br><span class="line">     a LEFT JOIN b USING (c1,c2,c3)</span><br><span class="line">     a LEFT JOIN b ON a.c1=b.c1 AND a.c2=b.c2 AND a.c3=b.c3</span><br><span class="line">现在，这两个子句不再是一样的：</span><br><span class="line">	a. 在决定哪些行满足联合条件时，两个联合保持语义相同。</span><br><span class="line">	b. 在决定哪些列显示SELECT *扩展时，两个联合的语义不相同</span><br><span class="line">	# USING联合选择对应列中的合并值，而ON联合选择所有表中的所有列</span><br><span class="line">对于前面的USING联合，SELECT *选择这些值：</span><br><span class="line"></span><br><span class="line">o                     COALESCE(a.c1,b.c1), COALESCE(a.c2,b.c2), COALESCE(a.c3,b.c3)</span><br><span class="line">对于ON联合，SELECT *选择这些值：</span><br><span class="line"></span><br><span class="line">a.c1, a.c2, a.c3, b.c1, b.c2, b.c3</span><br><span class="line">使用内部联合时，COALESCE(a.c1,b.c1)与a.c1或b.c1相同，因为两列将具有相同的值。使用外部联合时（比如LEFT JOIN），两列中有一列可以为NULL。该列将会从结果中被忽略。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SELECT ...</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT ...</span><br><span class="line">[UNION [ALL | DISTINCT]</span><br><span class="line">SELECT ...]</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">1. 用于把来自许多SELECT语句的结果组合到一个结果集合中。</span><br><span class="line"></span><br><span class="line">所受限制</span><br><span class="line">1. SELECT语句的对应位置的被选择的列应具有相同的类型。（例如，被第一个语句选择的第一列应和被其它语句选择的第一列具有相同的类型。）在第一个SELECT语句中被使用的列名称也被用于结果的列名称。</span><br><span class="line"></span><br><span class="line">2. 只有最后一个SELECT语句可以使用INTO OUTFILE</span><br><span class="line">3.  HIGH_PRIORITY不能与作为UNION一部分的SELECT语句同时使用。如果您对第一个SELECT指定了HIGH_PRIORITY，则不会起作用。如果您对其它后续的SELECT语句指定了HIGH_PRIORITY，则会产生语法错误。</span><br><span class="line">4. 去重问题。</span><br><span class="line">	a.对UNION不使用关键词ALL，则所有返回的行都是唯一的，如同您已经对整个结果集合使用了DISTINCT。如果您指定了ALL，您会从所有用过的SELECT语句中得到所有匹配的行。</span><br><span class="line">	b. DISTINCT关键词是一个自选词，不起任何作用，但是根据SQL标准的要求，在语法中允许采用</span><br><span class="line">	c. 在MySQL中，DISTINCT代表一个共用体的默认工作性质.</span><br><span class="line">	d. 混用 union all 和 union distinct , 会导致 distinct 会覆盖其左侧的所有 all 配置</span><br><span class="line">	e. distinct 共用体可以使用 union distinct 明确生成，或者只使用 union 进行隐式生成</span><br><span class="line">	</span><br><span class="line">5. 排序和分页</span><br><span class="line">	a. 想使用ORDER BY或LIMIT子句来对全部UNION结果进行分类或限制，则应对单个地SELECT语句加圆括号，并把ORDER BY或LIMIT放到最后一个的后面。</span><br><span class="line">	#这种 ORDER BY不能使用包括表名称（也就是，采用tbl_name.col_name格式的名称）列引用。可以在第一个SELECT语句中提供一个列别名，并在ORDER BY中参阅别名，或使用列位置在ORDER BY中参阅列。（首选采用别名，因为不建议使用列位置。）</span><br><span class="line">	(SELECT a FROM tbl_name WHERE a=10 AND B=1)</span><br><span class="line">    UNION</span><br><span class="line">    (SELECT a FROM tbl_name WHERE a=11 AND B=2)</span><br><span class="line">    ORDER BY a LIMIT 10;</span><br><span class="line">	</span><br><span class="line">	b. 带 order by 的一列有别名，则ORDER BY子句必须引用别名，而不能引用列名称。以下语句中的第一个语句必须运行，但是第二个会运行失败，出现在&#x27;order clause&#x27;中有未知列&#x27;a&#x27;的错误：</span><br><span class="line">	(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;</span><br><span class="line">	(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;</span><br><span class="line"></span><br><span class="line">	c. 为了对单个SELECT使用ORDER BY或LIMIT，应把子句放入圆括号中。圆括号包含了SELECT：</span><br><span class="line">	# 圆括号中用于单个SELECT语句的ORDER BY只有当与LIMIT结合后，才起作用。否则，ORDER BY被优化去除。</span><br><span class="line">	(SELECT a FROM tbl_name WHERE a=10 AND B=1 ORDER BY a LIMIT 10)</span><br><span class="line">    UNION</span><br><span class="line">    (SELECT a FROM tbl_name WHERE a=11 AND B=2 ORDER BY a LIMIT 10);</span><br><span class="line"></span><br><span class="line">	e  UNION结果集合中的列的类型和长度考虑了被所有SELECT语句恢复的数值</span><br></pre></td></tr></table></figure>

<h3 id="查询顺序"><a href="#查询顺序" class="headerlink" title="查询顺序"></a>查询顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1, 选出所有的表</span><br><span class="line">2, 条件选出所有的数据</span><br><span class="line">3， 分组</span><br><span class="line">4， 函数计算</span><br><span class="line">5. 组内筛选</span><br><span class="line">6. 去重排序</span><br><span class="line">7. 限制</span><br><span class="line"></span><br><span class="line">FROM</span><br><span class="line">&lt;表名&gt; # 笛卡尔积</span><br><span class="line">ON</span><br><span class="line">&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选</span><br><span class="line">JOIN &lt;join, left join, right join...&gt; </span><br><span class="line">&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中</span><br><span class="line">WHERE</span><br><span class="line">&lt;where条件&gt; # 对上述虚表进行筛选</span><br><span class="line">GROUP BY</span><br><span class="line">&lt;分组条件&gt; # 分组</span><br><span class="line">&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的</span><br><span class="line">HAVING</span><br><span class="line">&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选</span><br><span class="line">SELECT</span><br><span class="line">&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外</span><br><span class="line">DISTINCT</span><br><span class="line"># 数据除重</span><br><span class="line">ORDER BY</span><br><span class="line">&lt;排序条件&gt; # 排序</span><br><span class="line">LIMIT</span><br><span class="line">&lt;行数限制&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">概念</span><br><span class="line">	一个语句中嵌套 select ,  </span><br><span class="line">案例</span><br><span class="line">	select * from student where name=(select student_name from subject)</span><br><span class="line">特点</span><br><span class="line">	1. 一个子查询会返回一个标量（单一值）、一个行、一个列或一个表（一行或多行及一列或多列）。这些子查询被称为标量、列、行和表子查询</span><br><span class="line"></span><br><span class="line">使用限制</span><br><span class="line">1. 子查询必须要位于圆括号中</span><br><span class="line">2. 个子查询的外部语句必须是以下语句之一：SELECT, INSERT, UPDATE, DELETE, SET或DO</span><br><span class="line">3. 不能在一个子查询中修改一个表，又在同一个表中选择</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优势</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="标量-单一值-子查询"><a href="#标量-单一值-子查询" class="headerlink" title="标量(单一值)_子查询"></a>标量(单一值)_子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">概述</span><br><span class="line">	就是子查询只是返回单一值，是一个单一的操作数</span><br><span class="line">	只要单一列值或文字是合法的，并且您希望子查询具有所有操作数都具有的特性，则您就可以使用子查询。操作数具有的特性包括：一个数据类型、一个长度、一个指示是否可以为NULL的标志等</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">限制</span><br><span class="line">	1. 如果一个语句只允许一个文字值，您不能使用子查询。例如，LIMIT要求文字整数自变量，LOAD DATA要求一个文字字符串文件名。您不能使用子查询来提供这些值。</span><br><span class="line">	</span><br><span class="line">重要</span><br><span class="line">	1. 不要忘记子查询的圆括号</span><br><span class="line">	# 一个标量子查询可以为一个表达式的一部分。不要忘记圆括号。即使是子查询是一个为函数提供自变量的操作数时，也不要忘记圆括号</span><br><span class="line">	SELECT UPPER((SELECT s1 FROM t1)) FROM t2;</span><br></pre></td></tr></table></figure>



<h3 id="列-子查询"><a href="#列-子查询" class="headerlink" title="列_子查询"></a>列_子查询</h3><h3 id="行-子查询"><a href="#行-子查询" class="headerlink" title="行_子查询"></a>行_子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">概述</span><br><span class="line">	子查询返回的是一行的数值</span><br><span class="line">	</span><br><span class="line">案例</span><br><span class="line"># 表达式（1，2）和ROW（1，2）有时被称为行构造符。两者是等同的，在其它的语境中，也是合法的</span><br><span class="line">SELECT * FROM t1 WHERE (1,2) = (SELECT column1, column2 FROM t2);</span><br><span class="line">SELECT * FROM t1 WHERE ROW(1,2) = (SELECT column1, column2 FROM t2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">行构造符号</span><br><span class="line">用途</span><br><span class="line">	通常用于与对能返回两个或两个以上列的子查询进行比较</span><br><span class="line">	SELECT column1,column2,column3</span><br><span class="line">    FROM t1</span><br><span class="line">    WHERE (column1,column2,column3) IN</span><br><span class="line">    (SELECT column1,column2,column3 FROM t2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="表-子查询"><a href="#表-子查询" class="headerlink" title="表_子查询"></a>表_子查询</h3><h3 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h3><h4 id="比较语句中使用子查询"><a href="#比较语句中使用子查询" class="headerlink" title="比较语句中使用子查询"></a>比较语句中使用子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1 FROM t1 WHERE column1 = (SELECT MAX(column2) FROM t2);</span><br><span class="line"></span><br><span class="line">可以使用的操作符</span><br><span class="line">	=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;</span><br><span class="line">	</span><br><span class="line">注意</span><br><span class="line">1. 有时， 子查询的合法位置只能在比较式的右侧，您可以发现，在有些旧的DBMSs中仍保持这一点。</span><br><span class="line">2. 对于采用这些操作符之一进行的比较，子查询必须返回一个标量。有一个例外，那就是＝可以和行子查询同时使用【必须在标量中使用】</span><br></pre></td></tr></table></figure>

<h4 id="any-in-some-中使用"><a href="#any-in-some-中使用" class="headerlink" title="any, in some 中使用"></a>any, in some 中使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">operand comparison_operator ANY (subquery)</span><br><span class="line">operand IN (subquery)</span><br><span class="line">operand comparison_operator SOME (subquery)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ANY关键词必须后面接一个比较操作符</span><br><span class="line"># 对于在子查询返回的列中的任一数值，如果比较结果为TRUE的话，则返回TRUE</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);</span><br><span class="line"></span><br><span class="line"># in 是 any 的别名</span><br><span class="line"># not in 不是 &lt;&gt;any 的别名， 而是 &lt;&gt;all 的别名</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);</span><br><span class="line"></span><br><span class="line"># some 是 any 的别名</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY  (SELECT s1 FROM t2);</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="all-子查询"><a href="#all-子查询" class="headerlink" title="all 子查询"></a>all 子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 词语ALL必须接在一个比较操作符的后面。ALL的意思是“对于子查询返回的列中的所有值，如果比较结果为TRUE，则返回TRUE。”</span><br><span class="line"># 通常，包含NULL值的表和空表为“边缘情况”。当编写子查询代码时，都要考虑您是否把这两种可能性计算在内。</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># NOT IN是&lt;&gt; ALL的别名。因此，以下两个语句是相同的：</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);</span><br><span class="line">SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="not-exists"><a href="#not-exists" class="headerlink" title="[not] exists"></a>[not] exists</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">执行逻辑</span><br><span class="line">	# EXISTS 的作用是检查子查询是否有结果，而不是返回子查询的数据</span><br><span class="line">	EXISTS 子查询在执行时不会返回任何具体的数据，它只会返回一个布尔值（True 或者 False）。</span><br><span class="line">	a. 如果子查询中的条件成立（即子查询返回至少一行结果），EXISTS 就会返回 True，然后外部查询会选择符合这个条件的 t1 表中的数据。</span><br><span class="line">	b. 如果子查询没有结果（即返回空），EXISTS 就会返回 False，外部查询就不会选择任何 t1 表中的数据。</span><br><span class="line">SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 1. 从 stores 中查询出所有的的 store_type</span><br><span class="line"># 2. 将查询的 store_type 传入到子查询中，然后执行子查询</span><br><span class="line"># 3. exists 判断子查询是否为空</span><br><span class="line">SELECT DISTINCT store_type FROM stores</span><br><span class="line">WHERE EXISTS (SELECT * FROM cities_stores WHERE cities_stores.store_type = stores.store_type);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">相关联的子查询是一个包含对表的引用的子查询。该表也显示在外部查询中。例如：</span><br><span class="line"># 即使子查询的FROM子句不提及表t1，该子查询也会包含一个对t1中一列的引用。所以，MySQL看上去位于子查询的外部，并在外部查询中查找t1</span><br><span class="line">SELECT * FROM t1 WHERE column1 = ANY</span><br><span class="line">(SELECT column1 FROM t2 WHERE t2.column2 = t1.column2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM (subquery) [AS] name ...</span><br><span class="line">1. [AS] name子句是强制性的，因为FROM子句中的每个表必须有一个名称。在子查询选择列表中的任何列都必须有唯一的名称</span><br><span class="line">2. FROM子句中的子查询可以返回标量、列、行或表。FROM子句中的子查询不能为有关联的子查询。即使对EXPLAIN语句（即建立临时导出表），FROM子句中的子查询也会被执行。这是因为在优化过程中，上一级的查询需要有关所有表的信息</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">SELECT sb1,sb2,sb3</span><br><span class="line">FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb</span><br><span class="line">WHERE sb1 &gt; 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入 - insert"></a>插入 - insert</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># values 插入</span><br><span class="line">INSERT </span><br><span class="line">    [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] # 它们影响插入数据的优先级和行为。</span><br><span class="line">    [INTO] tbl_name [(col_name,...)]</span><br><span class="line">    VALUES (&#123;expr | DEFAULT&#125;,...),(...),...  # 插入的各个值</span><br><span class="line">    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]</span><br><span class="line">    </span><br><span class="line"># set 插入    </span><br><span class="line">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name</span><br><span class="line">    SET col_name=&#123;expr | DEFAULT&#125;, ...</span><br><span class="line">    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]</span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"># select 插入: 一个或多个表中向一个表中插入多个行</span><br><span class="line">INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name [(col_name,...)]</span><br><span class="line">    SELECT ...</span><br><span class="line">    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]</span><br><span class="line"></span><br><span class="line">-- ------------------------------------------------------------------------------------s</span><br><span class="line"></span><br><span class="line">sql 语句执行</span><br><span class="line">    low_priority： 如果表被锁定，则指示MySQL在低负载时执行INSERT。</span><br><span class="line">    high_priority: 告诉MySQL在后台执行INSERT，这在需要处理大量插入请求时很有用。</span><br><span class="line">    delayed: 在表锁定时强制优先处理INSERT语句。</span><br><span class="line">duplicate</span><br><span class="line">	1. 当插入行违反唯一性约束（例如，插入重复键）时执行更新操作。如果出现重复键的情况，这些列将会被更新为新的值。</span><br><span class="line">	在尝试插入一行数据时，如果有重复键（例如，唯一索引或主键），则更新该行数据而不是插入新行，以避免重复。</span><br><span class="line">	2. 只要您不使用SELECT部分中的GROUP BY，您就可以引用在其它表中的列。有一个副作用是，您必须使值部分中的非唯一列的名称符合要求。</span><br><span class="line">	3. 可以使用REPLACE替代INSERT，来覆盖旧行。对于包含唯一关键字值，并复制了旧行的新行，在进行处理时，REPLACE可以作为INSERT IGNORE的同类子句：新行被用于替换旧行，而不是被丢弃。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># values</span><br><span class="line">INSERT INTO users (username, email, birthdate, is_active)</span><br><span class="line">VALUES</span><br><span class="line">    (&#x27;test1&#x27;, &#x27;test1@runoob.com&#x27;, &#x27;1985-07-10&#x27;, true),</span><br><span class="line">    (&#x27;test2&#x27;, &#x27;test2@runoob.com&#x27;, &#x27;1988-11-25&#x27;, false),</span><br><span class="line">    (&#x27;test3&#x27;, &#x27;test3@runoob.com&#x27;, &#x27;1993-05-03&#x27;, true);</span><br><span class="line">    </span><br><span class="line">#set </span><br><span class="line"></span><br><span class="line"># select </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO pet VALUES (&#x27;Puffball&#x27;,&#x27;Diane&#x27;,&#x27;hamster&#x27;,&#x27;f&#x27;,&#x27;1999-03-30&#x27;,NULL);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT DELAYED语法</span><br><span class="line">INSERT DELAYED ...</span><br><span class="line">用于INSERT语句的DELAYED选项是MySQL相对于标准SQL的扩展。如果您的客户端不能等待INSERT完成，则这个选项是非常有用的。当您使用MySQL进行日志编写时，这是非常常见的问题。您也可以定期运行SELECT和UPDATE语句，这些语句花费的时间较长。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#单表语法：</span><br><span class="line">DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name</span><br><span class="line">    [WHERE where_definition]</span><br><span class="line">    [ORDER BY ...]</span><br><span class="line">    [LIMIT row_count]</span><br><span class="line"></span><br><span class="line">#多表语法：</span><br><span class="line">DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span><br><span class="line">    tbl_name[.*] [, tbl_name[.*] ...]</span><br><span class="line">    FROM table_references</span><br><span class="line">    [WHERE where_definition]</span><br><span class="line">或：</span><br><span class="line">DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span><br><span class="line">    FROM tbl_name[.*] [, tbl_name[.*] ...]</span><br><span class="line">    USING table_references</span><br><span class="line">    [WHERE where_definition]</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">delete ： sql的关键字，表示执行删除操作</span><br><span class="line">low_priority： 指定删除任务的优先级较低，DELETE的执行被延迟，直到没有其它客户端读取本表时再执行。</span><br><span class="line">quick： 用于在MySQL中，快速删除数据而不会扫描整个表格。在其他数据库中可能没有这个选项。</span><br><span class="line">where where_definition: 用于指定删除哪些行。【如果省略这个条件，将删除表中所有数据。】</span><br><span class="line">ignore 执行删除时忽略任何错误，继续执行删除操作。</span><br><span class="line">order by 指定删除数据时的排序规则。</span><br><span class="line">limit  指定要删除的行数的限制。如果不指定，则删除符合条件的所有行。</span><br><span class="line">using|on 允许使用表之间的连接关系来删除数据。table_references 是一个连接表（JOIN）的列表，用于指定如何连接表格以进行删除操作。</span><br><span class="line">table_references 参看 select.join</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">限制</span><br><span class="line">1. 您不能在一个多表DELETE语句中使用ORDER BY或LIMIT。</span><br><span class="line">2. 本语法允许在名称后面加.*，以便与Access相容。</span><br><span class="line">3. 如果您使用的多表DELETE语句包括InnoDB表，并且这些表受外键的限制，则MySQL优化程序会对表进行处理，改变原来的从属关系。在这种情况下，该语句出现错误并返回到前面的步骤。要避免此错误，您应该从单一表中删除，并依靠InnoDB提供的ON DELETE功能，对其它表进行相应的修改。</span><br><span class="line">4. 当引用表名称时，您必须使用别名（如果已给定）：</span><br><span class="line"># 下面的例子，没有给别名，就不需要</span><br><span class="line">DELETE t1 FROM test AS t1, test2 WHERE ...</span><br><span class="line">5. 跨数据库进行多表删除的时候，引用表是不能使用别名</span><br><span class="line">DELETE test1.tmp1, test2.tmp2 FROM test1.tmp1, test2.tmp2 WHERE ...</span><br><span class="line">6. 目前，您不能从一个表中删除，同时又在子查询中从同一个表中选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例</span><br><span class="line"># 当搜索待删除的行时，这些语句使用所有三个表，但是只从表t1和表t2中删除对应的行。</span><br><span class="line">DELETE t1, t2 FROM t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span><br><span class="line">DELETE FROM t1, t2 USING t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="demo-2"><a href="#demo-2" class="headerlink" title="demo"></a>demo</h4><h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># MySQL中采用的一个Oracle SQL扩展</span><br><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line"></span><br><span class="line">1. 清空一个表，逻辑上说，该语句与用于删除所有行的DELETE语句等同，但是在有些情况下，两者在使用上有所不同</span><br><span class="line">a, truncate 会取消并重新创建表，这比一行一行的删除行要快很多</span><br><span class="line">b, truncate 不能保证对事务是安全的；在进行事务处理和表锁定的过程中尝试进行删减，会发生错误。</span><br><span class="line">c, truncate  被删除的行的数目没有被返回。</span><br><span class="line">d, 只要表定义文件tbl_name.frm是合法的，则可以使用TRUNCATE TABLE把表重新创建为一个空表，即使数据或索引文件已经被破坏</span><br><span class="line">e, 表管理程序不记得最后被使用的AUTO_INCREMENT值，但是会从头开始计数。即使对于MyISAM和InnoDB也是如此。MyISAM和InnoDB通常不再次使用序列值</span><br><span class="line">f, 当被用于带分区的表时，TRUNCATE TABLE会保留分区；即，数据和索引文件被取消并重新创建，同时分区定义（.par）文件不受影响。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Single-table语法：</span><br><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] tbl_name</span><br><span class="line">    SET col_name1=expr1 [, col_name2=expr2 ...]</span><br><span class="line">    [WHERE where_definition]</span><br><span class="line">    [ORDER BY ...]</span><br><span class="line">    [LIMIT row_count]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Multiple-table语法：</span><br><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] table_references</span><br><span class="line">    SET col_name1=expr1 [, col_name2=expr2 ...]</span><br><span class="line">    [WHERE where_definition]</span><br><span class="line">    </span><br><span class="line">UPDATE语法可以用新值更新原有表行中的各列。</span><br><span class="line">LOW_PRIORITY： </span><br><span class="line">	如果使用了， 则UPDATE的执行被延迟了，直到没有其它的客户端从表中读取为止。</span><br><span class="line">IGNORE</span><br><span class="line">	在更新过程中出现错误，更新语句也不会中断。【如果出现了重复关键字冲突，则这些行不会被更新。如果列被更新后，新值会导致数据转化错误，则这些行被更新为最接近的合法的值。】</span><br><span class="line">SET</span><br><span class="line">	子句指示要修改哪些列和要给予哪些值。</span><br><span class="line">WHERE</span><br><span class="line">	子句指定应更新哪些行。如果没有WHERE子句，则更新所有的行。</span><br><span class="line">ORDER BY	</span><br><span class="line">	1. 按照被指定的顺序对行进行更新。先排序然后进行更新</span><br><span class="line">	2. 不能用于multiple-table UPDATE</span><br><span class="line">limit</span><br><span class="line">	1. 用于给定一个限值，限制可以被更新的行的数目。</span><br><span class="line">	2. 只要发现可以满足WHERE子句的row_count行，则该语句中止，不论这些行是否被改变。</span><br><span class="line">	3. 不能用于multiple-table UPDATE</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">=======================</span><br><span class="line">1. UPDATE赋值被从左到右评估。 </span><br><span class="line">UPDATE persondata SET age=age*2, age=age+1 # 语句对年龄列加倍，然后再进行增加：</span><br><span class="line"></span><br><span class="line">2. 把一列设置为其当前含有的值，则MySQL会注意到这一点，但不会更新。</span><br><span class="line">3. not null 列更新为 null。则该列被设置到与列类型对应的默认值，并且累加警告数。对于数字类型，默认值为0；对于字符串类型，默认值为空字符串(&#x27;&#x27;)；对于日期和时间类型，默认值为“zero”值</span><br><span class="line">4. UPDATE会返回实际被改变的行的数目。Mysql_info() C API函数可以返回被匹配和被更新的行的数目，以及在UPDATE过程中产生的警告的数量。</span><br><span class="line">5. multiple-table UPDATE语句可以使用在SELECT语句中允许的任何类型的联合，比如LEFT JOIN。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="demo-3"><a href="#demo-3" class="headerlink" title="demo"></a>demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 多表联合更新</span><br><span class="line">UPDATE items,month </span><br><span class="line">SET items.price=month.price</span><br><span class="line">WHERE items.id=month.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="待整理-1"><a href="#待整理-1" class="headerlink" title="待整理"></a>待整理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在一个被更改的multiple-table UPDATE中，有些列被引用。您只需要这些列的UPDATE权限。有些列被读取了，但是没被修改。您只需要这些列的SELECT权限。</span><br><span class="line"></span><br><span class="line">如果您使用的multiple-table UPDATE语句中包含带有外键限制的InnoDB表，则MySQL优化符处理表的顺序可能与上下层级关系的顺序不同。在此情况下，语句无效并被 回滚。同时，更新一个单一表，并且依靠ON UPDATE功能。该功能由InnoDB提供，用于对其它表进行相应的修改。请参见15.2.6.4节，“FOREIGN KEY约束”。</span><br><span class="line"></span><br><span class="line">目前，您不能在一个子查询中更新一个表，同时从同一个表中选择。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果你需要重复运行查询(比如说，每天或每周)，可以把它编成一个脚本，则每次执行时不必重新键入。 </span><br><span class="line">可以通过拷贝并编辑脚本文件从类似的现有的查询生成一个新查询。 </span><br><span class="line">当你正在开发查询时，批模式也是很有用的，特别对多行命令或多语句命令序列。如果你犯了一个错误，你不必重新输入所有内容，只需要编辑脚本来改正错误，然后告诉mysql再次执行脚本。 </span><br><span class="line">如果你有一个产生多个输出的查询，你可以通过一个分页器而不是盯着它翻屏到屏幕的顶端来运行输出： </span><br><span class="line">·                shell&gt; mysql &lt; batch-file | more</span><br><span class="line">你可以捕捉文件中的输出以便进行进一步的处理： </span><br><span class="line">·                shell&gt; mysql &lt; batch-file &gt; mysql.out</span><br><span class="line">你可以将脚本分发给另外的人，以便他们也能运行命令。 </span><br><span class="line">某些情况不允许交互地使用，例如, 当你从一个cron任务中运行查询时。在这种情况下，你必须使用批模式。</span><br></pre></td></tr></table></figure>



<h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INFILE <span class="string">&#x27;/path/pet.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> pet;</span><br><span class="line">你愿意，你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql <span class="operator">-</span>h host <span class="operator">-</span>u <span class="keyword">user</span> <span class="operator">-</span>ppassword <span class="operator">&lt;</span> xx.sql</span><br><span class="line">参数：</span><br><span class="line">	<span class="comment">-- force  语句出现错误的时候，仍旧相执行脚本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> source xxx.sql</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line">mysql<span class="operator">&gt;</span> \. filename</span><br></pre></td></tr></table></figure>







<h1 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h1><h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h2><ul>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE animals (</span><br><span class="line">     id MEDIUMINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">     name CHAR(30) NOT NULL,</span><br><span class="line">     PRIMARY KEY (id)</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line">INSERT INTO animals (name) VALUES </span><br><span class="line">    (&#x27;dog&#x27;),(&#x27;cat&#x27;),(&#x27;penguin&#x27;),</span><br><span class="line">    (&#x27;lax&#x27;),(&#x27;whale&#x27;),(&#x27;ostrich&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM animals;</span><br><span class="line">将返回：</span><br><span class="line"></span><br><span class="line">+----+---------+</span><br><span class="line">| id | name    |</span><br><span class="line">+----+---------+</span><br><span class="line">|  1 | dog     |</span><br><span class="line">|  2 | cat     |</span><br><span class="line">|  3 | penguin |</span><br><span class="line">|  4 | lax     |</span><br><span class="line">|  5 | whale   |</span><br><span class="line">|  6 | ostrich |</span><br><span class="line">+----+---------+</span><br><span class="line"></span><br><span class="line">1. 获取自增的最新值。【mysql函数： last_insert_id()】【c函数：mysql_insert_id()】来查询最新的AUTO_INCREMENT值。</span><br><span class="line">    a. 这些函数与具体连接有关，因此其返回值不会被其它执行插入功能的连接影响。</span><br><span class="line">    b. 对于多行插入,从插入的第一行实际返回AUTO_INCREMENT关键字。在复制设置中，通过该函数可以在其它服务器上正确复制多行插入。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MyISAM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 下面的不太懂？？？？</span><br><span class="line">[1] 可以在第二栏指定AUTO_INCREMENT以及多列索引。此时，AUTO_INCREMENT列生成的值的计算方法为：MAX(auto_increment_column) + 1 WHERE prefix=given-prefix。如果想要将数据放入到排序的组中可以使用该方法。</span><br><span class="line">[2]在这种情况下（AUTO_INCREMENT列是多列索引的一部分），如果你在任何组中删除有最大AUTO_INCREMENT值的行，将会重新用到AUTO_INCREMENT值。对于MyISAM表也如此,对于该表一般不重复使用AUTO_INCREMENT值。</span><br><span class="line">[3]如果AUTO_INCREMENT列是多索引的一部分，MySQL将使用该索引生成以AUTO_INCREMENT列开始的序列值。。例如，如果animals表含有索引PRIMARY KEY (grp, id)和INDEX(id)，MySQL生成序列值时将忽略PRIMARY KEY。结果是，该表包含一个单个的序列，而不是符合grp值的序列</span><br><span class="line">[4]要想以AUTO_INCREMENT值开始而不是1，你可以通过CREATE TABLE或ALTER TABLE来设置该值，如下所示:</span><br><span class="line">	ALTER TABLE tbl AUTO_INCREMENT = 100;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE animals (</span><br><span class="line">    grp ENUM(&#x27;fish&#x27;,&#x27;mammal&#x27;,&#x27;bird&#x27;) NOT NULL,</span><br><span class="line">    id MEDIUMINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name CHAR(30) NOT NULL,</span><br><span class="line">    PRIMARY KEY (grp,id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO animals (grp,name) VALUES </span><br><span class="line">    (&#x27;mammal&#x27;,&#x27;dog&#x27;),(&#x27;mammal&#x27;,&#x27;cat&#x27;),</span><br><span class="line">    (&#x27;bird&#x27;,&#x27;penguin&#x27;),(&#x27;fish&#x27;,&#x27;lax&#x27;),(&#x27;mammal&#x27;,&#x27;whale&#x27;),</span><br><span class="line">    (&#x27;bird&#x27;,&#x27;ostrich&#x27;);</span><br><span class="line"> </span><br><span class="line">SELECT * FROM animals ORDER BY grp,id;</span><br><span class="line">将返回：</span><br><span class="line"></span><br><span class="line">+--------+----+---------+</span><br><span class="line">| grp    | id | name    |</span><br><span class="line">+--------+----+---------+</span><br><span class="line">| fish   |  1 | lax     |</span><br><span class="line">| mammal |  1 | dog     |</span><br><span class="line">| mammal |  2 | cat     |</span><br><span class="line">| mammal |  3 | whale   |</span><br><span class="line">| bird   |  1 | penguin |</span><br><span class="line">| bird   |  2 | ostrich |</span><br><span class="line">+--------+----+---------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>BDB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同 MyISAM</span><br></pre></td></tr></table></figure>


</li>
<li><p>注意</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a. 因为AUTO_INCREMENT列必须编制索引。</span><br><span class="line">	若设置为主键则需要定义为NOT NULL，主键列不能为NULL</span><br><span class="line">	当向该列插入一个 null 值(建议)或者0时，此列被设置为下一个序列的值，通常情况是 value+1, 此处 value 是当前表中的列的最大值。</span><br><span class="line">b. auto_increment 序列是从 1 开始的，该列是一种整数烈性。 注意 1.0 不是整数</span><br><span class="line">b. 对于MyISAM表，您可以在ALTER TABLE之前执行SET INSERT_ID=value来设置第一个序号，也可以使用AUTO_INCREMENT=value表选项来设置</span><br><span class="line">c. 如果值大于AUTO_INCREMENT列中的最大值，则您可以使用用于InnoDB表的ALTER TALBE...AUTO_INCREMENT=value表选项，来为新行设置序号。如果值小于列中当前的最大值，不会出现错误信息，当前的序列值也不改变。</span><br><span class="line">d. 使用MyISAM表时，如果您不更改AUTO_INCREMENT列，则序列号不受影响。如果您取消一个AUTO_INCREMENT列，然后添加另一个AUTO_INCREMENT列，则序号重新排列，从1开始。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

















<h1 id="语句控制"><a href="#语句控制" class="headerlink" title="语句控制"></a>语句控制</h1><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 有匹配的返回配置的 <span class="keyword">when</span> 后面的 <span class="keyword">then</span> 的 <span class="keyword">result</span> ,如果 没有匹配的返回 <span class="keyword">else</span> 中的内容， 如果没有 <span class="keyword">else</span> 则返回 <span class="keyword">null</span> </span><br><span class="line"><span class="number">2.</span> <span class="keyword">CASE</span>表达式的默认返回值类型是任何返回值的相容集合类型，但具体情况视其所在语境而定</span><br><span class="line">   如果用在字符串语境中，则返回结果味字符串。如果用在数字语境中，则返回结果为十进制值、实值或整数值</span><br><span class="line"># 	</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">value</span> </span><br><span class="line">	<span class="keyword">WHEN</span> [compare<span class="operator">-</span><span class="keyword">value</span>]  <span class="keyword">THEN</span> <span class="keyword">result</span></span><br><span class="line">    [<span class="keyword">WHEN</span> [compare<span class="operator">-</span><span class="keyword">value</span>] <span class="keyword">THEN</span> <span class="keyword">result</span> ...] </span><br><span class="line">    [<span class="keyword">ELSE</span> <span class="keyword">result</span>]</span><br><span class="line">    <span class="keyword">END</span> </span><br><span class="line"></span><br><span class="line"># </span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line">	<span class="keyword">WHEN</span> [<span class="keyword">condition</span>] <span class="keyword">THEN</span> <span class="keyword">result</span> </span><br><span class="line">	[<span class="keyword">WHEN</span> [<span class="keyword">condition</span>] <span class="keyword">THEN</span> <span class="keyword">result</span> ...] </span><br><span class="line">	[<span class="keyword">ELSE</span> <span class="keyword">result</span>] </span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例</span><br><span class="line">	<span class="keyword">select</span></span><br><span class="line">		<span class="keyword">case</span> </span><br><span class="line">		<span class="keyword">when</span> <span class="built_in">MAX</span>( gxsj ) <span class="keyword">is</span> <span class="keyword">null</span>  <span class="keyword">then</span> <span class="number">1949</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">MAX</span>( gxsj )</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">AS</span> maxtime</span><br><span class="line">	<span class="keyword">from</span> ODS_WUSUO.WSZB	</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">	IF(expr1,expr2,expr3) </span><br><span class="line">	expr1 是TRU </span><br><span class="line">	expr1 是</span><br><span class="line">	expr1</span><br><span class="line">		是 TRUE :   (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL) ：返回值为 expr2</span><br><span class="line">         是 FALSE                                   ：返回值为 expr3</span><br><span class="line">         是 整数： 则为 true, 其他的则需要使用比较运算符进行比较</span><br><span class="line">         </span><br><span class="line">	默认返回值</span><br><span class="line">	    expr2 或者 expr3 返回值有一个是</span><br><span class="line">	     </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">案例</span><br><span class="line">mysql&gt; SELECT IF(1&gt;2,2,3);</span><br><span class="line">-&gt; 3</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT IF(0.1,1,0);</span><br><span class="line">-&gt; 0  -- 原因是 0.1 被转化为整数值，从而引起一个对 IF(0)的检验</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>默认返回值类型</li>
</ul>
<table>
<thead>
<tr>
<th><strong>表达式</strong></th>
<th><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>expr2</em> 或<em>expr3</em>  返回值为一个字符串。</td>
<td>字符串</td>
</tr>
<tr>
<td><em>expr2</em> 或<em>expr3</em>  返回值为一个浮点值。</td>
<td>浮点</td>
</tr>
<tr>
<td><em>expr2</em> 或  <em>expr3</em> 返回值为一个整数。</td>
<td>整数</td>
</tr>
<tr>
<td><em>expr2</em> 和<em>expr3</em>  都是字符串，且其中任何一个字符串区分大小写</td>
<td>区分大小写</td>
</tr>
</tbody></table>
<h2 id="null-if"><a href="#null-if" class="headerlink" title="null-if"></a>null-if</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(expr1,expr2)</span><br><span class="line">expr1 ≠ <span class="keyword">NULL</span>  返回 expr1</span><br><span class="line">expr1 <span class="operator">=</span> <span class="keyword">NULL</span>  返回 expr2</span><br><span class="line"></span><br><span class="line"><span class="built_in">NULLIF</span>(expr1,expr2) </span><br><span class="line">expr1 <span class="operator">=</span> expr2   返回 <span class="keyword">NULL</span></span><br><span class="line">expr1 ≠ expr2   返回  expr1</span><br></pre></td></tr></table></figure>





<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 操作符的优先级和 mysql 的模式有关，但是 () 最高</span><br><span class="line">:=</span><br><span class="line"></span><br><span class="line">||, OR, XOR</span><br><span class="line"></span><br><span class="line">&amp;&amp;, AND</span><br><span class="line"></span><br><span class="line">NOT</span><br><span class="line"></span><br><span class="line">BETWEEN, CASE, WHEN, THEN, ELSE</span><br><span class="line"></span><br><span class="line">=, &lt;=&gt;, &gt;=, &gt;, &lt;=, &lt;, &lt;&gt;, !=, IS, LIKE, REGEXP, IN</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line"></span><br><span class="line">&amp;</span><br><span class="line"></span><br><span class="line">&lt;&lt;, &gt;&gt;</span><br><span class="line"></span><br><span class="line">-, +</span><br><span class="line"></span><br><span class="line">*, /, DIV, %, MOD</span><br><span class="line"></span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">- (一元减号), ~ (一元比特反转)</span><br><span class="line"></span><br><span class="line">!</span><br><span class="line"></span><br><span class="line">BINARY, COLLATE</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1</span><br><span class="line"></span><br><span class="line">在GROUP BY中，</span><br><span class="line">	1. 两个NULL值视为相同。</span><br><span class="line">order by</span><br><span class="line">	1. 如果运行 ORDER BY ... ASC，则NULL值出现在最前面，</span><br><span class="line">	2. 若运行ORDER BY ... DESC，则NULL值出现在最后面。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">“_” 匹配任何单个字符，</span><br><span class="line">“%” 匹配任意数目字符(包括零字符)。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	1. 注意使用SQL模式时，不能使用=或!=；而应使用LIKE或NOT LIKE比较操作符。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四则"><a href="#四则" class="headerlink" title="四则"></a>四则</h2><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>操作符</th>
</tr>
</thead>
<tbody><tr>
<td>有 null</td>
<td>有 null</td>
<td>null-safe 等算符 &lt;&#x3D;&gt;   【正常比较: 两个操作码均为NULL时，其所得值为1而不为NULL，而当一个操作码为NULL时，其所得值为0而不为NULL。】<br />其他运算符   【结果均为 null】</td>
</tr>
<tr>
<td>字符串</td>
<td>字符串</td>
<td>按照字符串比较，字符串比较不区分大小写，并使用现有字符集</td>
</tr>
<tr>
<td>整数</td>
<td>整数</td>
<td>按照整数比较</td>
</tr>
<tr>
<td>数字</td>
<td>字符串</td>
<td>1. MySQL 不能使用列中的索引进行快速查找，原因是许多不同的字符串都可被转换为数值 1: ‘1’、 ‘ 1’、 ‘1a’<br /></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TIMESTAMP 或 DATETIME 列</td>
<td>常数</td>
<td>1. 行比较前将常数转为 timestamp。这样做的目的是为了使ODBC的进行更加顺利<br />2. 注意，这不适合IN()中的参数!为了更加可靠，在进行对比时通常使用完整的  datetime&#x2F;date&#x2F;time字符串。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>在其它情况下，参数作为浮点数进行比较</li>
</ul>
<h2 id="算数计算符"><a href="#算数计算符" class="headerlink" title="算数计算符"></a>算数计算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-, +</span><br><span class="line"></span><br><span class="line">*, /, DIV(取商), %, MOD(取余数)</span><br><span class="line"></span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">- (一元减号, 负号), ~ (一元比特反转)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1, -、 +和 *而言, 若两个参数均为正数，则其计算结果的精确度为 BIGINT (64比特)，若其中一个参数为无符号整数， 而其它参数也是整数, 则结果为无符号整数</span><br><span class="line">2, </span><br></pre></td></tr></table></figure>



<h2 id="匹配符"><a href="#匹配符" class="headerlink" title="匹配符"></a>匹配符</h2><h3 id=""><a href="#" class="headerlink" title="&lt;&#x3D;&gt;"></a>&lt;&#x3D;&gt;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NULL-safe equal.</span><br><span class="line">    mysql&gt; SELECT 1 &lt;=&gt; 1, NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULL   </span><br><span class="line">    mysql&gt; 1, 1, 0</span><br><span class="line">    </span><br><span class="line">is</span><br><span class="line">mysql&gt; SELECT 1 IS TRUE, 0 IS FALSE, NULL IS UNKNOWN;</span><br><span class="line">mysql&gt; 1, 1, 1</span><br><span class="line">mysql&gt; SELECT 1 IS NOT UNKNOWN, 0 IS NOT UNKNOWN, NULL IS NOT UNKNOWN;</span><br><span class="line">mysql&gt; 1, 1, 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">expr LIKE pat [ESCAPE &#x27;escape-char&#x27;] </span><br><span class="line">expr NOT LIKE pat [ESCAPE &#x27;escape-char&#x27;] </span><br><span class="line">escape : 执行转义字符</span><br><span class="line"></span><br><span class="line">like 使用的两种通配符</span><br><span class="line">	%	匹配任何数目的字符，甚至包括零字符， 即 字符格式 &gt;= 0</span><br><span class="line">	_ 	只能匹配一种字符, 字符个数 =1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">特点：</span><br><span class="line">1. 返回1 (TRUE) 或 0 (FALSE)。 若 expr 或 pat 中任何一个为 NULL,则结果为 NULL。</span><br><span class="line">2. like 区分大小写</span><br><span class="line">2.  由于 MySQL在字符串中使用 C转义语法(例如, 用‘\n’代表一个换行字符)，在LIKE字符串中，必须将用到的‘\’双写。例如， 若要查找 ‘\n’, 必须将其写成 ‘\\n’。而若要查找 ‘\’, 则必须将其写成 it as ‘\\\\’;原因是反斜线符号会被语法分析程序剥离一次，在进行模式匹配时，又会被剥离一次，最后会剩下一个反斜线符号接受匹配。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">-- 要指定一个不同的转义字符,可使用ESCAPE语句：如果没有指定 ESCAPE字符, 则假设为‘\’</span><br><span class="line">mysql&gt; SELECT &#x27;David_&#x27; LIKE &#x27;David|_&#x27; ESCAPE &#x27;|&#x27;;</span><br><span class="line"> -&gt; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 在MySQL中, LIKE 允许出现在数字表达式中。 (这是标准SQL LIKE 的延伸）。 </span><br><span class="line">mysql&gt; SELECT 10 LIKE &#x27;1%&#x27;;</span><br><span class="line">-&gt; 1</span><br><span class="line"></span><br><span class="line">在确定字符类型时，REGEXP 和 RLIKE 使用当前字符集 (默认为cp1252 Latin1 )。 警告：这些操作符不支持多字节字元。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr REGEXP pat expr RLIKE pat </span><br><span class="line"></span><br><span class="line">1. 若expr 匹配 pat，则返回 1; 否则返回0。若 expr 或 pat 任意一个为 NULL, 则结果为 NULL。 RLIKE 是REGEXP的同义词, 作用是为mSQL 提供兼容性。</span><br><span class="line">2. REGEXP 不区分大小写, 除非将其同二进制字符串同时使用</span><br><span class="line"></span><br><span class="line">详情见 mysql 正则表达</span><br></pre></td></tr></table></figure>



<h2 id="范围比较"><a href="#范围比较" class="headerlink" title="范围比较"></a>范围比较</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">between ... and ...</span><br><span class="line">	</span><br><span class="line">比较规则</span><br><span class="line">    1. 若所有参数都是同一类型，则上述关系相当于表达式   (min &lt;= expr AND expr &lt;= max)。</span><br><span class="line">    2. 不同种类型进行比较， 则进行类型转换</span><br><span class="line">    </span><br><span class="line">返回值</span><br><span class="line">	expr BETWEEN min AND max ：</span><br><span class="line">	假如expr大于或等于 min 且expr 小于或等于max, 则BETWEEN 的返回值为1,或是0</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">in	</span><br></pre></td></tr></table></figure>



<h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line">	所有逻辑 操作符的求值所得结果均为 TRUE、FALSE或 NULL (UNKNOWN)</span><br><span class="line">	体现为  1 (TRUE)、 0 (FALSE)和 NULL</span><br></pre></td></tr></table></figure>

<h3 id="not-和-！"><a href="#not-和-！" class="headerlink" title="not 和 ！"></a>not 和 ！</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用特例</span><br><span class="line">当操作数为<span class="number">0</span> 时，所得值为 <span class="number">1</span> ；</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOT</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">当操作数为非零值时，所得值为  <span class="number">0</span> ，</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">NOT</span> <span class="number">10</span>;</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">当操作数为<span class="keyword">NOT</span> <span class="keyword">NULL</span>时，所得的返回值为 <span class="keyword">NULL</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="and-和"><a href="#and-和" class="headerlink" title="and 和 &amp;&amp;"></a>and 和 &amp;&amp;</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当所有操作数均为非零值、并且不为<span class="keyword">NULL</span>时，计算所得结果为  <span class="number">1</span> ，</span><br><span class="line">当一个或多个操作数为<span class="number">0</span> 时，所得结果为 <span class="number">0</span> ，</span><br><span class="line">其余情况返回值为 <span class="keyword">NULL</span> </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 两个操作数</span><br><span class="line">真： <span class="number">1</span> , 非<span class="number">0</span></span><br><span class="line">假： <span class="number">0</span></span><br><span class="line">伪假： <span class="keyword">null</span> </span><br><span class="line">    a.  有假则结果假。 有 <span class="number">0</span> 结果为 <span class="number">0</span>， 有 <span class="keyword">null</span> 结果为 <span class="keyword">null</span>, 同时<span class="number">0</span>和<span class="keyword">null</span> 的为 <span class="number">0</span></span><br><span class="line">案例</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="keyword">NULL</span>; <span class="operator">=</span><span class="operator">=</span>》 <span class="keyword">null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> <span class="keyword">NULL</span>; <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="or-和"><a href="#or-和" class="headerlink" title="or 和 ||"></a>or 和 ||</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 两个操作数，有真为真</span><br><span class="line">真： <span class="number">1</span> , 非<span class="number">0</span></span><br><span class="line">假： <span class="number">0</span></span><br><span class="line">伪假： <span class="keyword">null</span> </span><br><span class="line">    a. 有真结果就是 <span class="number">1</span>, 否则就是 <span class="number">0</span></span><br><span class="line">    b. 有 <span class="keyword">null</span> 结果就是 <span class="keyword">null</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">案例</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="number">0</span> <span class="operator">||</span> <span class="keyword">NULL</span>;  <span class="operator">=</span><span class="operator">=</span>》  <span class="keyword">NULL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">||</span> <span class="keyword">NULL</span>;  <span class="operator">=</span><span class="operator">=</span>》 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">作用</span><br><span class="line">	a XOR b 的计算等同于  (a <span class="keyword">AND</span> (<span class="keyword">NOT</span> b)) <span class="keyword">OR</span> ((<span class="keyword">NOT</span> a)和 b)。 </span><br><span class="line">规律</span><br><span class="line">	a. </span><br><span class="line">	</span><br><span class="line">待总结</span><br><span class="line">逻辑XOR。当任意一个操作数为 <span class="keyword">NULL</span>时，返回值为<span class="keyword">NULL</span>。对于非   <span class="keyword">NULL</span> 的操作数，假如一个奇数操作数为非零值，则计算所得结果为  <span class="number">1</span> ，否则为  <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> XOR <span class="number">1</span>;</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> XOR <span class="number">0</span>;</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> XOR <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> XOR <span class="number">1</span> XOR <span class="number">1</span>;</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">子程序： 就是值存储过程和函数</span><br><span class="line">特点：</span><br><span class="line">	一个子程序要么是一个程序要么是一个函数。使用CALL语句来调用程序，程序只能用输出变量传回值。就像别其它函数调用一样，函数可以被从语句外调用（即通过引用函数名），函数能返回标量值。存储子程序也可以调用其它存储子程序。 </span><br><span class="line"></span><br><span class="line">1. 一个存储子程序或函数与特定的数据库相联系</span><br><span class="line">a.  当一个子程序被调用时，一个隐含的USE db_name 被执行（当子程序终止时停止执行）。存储子程序内的USE语句时不允许的</span><br><span class="line">b. 你可以使用数据库名限定子程序名。这可以被用来引用一个不在当前数据库中的子程序。比如，要引用一个与test数据库关联的存储程序p或函数f，你可以说CALL test.p()或test.f()。</span><br><span class="line">c. 数据库移除的时候，与它关联的所有存储子程序也都被移除</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th></th>
<th>存储过程</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>修改数据库</td>
<td>可以修改数据库的内容</td>
<td>是不允许修改数据库的</td>
</tr>
<tr>
<td>调用方式</td>
<td>不能直接嵌入到查询中，需要通过特定的语法来调用执行</td>
<td>可以嵌入到SQL语句中直接调用</td>
</tr>
<tr>
<td>返回值</td>
<td>返回零个或多个结果集</td>
<td>只能返回单个值</td>
</tr>
<tr>
<td>用途</td>
<td>更适用于执行一系列的操作、数据处理和任务执行</td>
<td>通常用于计算并返回单个值。</td>
</tr>
</tbody></table>
<h2 id="暂时不懂"><a href="#暂时不懂" class="headerlink" title="暂时不懂"></a>暂时不懂</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">为进行复制，使用NOW()函数（或它的同义词）或RAND()函数会不必要地使得一个子程序非确定。对NOW()而言，二进制日志包括时间戳并被正确复制。RAND() 只要在一个子程序被内应用一次也会被正确复制。（你可以把子程序执行时间戳和随机数种子认为强制输入，它们在主从上是同样的。） </span><br><span class="line"></span><br><span class="line">当前来讲，DETERMINISTIC特征被接受，但还没有被优化程序所使用。然而如果二进制日志功能被允许了，这个特征影响到MySQL是否会接受子程序定义。请参阅20.4节，“存储子程序和触发程序的二进制日志功能”。 </span><br><span class="line"></span><br><span class="line">一些特征提供子程序使用数据的内在信息。CONTAINS SQL表示子程序不包含读或写数据的语句。NO SQL表示子程序不包含SQL语句。READS SQL DATA表示子程序包含读数据的语句，但不包含写数据的语句。MODIFIES SQL DATA表示子程序包含写数据的语句。如果这些特征没有明确给定，默认的是CONTAINS SQL。 </span><br><span class="line"></span><br><span class="line">SQL SECURITY特征可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是DEFINER。在SQL:2003中者是一个新特性。创建者或调用者必须由访问子程序关联的数据库的许可。在MySQL 5.1中，必须有EXECUTE权限才能执行子程序。必须拥有这个权限的用户要么是定义者，要么是调用者，这取决于SQL SECURITY特征是如何设置的。 </span><br><span class="line"></span><br><span class="line">MySQL存储sql_mode系统变量设置，这个设置在子程序被创建的时候起作用，MySQL总是强制使用这个设置来执行子程序。 </span><br><span class="line"></span><br><span class="line">COMMENT子句是一个MySQL的扩展，它可以被用来描述存储程序。这个信息被SHOW CREATE PROCEDURE和 SHOW CREATE FUNCTION语句来显示。 </span><br><span class="line"></span><br><span class="line">MySQL允许子程序包含DDL语句，如CREATE和DROP。MySQL也允许存储程序（但不是存储函数）包含SQL 交互语句，如COMMIT。存储函数不可以包含那些做明确的和绝对的提交或者做回滚的语。SQL标准不要求对这些语句的支持，SQL标准声明每个DBMS提供商可以决定是否允许支持这些语句。 </span><br><span class="line"></span><br><span class="line">存储子程序不能使用LOAD DATA INFILE。 </span><br><span class="line"></span><br><span class="line">返回结果包的语句不能被用在存储函数种。这包括不使用INTO给变量读取列值的SELECT语句，SHOW 语句，及其它诸如EXPLAIN这样的语句。对于可在函数定义时间被决定要返回一个结果包的语句，发生一个允许从函数错误返回结果包的Not（ER_SP_NO_RETSET_IN_FUNC）。对于只可在运行时决定要返回一个结果包的语句， 发生一个不能在给定上下文错误返回结果包的PROCEDURE %s （ER_SP_BADSELECT)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">控制流程函数</span><br><span class="line">存储过程/函数体 中的流程控制是不一样的</span><br></pre></td></tr></table></figure>



<h1 id="子程序-存储过程"><a href="#子程序-存储过程" class="headerlink" title="子程序 - 存储过程"></a>子程序 - 存储过程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>基础介绍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL5.0 版本开始支持存储过程。</span><br><span class="line"></span><br><span class="line">大多数 SQL 语句都是针对一个或多个表的单条语句。并非所有的操作都那么简单。经常会有一个完整的操作需要多条语句才能完成。</span><br><span class="line"></span><br><span class="line">存储过程简单来说，就是为以后的使用而保存的一条或多条 MySQL 语句的集合。可将其视为批处理文件。虽然他们的作用不仅限于批处理。</span><br><span class="line"></span><br><span class="line">存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。 </span><br></pre></td></tr></table></figure>



<ul>
<li>优点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 通过把处理封装在容易使用的单元中，简化复杂的操作；</span><br><span class="line">2. 简化对变动的管理。如果表名、列名或业务逻辑有变化。只需要更改存储过程的代码，使用它的人员不会改自己的代码；</span><br><span class="line">3. 通常存储过程有助于提高应用程序的性能。当创建的存储过程被编译之后，就存储在数据库中。 但是，MySQL 实现的存储过程略有不同。 MySQL 存储过程按需编译。在编译存储过程之后，MySQL 将其放入缓存中。MySQL 为每个连接维护自己的存储过程高速缓存。如果应用程序在单个连接中多次使用存储过程，则使用编译版本，否则存储过程的工作方式类似于查询；</span><br><span class="line">4. 存储过程有助于减少应用程序和数据库服务器之间的流量，因为应用程序不必发送多个冗长的 SQL 语句，而只用发送存储过程的名称和参数；</span><br><span class="line">5. 存储的程序对任何应用程序都是可重用的和透明的。存储过程将数据库接口暴露给所有应用程序，以便开发人员不必开发存储过程中已支持的功能；</span><br><span class="line">6. 存储的程序是安全的。数据库管理员可以向访问数据库中存储过程的应用程序授予适当的权限，而不向基础数据库表提供任何权限。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<ul>
<li>缺点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 如果使用大量存储过程，那么使用这些存储过程的每个连接的内存使用量将会大大增加。 此外，如果您在存储过程中过度使用大量逻辑操作，则 CPU 使用率也会增加，因为 MySQL 数据库最初的设计侧重于高效的查询，不利于逻辑运算；</span><br><span class="line">2. 存储过程的构造使得开发具有复杂业务逻辑的存储过程变得更加困难；</span><br><span class="line">3. 很难调试存储过程。只有少数数据库管理系统允许您调试存储过程。不幸的是，MySQL 不提供调试存储过程的功能；</span><br><span class="line">4. 开发和维护存储过程并不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可能会导致应用程序开发和维护阶段的问题。 </span><br></pre></td></tr></table></figure>



<ul>
<li>其他</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#介绍</span><br><span class="line">	一个存储程序是可以被存储在服务器中的一套SQL语句。一旦它被存储了，客户端不需要再重新发布单独的语句，而是可以引用存储程序来替代。</span><br><span class="line">	存储过程就是具有名字的一段代码，用来完成一个特定的功能。</span><br><span class="line">	创建的存储过程保存在数据库的数据字典中</span><br><span class="line">	</span><br><span class="line">#优势</span><br><span class="line">	1， 当用不同语言编写多客户应用程序，或多客户应用程序在不同平台上运行且需要执行相同的数据库操作之时</span><br><span class="line">	2， 更为安全。。比如，银行对所有普通操作使用存储程序。这提供一个坚固而安全的环境，程序可以确保每一个操作都被妥善记入日志。在这样一个设置中，应用程序和用户不可能直接访问数据库表，但是仅可以执行指定的存储程序。</span><br><span class="line">	3. 存储程序可以提供改良后的性能，因为只有较少的信息需要在服务器和客户算之间传送</span><br><span class="line">    存储过程可封装，并隐藏复杂的商业逻辑。</span><br><span class="line">    存储过程可以回传值，并可以接受参数。 </span><br><span class="line">    存储过程可以用在数据检验，强制实行商业逻辑等。	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#缺点</span><br><span class="line">	1. 增加数据库服务器系统的负荷，因为更多的工作在服务器这边完成，更少的在客户端（应用程序）那边完成上。如果许多客户端机器（比如网页服务器）只由一个或少数几个数据库服务器提供服务，可以考虑一下存储程序。</span><br><span class="line">	2. 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</span><br><span class="line">	3. 存储过程的性能调校与撰写，受限于各种数据库系统。</span><br><span class="line"></span><br><span class="line">#限制</span><br><span class="line">    存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</span><br></pre></td></tr></table></figure>

<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] PROCEDURE sp_name ([proc_parameter[,...]])</span><br><span class="line">    [characteristic ...] routine_body</span><br><span class="line"> </span><br><span class="line"># 参数 </span><br><span class="line">proc_parameter:</span><br><span class="line">    [ IN | OUT | INOUT ] param_name type</span><br><span class="line"> </span><br><span class="line">#  存储过程的特征</span><br><span class="line">characteristic:</span><br><span class="line">    COMMENT &#x27;string&#x27;   # 注释</span><br><span class="line">  | LANGUAGE SQL # 使用什么语言写</span><br><span class="line">  | [NOT] DETERMINISTIC # 存储过程是否具有确定的</span><br><span class="line">  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; # 对数据库的影响</span><br><span class="line">  | SQL SECURITY &#123; DEFINER | INVOKER &#125; #指定存储过程的执行权限级别的属性</span><br><span class="line"> </span><br><span class="line"># 存储体/函数体·</span><br><span class="line">routine_body:</span><br><span class="line">　　Valid SQL routine statement</span><br><span class="line">　</span><br><span class="line"> ====================================================</span><br><span class="line">函数小括号</span><br><span class="line">	即使没有参数，小括号也不能省略</span><br><span class="line">参数</span><br><span class="line">    输入值使用in参数。</span><br><span class="line">    返回值使用out参数。</span><br><span class="line">    inout参数就尽量的少用。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="demo-4"><a href="#demo-4" class="headerlink" title="demo"></a>demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">delimoter $$</span><br><span class="line">create procedure 函数名(入参/出参 参数名 参数类型)</span><br><span class="line">begin</span><br><span class="line">	select p_in;</span><br><span class="line">	set p_in=2;</span><br><span class="line">	select p_in;</span><br><span class="line">end$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter //</span><br><span class="line">mysql&gt; CREATE PROCEDURE simpleproc (OUT param1 INT)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt;   SELECT COUNT(*) INTO param1 FROM t;</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; //</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名([[IN |OUT |INOUT ] 参数名 数据类形...])</span><br><span class="line"></span><br><span class="line">参数一共有三种：</span><br><span class="line">    IN 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）</span><br><span class="line">    OUT 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）</span><br><span class="line">    INOUT 输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）</span><br></pre></td></tr></table></figure>

<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">delimoter $$</span><br><span class="line">create procedure in_param(in p_in int)</span><br><span class="line">begin</span><br><span class="line">	select p_in;</span><br><span class="line">	set p_in=2;</span><br><span class="line">	select p_in;</span><br><span class="line">end$$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line">set @p_in=1;</span><br><span class="line">mysql&gt; call in_param(@p_in);</span><br><span class="line">+------+</span><br><span class="line">| p_in |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br><span class="line"> </span><br><span class="line">+------+</span><br><span class="line">| P_in |</span><br><span class="line">+------+</span><br><span class="line">|    2 |</span><br><span class="line">+------+</span><br><span class="line"></span><br><span class="line"># p_in 在存储过程中被修改，但并不影响 @p_in 的值，因为前者为局部变量、后者为全局变量</span><br><span class="line">mysql&gt; select @p_in;</span><br><span class="line">+-------+</span><br><span class="line">| @p_in |</span><br><span class="line">+-------+</span><br><span class="line">|     1 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>



<h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure out_param(out p_out int)</span><br><span class="line">begin</span><br><span class="line">	select p_out;</span><br><span class="line">	set p_out=2;</span><br><span class="line">	select p_out;</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">mysql&gt; set @p_out=1;</span><br><span class="line"> </span><br><span class="line">mysql&gt; call out_param(@p_out);</span><br><span class="line">#因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为null</span><br><span class="line">+-------+</span><br><span class="line">| p_out |</span><br><span class="line">+-------+</span><br><span class="line">|  NULL |</span><br><span class="line">+-------+</span><br><span class="line">　　</span><br><span class="line">+-------+</span><br><span class="line">| p_out |</span><br><span class="line">+-------+</span><br><span class="line">|     2 |</span><br><span class="line">+-------+</span><br><span class="line"> </span><br><span class="line">mysql&gt; select @p_out;</span><br><span class="line">#调用了out_param存储过程，输出参数，改变了p_out变量的值</span><br><span class="line">+--------+</span><br><span class="line">| @p_out |</span><br><span class="line">+--------+</span><br><span class="line">|      2 |</span><br><span class="line">+--------+</span><br><span class="line">　　</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure inout_param(inout p_inout int)</span><br><span class="line">begin</span><br><span class="line">	select p_inout;</span><br><span class="line">	set p_inout=2;</span><br><span class="line">	select p_inout;</span><br><span class="line">end $$	</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">mysql&gt; call inout_param(@p_inout);</span><br><span class="line">+---------+</span><br><span class="line">| p_inout |</span><br><span class="line">+---------+</span><br><span class="line">|       1 |</span><br><span class="line">+---------+</span><br><span class="line"> </span><br><span class="line">+---------+</span><br><span class="line">| p_inout |</span><br><span class="line">+---------+</span><br><span class="line">|       2 |</span><br><span class="line">+---------+</span><br><span class="line"> </span><br><span class="line">mysql&gt; select @p_inout;</span><br><span class="line">+----------+</span><br><span class="line">| @p_inout |</span><br><span class="line">+----------+</span><br><span class="line">|        2 |</span><br><span class="line">+----------+</span><br><span class="line">#调用了inout_param存储过程，接受了输入的参数，也输出参数，改变了变量</span><br></pre></td></tr></table></figure>

<h2 id="存储过程特征"><a href="#存储过程特征" class="headerlink" title="存储过程特征"></a>存储过程特征</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#  存储过程的特征</span><br><span class="line">characteristic:</span><br><span class="line">    COMMENT &#x27;string&#x27;   # 注释</span><br><span class="line">  | LANGUAGE SQL # 使用什么语言写</span><br><span class="line">  | [NOT] DETERMINISTIC</span><br><span class="line">  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">  | SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">存储过程特征</span><br><span class="line">1.  LANGUAGE SQL：指定了存储过程使用的语言类型。对于绝大多数情况，MySQL的存储过程是使用SQL语言编写的。然而，并非所有的数据库管理系统都仅限于使用SQL语言编写存储过程。一些数据库允许存储过程使用其他编程语言编写，比如PL/SQL（Oracle）、T-SQL（SQL Server）或者使用类似于JavaScript、Python等的脚本语言。</span><br><span class="line">2. determictic: 确定性：如果一个存储过程被标记为确定性（DETERMINISTIC），那么对于给定的输入参数，它总是产生相同的输出。换句话说，无论何时调用具有相同参数的存储过程，都会得到相同的结果。这在某些情况下非常重要，尤其是当存储过程执行的操作是基于输入参数并且不依赖于外部因素时。 确定性对于数据库引擎来说很重要，因为它会影响到数据库的查询优化和缓存。确定性的存储过程更容易被优化和缓存，因为相同的输入总是产生相同的输出，而非确定性的存储过程则更难被优化，因为无法预测其输出。</span><br><span class="line"></span><br><span class="line">3. 存储过程对数据库影响的属性。这些属性的定义有助于数据库管理系统优化存储过程的执行方式，尤其是在涉及到缓存、权限管理以及性能优化方面。指定正确的属性可以帮助数据库系统更好地理解和处理存储过程，以提高执行效率和安全性。</span><br><span class="line">CONTAINS SQL: 这表示存储过程包含SQL语句。大多数存储过程都属于这个类别，因为它们通常包含执行SQL查询或更新的语句。</span><br><span class="line">NO SQL: 表示存储过程不包含任何SQL语句。它可能是一个计算型的过程，不涉及数据库的读取或写入操作，可能执行一些逻辑运算或控制流操作。</span><br><span class="line">READS SQL DATA: 表示存储过程可能会读取数据库中的数据，但不会修改（写入）数据。它可能会执行SELECT语句或者一些只读的操作。</span><br><span class="line">MODIFIES SQL DATA: 表示存储过程可能会修改数据库中的数据，可能包括INSERT、UPDATE、DELETE等会改变数据库内容的操作。</span><br><span class="line"></span><br><span class="line">4. 权限。选择适当的SQL SECURITY级别取决于存储过程的目的以及安全需求。使用DEFINER级别可以确保存储过程在固定的权限下执行，而INVOKER级别则允许存储过程根据调用者的权限动态执行。不同的数据库管理系统可能对SQL SECURITY的实现有所不同，因此在具体使用时，需要参考相应数据库的文档以了解具体的行为和限制。</span><br><span class="line"></span><br><span class="line">SQL SECURITY是用来指定存储过程的执行权限级别的属性。</span><br><span class="line"></span><br><span class="line">DEFINER: 当存储过程以定义者（DEFINER）的权限级别执行时，它将以存储过程的创建者（定义者）的权限来执行。这意味着无论谁调用存储过程，都会以创建者的权限来执行其中的SQL语句。这通常用于确保存储过程以创建者的权限执行，无论调用者的权限是什么。</span><br><span class="line"></span><br><span class="line">INVOKER: 当存储过程以调用者（INVOKER）的权限级别执行时，它将以调用者的权限来执行。换句话说，存储过程内部的SQL语句将按照调用者的权限级别来执行。这对于需要根据调用者权限动态执行SQL语句的情况很有用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="存储-函数体"><a href="#存储-函数体" class="headerlink" title="存储&#x2F;函数体"></a>存储&#x2F;函数体</h2><h3 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimeter $$ 防止语句被解析 </span><br></pre></td></tr></table></figure>



<h3 id="begin-end"><a href="#begin-end" class="headerlink" title="begin  end"></a>begin  end</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 复合语句: 来包含多个语句</span><br><span class="line">[begin_label:] BEGIN</span><br><span class="line">　　[statement_list]</span><br><span class="line">　　　　……</span><br><span class="line">END [end_label]  </span><br><span class="line"></span><br><span class="line">begin 与end 表示过程主体的开始和结束，相当于 Java 定义方法的一对大括号；</span><br></pre></td></tr></table></figure>



<h3 id="if-1"><a href="#if-1" class="headerlink" title="if"></a>if</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IF search_condition THEN statement_list</span><br><span class="line">	[ELSEIF search_condition THEN statement_list] ...</span><br><span class="line">	[ELSE statement_list]</span><br><span class="line">END IF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create procedure test2(in num int)</span><br><span class="line">begin</span><br><span class="line">	if num&lt;0 then</span><br><span class="line">		select &#x27;负数&#x27;</span><br><span class="line">	elseif num=0 then</span><br><span class="line">		select &#x27;不是正数也不是负数&#x27;</span><br><span class="line">	else</span><br><span class="line">		select &#x27;正数&#x27;</span><br><span class="line">	end if;</span><br><span class="line">end;	</span><br></pre></td></tr></table></figure>



<h3 id="case-1"><a href="#case-1" class="headerlink" title="case"></a>case</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">    WHEN when_value THEN statement_list</span><br><span class="line">    [WHEN when_value THEN statement_list] ...</span><br><span class="line">    [ELSE statement_list]</span><br><span class="line">END CASE</span><br><span class="line"> </span><br><span class="line">CASE</span><br><span class="line">    WHEN search_condition THEN statement_list</span><br><span class="line">    [WHEN search_condition THEN statement_list] ...</span><br><span class="line">    [ELSE statement_list]</span><br><span class="line">END CASE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 适合范围值判断</span><br><span class="line">create procedure test1(in num int)</span><br><span class="line">begin</span><br><span class="line">	case </span><br><span class="line">		when num &lt; 0 then select &#x27;负数&#x27;;</span><br><span class="line">		when num = 0 then select &#x27;不是正数也不是负数&#x27;;</span><br><span class="line">		when num &gt; 0 then select &#x27;正数&#x27;;</span><br><span class="line">	end case;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 适合准确值判断</span><br><span class="line">create procedure test2(in num int)</span><br><span class="line">begin</span><br><span class="line">	case num</span><br><span class="line">		when 1 then select &#x27;1&#x27;;</span><br><span class="line">		when 2 then select &#x27;2&#x27;;</span><br><span class="line">		else select &#x27;不确定输入的是几&#x27;;</span><br><span class="line">	end case;</span><br><span class="line">end;	</span><br></pre></td></tr></table></figure>



<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] WHILE search_condition DO</span><br><span class="line">    statement_list</span><br><span class="line">END WHILE [end_label]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定义存储过程，实现 1+...+10</span><br><span class="line">create producer test(out sum int)</span><br><span class="line">begin</span><br><span class="line">	declare num int default 0;</span><br><span class="line">	set num = 0;</span><br><span class="line">	while num &lt; 10 do</span><br><span class="line">		set num = num + 1;</span><br><span class="line">		set sum = sum + num;-3--</span><br><span class="line">	end while;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call test(@sum)  -- 调用存储过程</span><br><span class="line">select @sum  -- 获取结果</span><br></pre></td></tr></table></figure>

<h3 id="repeat-循环"><a href="#repeat-循环" class="headerlink" title="repeat 循环"></a>repeat 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] REPEAT</span><br><span class="line">    statement_list</span><br><span class="line">UNTIL search_condition</span><br><span class="line">END REPEAT [end_label]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用法</span><br><span class="line">	repeat语句的用法和 java中的 do…while 语句类似，都是先执行循环操作，再判断条件，区别是 repeat表达</span><br><span class="line">式值为 false时才执行循环操作，直到表达式值为 true停止。</span><br><span class="line"></span><br><span class="line">demo </span><br><span class="line">create procedure test(out sum int)</span><br><span class="line">begin </span><br><span class="line">	declare num int default 0;</span><br><span class="line">	set sum = 0;</span><br><span class="line">	repeat</span><br><span class="line">		set num = num + 1;</span><br><span class="line">		set sum = sum + num;</span><br><span class="line">		util num &gt;= 10</span><br><span class="line">	end repeat;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call test(@sum); -- 调用过程</span><br><span class="line">select @sum -- 查询结果</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">    statement_list</span><br><span class="line">END LOOP [end_label]</span><br><span class="line"></span><br><span class="line">1. 无限循环，需要使用 leave 退出</span><br><span class="line"></span><br><span class="line">create procedure test(out sum int)</span><br><span class="line">begin</span><br><span class="line">	declare num int default 0;</span><br><span class="line">	set sum = 0;</span><br><span class="line">	loop_flag: loop</span><br><span class="line">	set num = num + 1;</span><br><span class="line">	set sum = sum + num;</span><br><span class="line">	if num &gt;= 10 then leave loop_flag;</span><br><span class="line">	end if;</span><br><span class="line">	end loop loop_flag;	</span><br><span class="line">end;</span><br><span class="line">call test(@sum) -- 调用过程</span><br><span class="line">select @sum -- 查询变量</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="leave-break"><a href="#leave-break" class="headerlink" title="leave &#x3D;&#x3D;&gt; break"></a>leave &#x3D;&#x3D;&gt; break</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAVE label</span><br><span class="line"># 等效于 java 中的 break</span><br><span class="line">这个语句被用来退出任何被标注的流程控制构造。它和BEGIN ... END或循环一起被使用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="iterete-continue"><a href="#iterete-continue" class="headerlink" title="iterete &#x3D;&#x3D;&gt; continue"></a>iterete &#x3D;&#x3D;&gt; continue</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br><span class="line"># 等效于 java 中的 continue</span><br><span class="line">ITERATE只可以出现在LOOP, REPEAT, 和WHILE语句内。ITERATE意思为：“再次循环。” </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 直接使用 navicate 即可</span><br><span class="line">查询存储过程</span><br><span class="line">show procedure status;</span><br><span class="line"></span><br><span class="line">显示特定数据库的存储过程</span><br><span class="line">show procedure status where db=&#x27;test&#x27;;</span><br><span class="line"></span><br><span class="line">显示特定模式的存储过程，要求显示莫名成中包含 tes 的存储过程</span><br><span class="line">show procedure status where name like &#x27;%tes%&#x27;</span><br><span class="line"></span><br><span class="line">删除存储过程 test</span><br><span class="line">drop procedure test;</span><br></pre></td></tr></table></figure>





<h1 id="子程序-函数"><a href="#子程序-函数" class="headerlink" title="子程序 - 函数"></a>子程序 - 函数</h1><h2 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 1. RETURNS字句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。 </span><br><span class="line"># 2. </span><br><span class="line">CREATE FUNCTION sp_name ([func_parameter[,...]]) RETURNS type</span><br><span class="line">    [characteristic ...] routine_body</span><br><span class="line">    </span><br><span class="line">    proc_parameter:</span><br><span class="line">    [ IN | OUT | INOUT ] param_name type</span><br><span class="line">    </span><br><span class="line">    func_parameter:</span><br><span class="line">    param_name type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type:</span><br><span class="line">    Any valid MySQL data type</span><br><span class="line"></span><br><span class="line">routine_body:</span><br><span class="line">	# 合法的SQL过程语句。可以使用复合语句语法，复合语句可以包含声明，循环和其它控制结构语句</span><br><span class="line">    Valid SQL procedure statement or statements</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==================</span><br><span class="line">1. CREATE FUNCTION语句被用在更早的MySQL版本上以支持UDF （自定义函数）。 UDF继续被支持，即使现在有了存储函数。UDF会被认为一个外部存储函数。然而，不要让存储函数与UDF函数共享名字空间。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">version()  mysql数据库的版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="待整理-2"><a href="#待整理-2" class="headerlink" title="待整理"></a>待整理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">COALESCE(value,...) : </span><br><span class="line">	[coalesce]返回值为列表当中的第一个非 NULL值，全部都是 NULL 值得情况下返回值为 NULL </span><br><span class="line"></span><br><span class="line">GREATEST(value1,value2,...) [greatest]</span><br><span class="line">    1. 当有2或多个参数时，返回值为最大(最大值的)参数。比较参数所依据的规律同LEAST()相同。</span><br><span class="line">    2. 没有参数，则返回 null</span><br><span class="line">    </span><br><span class="line">expr IN (value,...) </span><br><span class="line">	expr 为IN列表中的任意一个值，则其返回值为 1 , 否则返回值为0</span><br><span class="line">	1. 如果 value 都是常数， 则使用二分法进行搜索</span><br><span class="line">	2. 如果 expr 是个区分大小的字符串，则字符串比较也按照区分大小的方式进行</span><br><span class="line">	3. 为了同SQL 标准相一致，在左侧表达式为NULL的情况下，或是表中找不到匹配项或是表中一个表达式为NULL 的情况下，IN的返回值均为NULL</span><br><span class="line">	4. IN 列表中所列值的个数仅受限于 max_allowed_packet 值</span><br><span class="line">	</span><br><span class="line">expr NOT IN (value,...) 等价于 NOT (expr IN (value,...)) 。 </span><br><span class="line">	</span><br><span class="line">ISNULL(expr) </span><br><span class="line">	1. expr 为NULL，那么ISNULL() 的返回值为 1，否则返回值为 0。 </span><br><span class="line">	2. 同 IS NULL比较操作符具有一些相同的特性</span><br><span class="line">	</span><br><span class="line">INTERVAL(N,N1,N2,N3,...) [interval]  ??????</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">LEAST(value1,value2,...)  [least]</span><br><span class="line">	1. 返回参数中的最小值 ？？？？？？？？？</span><br><span class="line">	假如返回值被用在一个 INTEGER 语境中，或是所有参数均为整数值，则将其作为整数值进行比较。 </span><br><span class="line">    假如返回值被用在一个 REAL语境中，或所有参数均为实值，则 将其作为实值进行比较。 </span><br><span class="line">    假如任意一个参数是一个区分大小写的字符串，则将参数按照区分大小写的字符串进行比较。 </span><br><span class="line">    在其它情况下，将参数作为区分大小写的字符串进行比较。 </span><br><span class="line">    假如任意一个自变量为NULL，则 LEAST()的返回值为NULL 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">什么是视图</span><br><span class="line">	视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的。</span><br><span class="line"></span><br><span class="line">　　通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用视图动态生成。</span><br><span class="line"></span><br><span class="line">基表：用来创建视图的表叫做基表base table</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</span><br><span class="line"></span><br><span class="line">安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</span><br><span class="line"></span><br><span class="line">数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响</span><br></pre></td></tr></table></figure>


</li>
<li><p>缺点</p>
</li>
</ul>
<h2 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE]   </span><br><span class="line">　　[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]  </span><br><span class="line">　　[DEFINER = &#123; user | CURRENT_USER &#125;]  </span><br><span class="line">　　[SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span><br><span class="line">VIEW view_name [(column_list)]  </span><br><span class="line">AS select_statement  </span><br><span class="line">　　[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">使用</span><br><span class="line">	视图一旦创建完毕，就可以像一个普通表那样使用，视图主要用来查询</span><br><span class="line"></span><br><span class="line">权限：</span><br><span class="line">	1. create view 权限， select 每一列权限</span><br><span class="line">	2. select 权限</span><br><span class="line">	3. or replace : drop 权限</span><br><span class="line"> 	</span><br><span class="line"> 	# 总结</span><br><span class="line">　   使用root用户定义一个视图(推荐使用第一种)：u1、u2</span><br><span class="line">　　　　1）u1作为定义者定义一个视图，u1对基表有select权限，u2对视图有访问权限：u2是以定义者的身份访问可以查询到基表的内容；</span><br><span class="line">　　　　2）u1作为定义者定义一个视图，u1对基表没有select权限，u2对视图有访问权限，u2对基表有select权限：u2访问视图的时候是以调用者的身份，此时调用者是u2，可以查询到基表的内容。	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">·         SELECT语句不能包含FROM子句中的【子查询】</span><br><span class="line">·         SELECT语句不能引用系统或用户变量。</span><br><span class="line">·         SELECT语句不能引用预处理语句参数。</span><br><span class="line">·         在存储子程序内，定义不能引用子程序参数或局部变量。</span><br><span class="line">·         在定义中引用的表或视图必须存在。但是，创建了视图后，能够舍弃定义引用的表或视图。要想检查视图定义是否存在这类问题，可使用CHECK TABLE语句。</span><br><span class="line">·         在定义中不能引用TEMPORARY表，不能创建TEMPORARY视图。</span><br><span class="line">·         在视图定义中命名的表必须已存在。</span><br><span class="line">·         不能将触发程序与视图关联在一起。</span><br><span class="line">·         如果创建了视图，并通过更改系统变量更改了查询处理环境，会影响从视图获得的结果</span><br></pre></td></tr></table></figure>



<ul>
<li>create [or replace]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create 创建视图</span><br><span class="line">or replace 	替换已有的视图</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>ALGORITHM</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ALGORITHM：表示视图选择算法 </span><br><span class="line">	1. 对于 MERGE合并[将视图的语句与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分]，会将引用视图的语句的文本与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分。</span><br><span class="line">	2. 对于 TEMPTABLE临时表[将视图的结果存入临时表，然后使用临时表执行语句]，视图的结果将被置于临时表中，然后使用它执行语句。MERGE算法要求视图中的行和基表中的行具有一对一的关系。如果不具有该关系。必须使用临时表取而代之。如果视图包含下述结构中的任何一种，将失去一对一的关系：</span><br><span class="line">·         聚合函数（SUM(), MIN(), MAX(), COUNT()等）。</span><br><span class="line">·         DISTINCT </span><br><span class="line">·         GROUP BY </span><br><span class="line">·         HAVING </span><br><span class="line">·         UNION或UNION ALL </span><br><span class="line">·         仅引用文字值（在该情况下，没有基本表）。</span><br><span class="line"> </span><br><span class="line">	3. 对于 UNDEFINED【未定义的,默认】。</span><br><span class="line">	总结： 1.如果可能，mysql倾向于MERGE而不是TEMPTABLE，这是因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。</span><br><span class="line">	总结： 2. 明确选择TEMPTABLE的1个原因在于，创建临时表之后、并在完成语句处理之前，能够释放基表上的锁定。与MERGE算法相比，锁定释放的速度更快，这样，使用视图的其他客户端不会被屏蔽过长时间。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<ul>
<li>DEFINER</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFINER</span><br><span class="line">	指出谁是视图的创建者或定义者</span><br><span class="line">	definer= &#x27;用户名&#x27;@&#x27;登录主机&#x27;</span><br><span class="line">    如果不指定该选项，则创建视图的用户就是定义者，指定关键字CURRENT_USER(当前用户)和不指定该选项效果相同</span><br></pre></td></tr></table></figure>

<ul>
<li>SQL SECURITY { DEFINER | INVOKER }</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL SECURITY选项：要查询一个视图，首先必须要具有对视图的select权限。</span><br><span class="line"></span><br><span class="line">　　但是，如果同一个用户对于视图所访问的表没有select权限，那会怎么样？</span><br><span class="line"></span><br><span class="line">SQL SECURITY选项决定执行的结果：</span><br><span class="line"></span><br><span class="line">　　①SQL SECURITY DEFINER：定义(创建)视图的用户必须对视图所访问的表具有select权限，也就是说将来其他用户访问表的时候以定义者的身份，此时其他用户并没有访问权限。</span><br><span class="line"></span><br><span class="line">　　②SQL SECURITY INVOKER：访问视图的用户必须对视图所访问的表具有select权限。</span><br><span class="line"></span><br><span class="line">缺省SQL SECURITY选项等同于SQL SECURITY DEFINER</span><br></pre></td></tr></table></figure>



<ul>
<li>view name</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viwe_name 视图名</span><br><span class="line">	1、 表和视图共享数据库中相同的名称空间，因此，数据库不能包含具有相同名称的表和视图</span><br><span class="line">	2、 视图必须具有唯一的列名，不得有重复，就像基表那样。默认情况下，由SELECT语句检索的列名将用作视图列名。要想为视图列定义明确的名称，可使用可选的column_list子句，列出由逗号隔开的ID。column_list中的名称数目必须等于SELECT语句检索的列数。</span><br><span class="line">	1. 视图属于数据库，默认在当前数据数据库创建视图.要想在给定数据库中明确创建视图，创建时，应将名称指定为db_name.view_name。 </span><br></pre></td></tr></table></figure>



<ul>
<li>select_statement</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select_statement  </span><br><span class="line">	1. 是一种SELECT语句，它给出了视图的定义。该语句可从基表或其他视图进行选择。 </span><br><span class="line">	2、SELECT语句检索的列可以是对表列的简单引用。也可以是使用函数、常量值、操作符等的表达式。</span><br><span class="line">	3、对于SELECT语句中不合格的表或视图，将根据默认的数据库进行解释。通过用恰当的数据库名称限定表或视图名，视图能够引用表或其他数据库中的视图</span><br><span class="line">	4、</span><br></pre></td></tr></table></figure>

<ul>
<li>WITH CHECK OPTION</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义时可以带上WITH CHECK OPTION约束	</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]：表</span><br><span class="line">	对于可以执行DML操作的视图，需要带上，对视图所做的DML操作的结果，不能违反视图的WHERE条件的限制。视图在更新时保证在视图的权限范围之内【推荐使用，可以保证数据的安全性 】 </span><br><span class="line">　　cascade 表示更新视图的时候，要满足视图和表的相关条件【检查所有的视图，默认值】</span><br><span class="line">　　local表示更新视图的时候，要满足该视图定义的一个条件即可.【只检查将要更新的视图本身】</span><br></pre></td></tr></table></figure>







<h3 id="demo-创建视图"><a href="#demo-创建视图" class="headerlink" title="demo-创建视图"></a>demo-创建视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 从一个表创建视图</span><br><span class="line">create view v_F_players(编号，名字，性别，电话)</span><br><span class="line">as</span><br><span class="line">select PLAYERNO,NAME,GENDER,PHONE from PLAYERS </span><br><span class="line">where GENDER=&#x27;A&#x27;；</span><br><span class="line">with check option;</span><br><span class="line"></span><br><span class="line">select * from v_F_players；  -- 调用</span><br><span class="line"></span><br><span class="line"># 从两个表创建视图</span><br><span class="line"># 如果创建视图时不明确指定视图的列名，那么列名就和定义视图的select子句中的列名完全相同；</span><br><span class="line"># 如果显式的指定视图的列名就按照指定的列名</span><br><span class="line">create view v_match</span><br><span class="line">as</span><br><span class="line">select a.PLAYERNO,a.NAME, WON, MARCHNO, c.TEAMNO, c.DIVISION </span><br><span class="line">from</span><br><span class="line">PLAYERS a, MATCHES b, TEAMS c</span><br><span class="line">where a.PLAYERNO=b.PLAYERNO and b.TEAMNO=c.TEAMNO;</span><br></pre></td></tr></table></figure>



<h3 id="demo-with-check-option"><a href="#demo-with-check-option" class="headerlink" title="demo_with-check-option"></a>demo_with-check-option</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">create view v_test</span><br><span class="line">as</span><br><span class="line">select * from PLAYERS</span><br><span class="line">where birth_date &lt; &#x27;1960-01-01&#x27;</span><br><span class="line">with check option;</span><br><span class="line"></span><br><span class="line"># 更新</span><br><span class="line">update v_test</span><br><span class="line">set BIRTH_DATE=&#x27;1970-09-01&#x27;</span><br><span class="line">where PLAYERNO=39;</span><br><span class="line"></span><br><span class="line"># 抛出异常</span><br><span class="line">ERROR 1369 (HY000): CHECK OPTION failed </span><br><span class="line">&#x27;TENNIS.v_veterans&#x27;</span><br><span class="line">因为违反了视图中的WHERE birth_date &lt; &#x27;1960-01-01&#x27;子句，所以抛出异常；</span><br><span class="line">利用with check option约束限制，保证更新视图是在该视图的权限范围之内。</span><br></pre></td></tr></table></figure>

<h3 id="demo-视图嵌套"><a href="#demo-视图嵌套" class="headerlink" title="demo_视图嵌套"></a>demo_视图嵌套</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create view v_ear_venterans</span><br><span class="line">as</span><br><span class="line">select * from v_venterans</span><br><span class="line">where JOINED &lt; 1980;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 删除视图是指删除数据库中已存在的视图，删除视图时，只能删除视图的定义，不会删除数据，也就是说不动基表：</span><br><span class="line">DROP VIEW [IF EXISTS]</span><br><span class="line">    view_name [, view_name] ...</span><br><span class="line">    [RESTRICT | CASCADE]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">DROP VIEW: 能够删除1个或多个视图。必须在每个视图上拥有DROP权限。</span><br><span class="line"></span><br><span class="line">[IF EXISTS]: 这是一个可选的部分，表示如果视图存在，则执行删除操作。如果视图不存在，而这个选项被指定了，那么不会出现错误，命令会继续执行而不会中断，将为每个不存在的视图生成NOTE。</span><br><span class="line"></span><br><span class="line">view_name [, view_name] ...: 这里是要删除的视图的名称列表。你可以在一个 DROP VIEW 命令中同时指定多个视图名称，用逗号分隔开。</span><br><span class="line"></span><br><span class="line">[RESTRICT | CASCADE]: 这是针对存在依赖关系的情况下的操作选项：</span><br><span class="line">	RESTRICT: 如果其他对象依赖于要删除的视图，那么会阻止删除操作，并返回错误信息。</span><br><span class="line">	CASCADE: 如果其他对象依赖于要删除的视图，会先删除这些依赖于该视图的对象，然后再删除视图本身。</span><br><span class="line">所以，这个语法允许你安全地</span><br></pre></td></tr></table></figure>





<h2 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">    VIEW view_name [(column_list)]</span><br><span class="line">    AS select_statement</span><br><span class="line">    [WITH [CASCADED | LOCAL] CHECK OPTION]</span><br><span class="line">1.该语句用于更改已有视图的定义</span><br><span class="line">2.该语句需要具有针对视图的CREATE VIEW和DROP权限，也需要针对SELECT语句中引用的每一列的某些权限。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="查询-3"><a href="#查询-3" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE VIEW view_name</span><br><span class="line">获取 create view 的完整语句，该语句给出了1个创建给定视图的CREATE VIEW语句。</span><br></pre></td></tr></table></figure>



<h2 id="DML-更新"><a href="#DML-更新" class="headerlink" title="DML_更新"></a>DML_更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 因为视图本身没有数据，因此对视图进行的dml操作最终都体现在基表中</span><br><span class="line"># 视图的DML操作，不是所有的视图都可以做DML操作。</span><br><span class="line">　　①select子句中包含distinct</span><br><span class="line">　　②select子句中包含组函数</span><br><span class="line">　　③select语句中包含group by子句</span><br><span class="line">　　④select语句中包含order by子句</span><br><span class="line">　　⑤select语句中包含union 、union all等集合运算符</span><br><span class="line">　　⑥where子句中包含相关子查询</span><br><span class="line">　　⑦from子句中包含多个表</span><br><span class="line">　　⑧如果视图中有计算列，则不能更新</span><br><span class="line">　　⑨如果基表中有某个具有非空约束的列未出现在视图定义中，则不能做insert操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">某些视图是可更新的。也就是说，可以在诸如UPDATE、DELETE或INSERT等语句中使用它们，以更新基表的内容。对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。还有一些特定的其他结构，这类结构会使得视图不可更新。更具体地讲，如果视图包含下述结构中的任何一种，那么它就是不可更新的：</span><br><span class="line"></span><br><span class="line">·         聚合函数（SUM(), MIN(), MAX(), COUNT()等）。</span><br><span class="line">·         DISTINCT </span><br><span class="line">·         GROUP BY </span><br><span class="line">·         HAVING </span><br><span class="line">·         UNION或UNION ALL </span><br><span class="line">·         位于选择列表中的子查询</span><br><span class="line">·         Join </span><br><span class="line">·         FROM子句中的不可更新视图</span><br><span class="line">·         WHERE子句中的子查询，引用FROM子句中的表。</span><br><span class="line">·         仅引用文字值（在该情况下，没有要更新的基本表）。</span><br><span class="line">·         ALGORITHM = TEMPTABLE（使用临时表总会使视图成为不可更新的）。</span><br><span class="line"></span><br><span class="line">混合了简单列引用和导出列的视图是不可插入的，但是，如果仅更新非导出列，视图是可更新的。考虑下述视图：</span><br><span class="line"></span><br><span class="line">CREATE VIEW v AS SELECT col1, 1 AS col2 FROM t;</span><br><span class="line">该视图是不可插入的，这是因为col2是从表达式导出的。但是，如果更新时不更新col2，它是可更新的。这类更新是允许的：</span><br><span class="line"></span><br><span class="line">UPDATE v SET col1 = 0;</span><br><span class="line">下述更新是不允许的，原因在于，它试图更新导出列：</span><br><span class="line"></span><br><span class="line">UPDATE v SET col2 = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DML-插入"><a href="#DML-插入" class="headerlink" title="DML_插入"></a>DML_插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">关于可插入性（可用INSERT语句更新），如果它也满足关于视图列的下述额外要求，可更新的视图也是可插入的：</span><br><span class="line">·         不得有重复的视图列名称。</span><br><span class="line">·         视图必须包含没有默认值的基表中的所有列。</span><br><span class="line">·         视图列必须是简单的列引用而不是导出列。导出列不是简单的列引用，而是从表达式导出的。下面给出了一些导出列示例：</span><br><span class="line">·                3.14159</span><br><span class="line">·                col1 + 3</span><br><span class="line">·                UPPER(col2)</span><br><span class="line">·                col3 / col4</span><br><span class="line">·                (subquery)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="不懂"><a href="#不懂" class="headerlink" title="不懂"></a>不懂</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">在视图定义中允许使用ORDER BY，但是，如果从特定视图进行了选择，而该视图使用了具有自己ORDER BY的语句，它将被忽略。</span><br><span class="line"></span><br><span class="line">对于定义中的其他选项或子句，它们将被增加到引用视图的语句的选项或子句中，但效果未定义。例如，如果在视图定义中包含LIMIT子句，而且从特定视图进行了选择，而该视图使用了具有自己LIMIT子句的语句，那么对使用哪个LIMIT未作定义。相同的原理也适用于其他选项，如跟在SELECT关键字后的ALL、DISTINCT或SQL_SMALL_RESULT，并适用于其他子句，如INTO、FOR UPDATE、LOCK IN SHARE MODE、以及PROCEDURE。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在某些情况下，能够更新多表视图，假定它能使用MERGE算法进行处理。为此，视图必须使用内部联合（而不是外部联合或UNION）。此外，仅能更新视图定义中的单个表，因此，SET子句必须仅命名视图中某一表的列。即使从理论上讲也是可更新的，不允许使用UNION ALL的视图，这是因为，在实施中将使用临时表来处理它们。</span><br><span class="line"></span><br><span class="line">对于多表可更新视图，如果是将其插入单个表中，INSERT能够工作。不支持DELETE。</span><br><span class="line"></span><br><span class="line">对于可更新视图，可给定WITH CHECK OPTION子句来防止插入或更新行，除非作用在行上的select_statement中的WHERE子句为“真”。</span><br><span class="line"></span><br><span class="line">在关于可更新视图的WITH CHECK OPTION子句中，当视图是根据另一个视图定义的时，LOCAL和CASCADED关键字决定了检查测试的范围。LOCAL关键字对CHECK OPTION进行了限制，使其仅作用在定义的视图上，CASCADED会对将进行评估的基表进行检查。如果未给定任一关键字，默认值为CASCADED。请考虑下述表和视图集合的定义：</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t1 (a INT);</span><br><span class="line">mysql&gt; CREATE VIEW v1 AS SELECT * FROM t1 WHERE a &lt; 2</span><br><span class="line">    -&gt; WITH CHECK OPTION;</span><br><span class="line">mysql&gt; CREATE VIEW v2 AS SELECT * FROM v1 WHERE a &gt; 0</span><br><span class="line">    -&gt; WITH LOCAL CHECK OPTION;</span><br><span class="line">mysql&gt; CREATE VIEW v3 AS SELECT * FROM v1 WHERE a &gt; 0</span><br><span class="line">    -&gt; WITH CASCADED CHECK OPTION;</span><br><span class="line">这里，视图v2和v3是根据另一视图v1定义的。v2具有LOCAL检查选项，因此，仅会针对v2检查对插入项进行测试。v3具有CASCADED检查选项，因此，不仅会针对它自己的检查对插入项进行测试，也会针对基本视图的检查对插入项进行测试。在下面的语句中，介绍了这些差异：</span><br><span class="line"></span><br><span class="line">ql&gt; INSERT INTO v2 VALUES (2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; INSERT INTO v3 VALUES (2);</span><br><span class="line">ERROR 1369 (HY000): CHECK OPTION failed &#x27;test.v3&#x27;</span><br><span class="line">视图的可更新性可能会受到系统变量updatable_views_with_limit的值的影响。请参见5.3.3节，“服务器系统变量”。</span><br><span class="line"></span><br><span class="line">INFORMATION_SCHEMA包含1个VIEWS表，从该表可获取关于视图对象的信息。请参见23.1.15节，“INFORMATION_SCHEMA VIEWS表”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="不懂2"><a href="#不懂2" class="headerlink" title="不懂2"></a>不懂2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">六、视图查询语句的处理</span><br><span class="line"></span><br><span class="line">示例：所有有罚款的球员的信息</span><br><span class="line"></span><br><span class="line">创建视图：</span><br><span class="line"></span><br><span class="line">mysql&gt; create view cost_raisers</span><br><span class="line">    -&gt; as</span><br><span class="line">    -&gt; select * from PLAYERS</span><br><span class="line">    -&gt; where playerno in (select playerno from PENALTIES);</span><br><span class="line">查询视图：</span><br><span class="line"></span><br><span class="line">mysql&gt; select playerno from cost_raisers</span><br><span class="line">    -&gt; where town=&#x27;Stratford&#x27;;</span><br><span class="line">+----------+</span><br><span class="line">| PLAYERNO |</span><br><span class="line">+----------+</span><br><span class="line">|        6 |</span><br><span class="line">+----------+ </span><br><span class="line">1、替代方法：</span><br><span class="line"></span><br><span class="line">　　先把select语句中的视图名使用定义视图的select语句来替代；</span><br><span class="line"></span><br><span class="line">　　再处理所得到的select语句。</span><br><span class="line"></span><br><span class="line">mysql&gt; select playerno from</span><br><span class="line">　　 -&gt; (</span><br><span class="line">    -&gt;   select * from PLAYERS</span><br><span class="line">    -&gt;   where playerno in-&gt;   　　(select playerno from PENALTIES)</span><br><span class="line">    -&gt; )as viewformula</span><br><span class="line">    -&gt; where town=&#x27;Stratford&#x27;;</span><br><span class="line">+----------+</span><br><span class="line">| PLAYERNO |</span><br><span class="line">+----------+</span><br><span class="line">|        6 |</span><br><span class="line">+----------+</span><br><span class="line">2、具体化方法：</span><br><span class="line"></span><br><span class="line">　　先处理定义视图的select语句，这会生成一个中间的结果集；</span><br><span class="line"></span><br><span class="line">　　然后，再在中间结果上执行select查询。</span><br><span class="line"></span><br><span class="line">mysql&gt; select &lt;列名&gt; from &lt;中间结果&gt;;　</span><br></pre></td></tr></table></figure>





<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">触发器（Trigger） </span><br><span class="line">	执行时期： 在操作者对表进行「增删改」 之前（或之后）被触发，自动执行一段事先写好的 SQL 代码。</span><br><span class="line">	[before|after] insert </span><br><span class="line">	[before|after] update</span><br><span class="line">	[before|after] delete    </span><br></pre></td></tr></table></figure>



<h2 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event</span><br><span class="line">    ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">限制</span><br><span class="line">1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。例如，对于某一表，不能有两个BEFORE UPDATE触发程序。但可以有1个BEFORE UPDATE触发程序和1个BEFORE INSERT触发程序，</span><br><span class="line">    </span><br><span class="line">trigger_name 触发器的名字</span><br><span class="line"></span><br><span class="line">trigger_time 触发器执行时机</span><br><span class="line">	这里设置触发器是在关键动作执行之前触发，还是执行之后触发。</span><br><span class="line">	触发程序的动作时间。它可以是BEFORE或AFTER，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">	</span><br><span class="line">trigger_event 触发器监测的对象.</span><br><span class="line">	触发器可以监测 INSERT、UPDATE、DELETE 的操作，当监测的命令对触发器关联的表进行操作时，触发器就被激活了。</span><br><span class="line">	# trigger_event与以表操作方式激活触发程序的SQL语句并不很类似，这点很重要,注意看例子</span><br><span class="line">    INSERT：将新行插入表时激活触发程序，例如，通过INSERT、LOAD DATA和REPLACE语句。</span><br><span class="line">    UPDATE：更改某一行时激活触发程序，例如，通过UPDATE语句。</span><br><span class="line">    DELETE：从表中删除某一行时激活触发程序，例如，通过DELETE和REPLACE语句。</span><br><span class="line">    # 特例</span><br><span class="line">    可能会造成混淆的例子之一是INSERT INTO .. ON DUPLICATE UPDATE ...语法：BEFORE INSERT触发程序对于每一行将激活，后跟AFTER INSERT触发程序，或BEFORE UPDATE和AFTER UPDATE触发程序，具体情况取决于行上是否有重复键。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tbl_name	表名</span><br><span class="line">	将这个触发器与数据库中的表进行关联，触发器定义在表上，也附着在表上，如果这个表被删除了，那么这个触发器也随之被删除。</span><br><span class="line">	必须引用永久性表。不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FOR EACH ROW：</span><br><span class="line">	这句表示只要满足触发器触发条件，触发器都会被执行，也就是说带上这个参数后，触发器将监测每一行对关联表操作的代码，一旦符合条件，触发器就会被触发。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trigger_stmt [触发器主体代码]：</span><br><span class="line">	这里是当满足触发条件后，被触发执行的代码主体。这里可以是一句 SQL 语句，也可以是多行命令。如果是多行命令，那么这些命令要写在 BEGIN...END 之间	[一句sql可以省略begin，但是最好不要省略]</span><br></pre></td></tr></table></figure>







<h2 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




































































































      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunshulei456.github.io/2024/04/21/mysql/mysql%20%E5%9F%BA%E7%A1%80/" data-id="clv9j5m830003f4ti6qpbfqsx" data-title="mysql 基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/04/21/mysql/mysql%20%E6%9D%83%E9%99%90%E5%88%86%E7%A6%BB/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          mysql 权限分离
        
      </div>
    </a>
  
  
    <a href="/2024/04/21/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/21/%E2%80%9C%E6%88%91%E7%9A%84%E6%96%B0%E5%B8%96%E5%AD%902%E2%80%9D/">“我的新帖子2”</a>
          </li>
        
          <li>
            <a href="/2024/04/21/%E2%80%9C%E6%88%91%E7%9A%84%E6%96%B0%E5%B8%96%E5%AD%90%E2%80%9D/">“我的新帖子”</a>
          </li>
        
          <li>
            <a href="/2024/04/21/mysql/mysql%20%E5%87%BD%E6%95%B0/">mysql 函数</a>
          </li>
        
          <li>
            <a href="/2024/04/21/mysql/mysql%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">mysql 安装配置</a>
          </li>
        
          <li>
            <a href="/2024/04/21/mysql/mysql%20%E6%9D%83%E9%99%90%E5%88%86%E7%A6%BB/">mysql 权限分离</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>